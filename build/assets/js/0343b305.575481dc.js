"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[8671],{8453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>r});var a=t(6540);const o={},s=a.createContext(o);function i(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:i(n.components),a.createElement(s.Provider,{value:e},n.children)}},8886:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var a=t(4848),o=t(8453);const s={title:"Chapter 11 - Navigation Systems for Physical AI"},i="Navigation Systems in Physical AI",r={id:"navigation-systems/navigation",title:"Chapter 11 - Navigation Systems for Physical AI",description:"Chapter Overview",source:"@site/docs/physical-ai/navigation-systems/02-navigation.mdx",sourceDirName:"navigation-systems",slug:"/navigation-systems/navigation",permalink:"/navigation-systems/navigation",draft:!1,unlisted:!1,editUrl:"https://github.com/fuzailpalook/new-book/tree/main/docs/physical-ai/navigation-systems/02-navigation.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Chapter 11 - Navigation Systems for Physical AI"},sidebar:"tutorialSidebar",previous:{title:"Chapter 11 - Visual SLAM Fundamentals",permalink:"/navigation-systems/vslam"},next:{title:"Sim-to-Real Transfer Techniques in Robotics",permalink:"/navigation-systems/sim-to-real"}},l={},c=[{value:"Chapter Overview",id:"chapter-overview",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"1. Fundamentals of Robot Navigation",id:"1-fundamentals-of-robot-navigation",level:2},{value:"1.1 Navigation Architecture",id:"11-navigation-architecture",level:3},{value:"1.2 Coordinate Systems and Transformations",id:"12-coordinate-systems-and-transformations",level:3},{value:"2. Global Path Planning",id:"2-global-path-planning",level:2},{value:"2.1 Grid-Based Path Planning",id:"21-grid-based-path-planning",level:3},{value:"A* Algorithm",id:"a-algorithm",level:4},{value:"Dijkstra&#39;s Algorithm",id:"dijkstras-algorithm",level:4},{value:"2.2 Sampling-Based Path Planning",id:"22-sampling-based-path-planning",level:3},{value:"3. Local Path Planning and Obstacle Avoidance",id:"3-local-path-planning-and-obstacle-avoidance",level:2},{value:"3.1 Dynamic Window Approach (DWA)",id:"31-dynamic-window-approach-dwa",level:3},{value:"3.2 Trajectory Rollout",id:"32-trajectory-rollout",level:3},{value:"4. Integration with ROS 2 Navigation Stack",id:"4-integration-with-ros-2-navigation-stack",level:2},{value:"4.1 ROS 2 Navigation 2 (Nav2) Components",id:"41-ros-2-navigation-2-nav2-components",level:3},{value:"4.2 Custom Navigation Plugin",id:"42-custom-navigation-plugin",level:3},{value:"5. Navigation Performance Evaluation",id:"5-navigation-performance-evaluation",level:2},{value:"5.1 Metrics and Evaluation",id:"51-metrics-and-evaluation",level:3},{value:"6. Advanced Navigation Topics",id:"6-advanced-navigation-topics",level:2},{value:"6.1 Multi-Robot Navigation",id:"61-multi-robot-navigation",level:3},{value:"6.2 Navigation in Dynamic Environments",id:"62-navigation-in-dynamic-environments",level:3},{value:"7. Implementation Best Practices",id:"7-implementation-best-practices",level:2},{value:"7.1 Safety Considerations",id:"71-safety-considerations",level:3},{value:"7.2 Performance Optimization",id:"72-performance-optimization",level:3},{value:"7.3 Robustness",id:"73-robustness",level:3},{value:"8. Chapter Summary",id:"8-chapter-summary",level:2},{value:"Exercises",id:"exercises",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h1,{id:"navigation-systems-in-physical-ai",children:"Navigation Systems in Physical AI"}),"\n",(0,a.jsx)(e.h2,{id:"chapter-overview",children:"Chapter Overview"}),"\n",(0,a.jsx)(e.p,{children:"Navigation is a fundamental capability for mobile robots operating in physical environments. This section explores the principles and implementation of navigation systems that enable robots to autonomously plan and execute paths from start to goal positions while avoiding obstacles and respecting environmental constraints. We'll cover both global path planning and local motion control, with emphasis on integration with ROS 2 navigation stack and real-time performance considerations."}),"\n",(0,a.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,a.jsx)(e.p,{children:"By the end of this section, you will be able to:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Implement global path planning algorithms like A*, Dijkstra, and RRT"}),"\n",(0,a.jsx)(e.li,{children:"Design local motion control systems for obstacle avoidance"}),"\n",(0,a.jsx)(e.li,{children:"Integrate navigation with SLAM for simultaneous localization and mapping"}),"\n",(0,a.jsx)(e.li,{children:"Configure and tune ROS 2 Navigation 2 (Nav2) for different robot platforms"}),"\n",(0,a.jsx)(e.li,{children:"Evaluate navigation performance in various environmental conditions"}),"\n",(0,a.jsx)(e.li,{children:"Handle dynamic obstacles and replanning scenarios"}),"\n",(0,a.jsx)(e.li,{children:"Optimize navigation systems for computational efficiency and safety"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"1-fundamentals-of-robot-navigation",children:"1. Fundamentals of Robot Navigation"}),"\n",(0,a.jsx)(e.h3,{id:"11-navigation-architecture",children:"1.1 Navigation Architecture"}),"\n",(0,a.jsx)(e.p,{children:"Robot navigation typically follows a hierarchical architecture with three main components:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Global Path Planning"}),": Computes an optimal path from start to goal based on a map"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Local Path Planning"}),": Generates short-term trajectories that avoid obstacles while following the global path"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Motion Control"}),": Translates planned trajectories into actual robot actuator commands"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"12-coordinate-systems-and-transformations",children:"1.2 Coordinate Systems and Transformations"}),"\n",(0,a.jsx)(e.p,{children:"Navigation systems rely on proper coordinate frame management to transform between different reference frames:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass CoordinateTransform:\n    def __init__(self):\n        self.transforms = {}  # Store transformation matrices between frames\n\n    def add_transform(self, from_frame, to_frame, translation, rotation_quat):\n        """\n        Add a transformation between two coordinate frames\n        """\n        # Create transformation matrix\n        R_mat = R.from_quat(rotation_quat).as_matrix()\n        T = np.eye(4)\n        T[:3, :3] = R_mat\n        T[:3, 3] = translation\n\n        self.transforms[(from_frame, to_frame)] = T\n        # Also store inverse transform\n        self.transforms[(to_frame, from_frame)] = np.linalg.inv(T)\n\n    def transform_point(self, point, from_frame, to_frame):\n        """\n        Transform a point from one frame to another\n        """\n        if (from_frame, to_frame) in self.transforms:\n            T = self.transforms[(from_frame, to_frame)]\n            point_h = np.append(point, 1)  # Homogeneous coordinates\n            transformed = T @ point_h\n            return transformed[:3]  # Return 3D coordinates\n        else:\n            raise ValueError(f"No transform found from {from_frame} to {to_frame}")\n\n# Example usage for robot navigation\nnav_transform = CoordinateTransform()\n# Add transform from robot base to map frame\nnav_transform.add_transform("base_link", "map", [1.0, 2.0, 0.0], [0, 0, 0, 1])\n'})}),"\n",(0,a.jsx)(e.h2,{id:"2-global-path-planning",children:"2. Global Path Planning"}),"\n",(0,a.jsx)(e.h3,{id:"21-grid-based-path-planning",children:"2.1 Grid-Based Path Planning"}),"\n",(0,a.jsx)(e.p,{children:"Grid-based approaches discretize the environment into a 2D or 3D grid where each cell represents free space or obstacles."}),"\n",(0,a.jsx)(e.h4,{id:"a-algorithm",children:"A* Algorithm"}),"\n",(0,a.jsx)(e.p,{children:"A* is a popular pathfinding algorithm that uses a heuristic to guide search toward the goal efficiently:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import heapq\nimport numpy as np\nfrom typing import List, Tuple\n\nclass AStarPlanner:\n    def __init__(self, grid_map: np.ndarray, resolution: float = 1.0):\n        """\n        Initialize A* planner with a grid map\n        grid_map: 2D array where 0 = free space, 1 = obstacle\n        resolution: Size of each grid cell in meters\n        """\n        self.grid = grid_map\n        self.resolution = resolution\n        self.height, self.width = grid_map.shape\n\n    def heuristic(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\n        """\n        Calculate heuristic distance between two positions (Manhattan distance)\n        """\n        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\n    def get_neighbors(self, pos: Tuple[int, int]) -> List[Tuple[int, int]]:\n        """\n        Get valid neighboring positions\n        """\n        neighbors = []\n        for dx, dy in [(-1,0), (1,0), (0,-1), (0,1), (-1,-1), (-1,1), (1,-1), (1,1)]:\n            new_x, new_y = pos[0] + dx, pos[1] + dy\n\n            # Check bounds\n            if 0 <= new_x < self.height and 0 <= new_y < self.width:\n                # Check if cell is free\n                if self.grid[new_x, new_y] == 0:\n                    neighbors.append((new_x, new_y))\n\n        return neighbors\n\n    def plan(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n        """\n        Plan a path from start to goal using A* algorithm\n        """\n        # Priority queue: (f_score, g_score, position)\n        open_set = [(0, 0, start)]\n        heapq.heapify(open_set)\n\n        # Track costs\n        g_score = {start: 0}\n        f_score = {start: self.heuristic(start, goal)}\n\n        # Track path\n        came_from = {}\n\n        while open_set:\n            current_f, current_g, current = heapq.heappop(open_set)\n\n            # Check if we reached the goal\n            if current == goal:\n                # Reconstruct path\n                path = [current]\n                while current in came_from:\n                    current = came_from[current]\n                    path.append(current)\n                path.reverse()\n                return path\n\n            # Explore neighbors\n            for neighbor in self.get_neighbors(current):\n                # Calculate tentative g_score\n                tentative_g = g_score[current] + self.distance(current, neighbor)\n\n                if neighbor not in g_score or tentative_g < g_score[neighbor]:\n                    # This path to neighbor is better than any previous one\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g\n                    f_score[neighbor] = tentative_g + self.heuristic(neighbor, goal)\n\n                    # Add to open set if not already there\n                    heapq.heappush(open_set, (f_score[neighbor], g_score[neighbor], neighbor))\n\n        # No path found\n        return []\n\n    def distance(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\n        """\n        Calculate distance between two adjacent positions\n        """\n        if pos1[0] == pos2[0] or pos1[1] == pos2[1]:\n            # Adjacent horizontally or vertically\n            return 1.0\n        else:\n            # Diagonal movement\n            return np.sqrt(2)\n\n# Example usage\ndef create_simple_map():\n    """\n    Create a simple 10x10 map with some obstacles\n    """\n    grid = np.zeros((10, 10))\n    # Add some obstacles\n    grid[3, 3:7] = 1  # Horizontal wall\n    grid[5:8, 5] = 1  # Vertical wall\n    return grid\n\n# Plan a path\ngrid_map = create_simple_map()\nplanner = AStarPlanner(grid_map)\npath = planner.plan((1, 1), (8, 8))\nprint(f"Path found: {path}")\n'})}),"\n",(0,a.jsx)(e.h4,{id:"dijkstras-algorithm",children:"Dijkstra's Algorithm"}),"\n",(0,a.jsx)(e.p,{children:"Dijkstra's algorithm finds the shortest path without using a heuristic, making it optimal but potentially slower:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import heapq\nimport numpy as np\nfrom typing import List, Tuple\n\nclass DijkstraPlanner:\n    def __init__(self, grid_map: np.ndarray, resolution: float = 1.0):\n        """\n        Initialize Dijkstra planner with a grid map\n        """\n        self.grid = grid_map\n        self.resolution = resolution\n        self.height, self.width = grid_map.shape\n\n    def get_neighbors(self, pos: Tuple[int, int]) -> List[Tuple[int, int]]:\n        """\n        Get valid neighboring positions\n        """\n        neighbors = []\n        for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:\n            new_x, new_y = pos[0] + dx, pos[1] + dy\n\n            # Check bounds\n            if 0 <= new_x < self.height and 0 <= new_y < self.width:\n                # Check if cell is free\n                if self.grid[new_x, new_y] == 0:\n                    neighbors.append((new_x, new_y))\n\n        return neighbors\n\n    def plan(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n        """\n        Plan a path from start to goal using Dijkstra\'s algorithm\n        """\n        # Priority queue: (distance, position)\n        pq = [(0, start)]\n        heapq.heapify(pq)\n\n        # Track distances and visited nodes\n        distances = {start: 0}\n        visited = set()\n        came_from = {}\n\n        while pq:\n            current_dist, current = heapq.heappop(pq)\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            # Check if we reached the goal\n            if current == goal:\n                # Reconstruct path\n                path = [current]\n                while current in came_from:\n                    current = came_from[current]\n                    path.append(current)\n                path.reverse()\n                return path\n\n            # Explore neighbors\n            for neighbor in self.get_neighbors(current):\n                if neighbor in visited:\n                    continue\n\n                # Calculate tentative distance\n                tentative_dist = current_dist + 1  # Assuming unit cost for adjacent cells\n\n                if neighbor not in distances or tentative_dist < distances[neighbor]:\n                    distances[neighbor] = tentative_dist\n                    came_from[neighbor] = current\n                    heapq.heappush(pq, (tentative_dist, neighbor))\n\n        # No path found\n        return []\n'})}),"\n",(0,a.jsx)(e.h3,{id:"22-sampling-based-path-planning",children:"2.2 Sampling-Based Path Planning"}),"\n",(0,a.jsx)(e.p,{children:"Sampling-based methods like RRT (Rapidly-exploring Random Trees) are effective for high-dimensional spaces:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import Tuple, List\nimport random\n\nclass RRTPlanner:\n    def __init__(self, bounds: Tuple[float, float, float, float],\n                 obstacles: List[Tuple[float, float, float]],\n                 step_size: float = 0.5):\n        """\n        Initialize RRT planner\n        bounds: (x_min, x_max, y_min, y_max)\n        obstacles: List of (x, y, radius) tuples representing circular obstacles\n        step_size: Maximum distance to extend tree at each step\n        """\n        self.bounds = bounds\n        self.obstacles = obstacles\n        self.step_size = step_size\n\n        # Tree structure: {node: parent}\n        self.tree = {}\n        self.nodes = []  # List of (x, y) coordinates\n\n    def is_collision_free(self, point: Tuple[float, float]) -> bool:\n        """\n        Check if a point is collision-free\n        """\n        x, y = point\n\n        # Check bounds\n        if not (self.bounds[0] <= x <= self.bounds[1] and\n                self.bounds[2] <= y <= self.bounds[3]):\n            return False\n\n        # Check obstacles\n        for obs_x, obs_y, radius in self.obstacles:\n            distance = np.sqrt((x - obs_x)**2 + (y - obs_y)**2)\n            if distance <= radius:\n                return False\n\n        return True\n\n    def nearest_node(self, point: Tuple[float, float]) -> Tuple[float, float]:\n        """\n        Find the nearest node in the tree to the given point\n        """\n        if not self.nodes:\n            return None\n\n        min_dist = float(\'inf\')\n        nearest = None\n\n        for node in self.nodes:\n            dist = np.sqrt((point[0] - node[0])**2 + (point[1] - node[1])**2)\n            if dist < min_dist:\n                min_dist = dist\n                nearest = node\n\n        return nearest\n\n    def extend_toward(self, from_node: Tuple[float, float],\n                     to_point: Tuple[float, float]) -> Tuple[float, float]:\n        """\n        Extend the tree from from_node toward to_point\n        """\n        dx = to_point[0] - from_node[0]\n        dy = to_point[1] - from_node[1]\n        distance = np.sqrt(dx**2 + dy**2)\n\n        if distance <= self.step_size:\n            return to_point\n        else:\n            # Move step_size distance toward the target\n            scale = self.step_size / distance\n            new_x = from_node[0] + dx * scale\n            new_y = from_node[1] + dy * scale\n            return (new_x, new_y)\n\n    def plan(self, start: Tuple[float, float], goal: Tuple[float, float],\n             max_iterations: int = 1000) -> List[Tuple[float, float]]:\n        """\n        Plan a path from start to goal using RRT\n        """\n        # Initialize tree with start node\n        self.tree[start] = None\n        self.nodes = [start]\n\n        for _ in range(max_iterations):\n            # Sample random point (bias toward goal)\n            if random.random() < 0.1:  # 10% chance to sample goal\n                rand_point = goal\n            else:\n                rand_point = (\n                    random.uniform(self.bounds[0], self.bounds[1]),\n                    random.uniform(self.bounds[2], self.bounds[3])\n                )\n\n            # Find nearest node in tree\n            nearest = self.nearest_node(rand_point)\n            if nearest is None:\n                continue\n\n            # Extend toward random point\n            new_point = self.extend_toward(nearest, rand_point)\n\n            # Check if path is collision-free\n            if self.is_collision_free(new_point):\n                # Add to tree\n                self.tree[new_point] = nearest\n                self.nodes.append(new_point)\n\n                # Check if we\'re close to goal\n                dist_to_goal = np.sqrt((new_point[0] - goal[0])**2 +\n                                      (new_point[1] - goal[1])**2)\n                if dist_to_goal < self.step_size:\n                    # Reconstruct path to goal\n                    path = [goal]\n                    current = new_point\n                    while current is not None:\n                        path.append(current)\n                        current = self.tree[current]\n                    path.reverse()\n                    return path\n\n        # No path found\n        return []\n'})}),"\n",(0,a.jsx)(e.h2,{id:"3-local-path-planning-and-obstacle-avoidance",children:"3. Local Path Planning and Obstacle Avoidance"}),"\n",(0,a.jsx)(e.h3,{id:"31-dynamic-window-approach-dwa",children:"3.1 Dynamic Window Approach (DWA)"}),"\n",(0,a.jsx)(e.p,{children:"The Dynamic Window Approach is a local planning method that considers robot dynamics and constraints:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import numpy as np\nfrom typing import Tuple, List\n\nclass DynamicWindowApproach:\n    def __init__(self, robot_params: dict):\n        \"\"\"\n        Initialize DWA with robot parameters\n        robot_params: {\n            'max_vel_x': maximum linear velocity,\n            'min_vel_x': minimum linear velocity,\n            'max_vel_theta': maximum angular velocity,\n            'min_vel_theta': minimum angular velocity,\n            'max_accel_x': maximum linear acceleration,\n            'max_accel_theta': maximum angular acceleration,\n            'dt': time step,\n            'predict_time': prediction horizon,\n            'to_goal_cost_gain': weight for goal cost,\n            'speed_cost_gain': weight for speed cost,\n            'obstacle_cost_gain': weight for obstacle cost\n        }\n        \"\"\"\n        self.params = robot_params\n\n    def motion(self, x: np.ndarray, u: np.ndarray, dt: float) -> np.ndarray:\n        \"\"\"\n        Motion model: update robot state based on control input\n        x = [x, y, theta, vel_x, vel_theta]\n        u = [vel_x, vel_theta]\n        \"\"\"\n        x[0] += u[0] * np.cos(x[2]) * dt\n        x[1] += u[0] * np.sin(x[2]) * dt\n        x[2] += u[1] * dt\n        x[3] = u[0]\n        x[4] = u[1]\n        return x\n\n    def calc_dynamic_window(self, state: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculate dynamic window based on current state and constraints\n        \"\"\"\n        # Dynamic window = [min_vel_x, max_vel_x, min_vel_theta, max_vel_theta]\n        vs = np.array([\n            self.params['min_vel_x'],\n            self.params['max_vel_x'],\n            -self.params['max_vel_theta'],\n            self.params['max_vel_theta']\n        ])\n\n        # Velocity window based on acceleration limits\n        vd = np.array([\n            state[3] - self.params['max_accel_x'] * self.params['dt'],\n            state[3] + self.params['max_accel_x'] * self.params['dt'],\n            state[4] - self.params['max_accel_theta'] * self.params['dt'],\n            state[4] + self.params['max_accel_theta'] * self.params['dt']\n        ])\n\n        # Take intersection of both windows\n        dw = np.array([\n            max(vs[0], vd[0]),\n            min(vs[1], vd[1]),\n            max(vs[2], vd[2]),\n            min(vs[3], vd[3])\n        ])\n\n        return dw\n\n    def calc_trajectory(self, state: np.ndarray, vel_x: float, vel_theta: float) -> np.ndarray:\n        \"\"\"\n        Calculate trajectory for given velocities\n        \"\"\"\n        x = state.copy()\n        trajectory = np.array([x])\n\n        time = 0\n        while time <= self.params['predict_time']:\n            x = self.motion(x, [vel_x, vel_theta], self.params['dt'])\n            trajectory = np.vstack((trajectory, x))\n            time += self.params['dt']\n\n        return trajectory\n\n    def calc_obstacle_cost(self, trajectory: np.ndarray, obstacles: np.ndarray) -> float:\n        \"\"\"\n        Calculate cost due to obstacles\n        \"\"\"\n        min_dist = float('inf')\n\n        for i in range(len(trajectory)):\n            for obs in obstacles:\n                dist = np.sqrt((trajectory[i, 0] - obs[0])**2 +\n                              (trajectory[i, 1] - obs[1])**2)\n                if dist <= min_dist:\n                    min_dist = dist\n\n        # Cost is inverse of minimum distance (higher cost for closer obstacles)\n        if min_dist == 0:\n            return float('inf')\n        return 1.0 / min_dist\n\n    def calc_to_goal_cost(self, trajectory: np.ndarray, goal: np.ndarray) -> float:\n        \"\"\"\n        Calculate cost to goal based on final position\n        \"\"\"\n        dx = goal[0] - trajectory[-1, 0]\n        dy = goal[1] - trajectory[-1, 1]\n        error_angle = np.arctan2(dy, dx)\n        cost_angle = error_angle - trajectory[-1, 2]\n        cost = abs(np.arctan2(np.sin(cost_angle), np.cos(cost_angle)))\n        return cost\n\n    def dwa_control(self, state: np.ndarray, goal: np.ndarray,\n                   obstacles: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Dynamic Window Approach control\n        \"\"\"\n        dw = self.calc_dynamic_window(state)\n\n        min_cost = float('inf')\n        best_u = np.array([0.0, 0.0])\n        best_trajectory = np.array([state])\n\n        # Evaluate all possible velocities in dynamic window\n        v_vel_x = np.arange(dw[0], dw[1], 0.1)\n        v_vel_theta = np.arange(dw[2], dw[3], 0.1)\n\n        for vel_x in v_vel_x:\n            for vel_theta in v_vel_theta:\n                # Generate trajectory for this velocity\n                trajectory = self.calc_trajectory(state, vel_x, vel_theta)\n\n                # Calculate costs\n                to_goal_cost = self.calc_to_goal_cost(trajectory, goal) * self.params['to_goal_cost_gain']\n                speed_cost = (self.params['max_vel_x'] - trajectory[-1, 3]) * self.params['speed_cost_gain']\n                ob_cost = self.calc_obstacle_cost(trajectory, obstacles) * self.params['obstacle_cost_gain']\n\n                final_cost = to_goal_cost + speed_cost + ob_cost\n\n                if min_cost >= final_cost:\n                    min_cost = final_cost\n                    best_u = [vel_x, vel_theta]\n                    best_trajectory = trajectory\n\n        return best_u, best_trajectory\n"})}),"\n",(0,a.jsx)(e.h3,{id:"32-trajectory-rollout",children:"3.2 Trajectory Rollout"}),"\n",(0,a.jsx)(e.p,{children:"Trajectory rollout evaluates multiple possible paths and selects the best one:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Tuple\n\nclass TrajectoryRollout:\n    def __init__(self, robot_config: dict):\n        self.config = robot_config\n        self.dt = robot_config.get(\'dt\', 0.1)\n        self.horizon = robot_config.get(\'horizon\', 2.0)\n        self.steps = int(self.horizon / self.dt)\n\n    def predict_motion(self, state: np.ndarray, cmd_vel: np.ndarray) -> np.ndarray:\n        """\n        Predict robot motion for a given command velocity\n        state = [x, y, theta, vel_x, vel_y, vel_theta]\n        cmd_vel = [vel_x, vel_theta]\n        """\n        next_state = state.copy()\n        dt = self.dt\n\n        # Update position based on current velocity\n        next_state[0] += cmd_vel[0] * np.cos(state[2]) * dt\n        next_state[1] += cmd_vel[0] * np.sin(state[2]) * dt\n        next_state[2] += cmd_vel[1] * dt\n\n        # Update velocities\n        next_state[3] = cmd_vel[0]  # Linear x velocity\n        next_state[5] = cmd_vel[1]  # Angular velocity\n\n        return next_state\n\n    def evaluate_trajectory(self, trajectory: List[np.ndarray],\n                           goal: np.ndarray, obstacles: List[np.ndarray]) -> float:\n        """\n        Evaluate a trajectory based on multiple criteria\n        """\n        # Calculate trajectory length penalty\n        length_penalty = 0\n        for i in range(1, len(trajectory)):\n            dx = trajectory[i][0] - trajectory[i-1][0]\n            dy = trajectory[i][1] - trajectory[i-1][1]\n            length_penalty += np.sqrt(dx**2 + dy**2)\n\n        # Calculate distance to goal\n        final_pos = trajectory[-1][:2]\n        goal_dist = np.sqrt((final_pos[0] - goal[0])**2 + (final_pos[1] - goal[1])**2)\n\n        # Calculate obstacle proximity cost\n        obstacle_cost = 0\n        for state in trajectory:\n            for obs in obstacles:\n                dist = np.sqrt((state[0] - obs[0])**2 + (state[1] - obs[1])**2)\n                if dist < 1.0:  # Within 1m of obstacle\n                    obstacle_cost += 1.0 / (dist + 0.01)  # Higher cost for closer obstacles\n\n        # Calculate smoothness penalty\n        smoothness_penalty = 0\n        if len(trajectory) > 2:\n            for i in range(1, len(trajectory) - 1):\n                p1 = trajectory[i-1][:2]\n                p2 = trajectory[i][:2]\n                p3 = trajectory[i+1][:2]\n\n                # Calculate curvature (simplified)\n                v1 = p2 - p1\n                v2 = p3 - p2\n                dot_product = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2) + 1e-6)\n                curvature = 1 - abs(dot_product)  # Higher for sharp turns\n                smoothness_penalty += curvature\n\n        # Weighted combination of costs\n        total_cost = (1.0 * goal_dist +\n                     0.1 * length_penalty +\n                     5.0 * obstacle_cost +\n                     0.5 * smoothness_penalty)\n\n        return total_cost\n\n    def generate_trajectories(self, state: np.ndarray) -> List[Tuple[List[np.ndarray], float]]:\n        """\n        Generate multiple possible trajectories\n        """\n        trajectories = []\n\n        # Define possible velocity commands\n        vel_x_options = np.linspace(0.0, self.config[\'max_vel_x\'], 5)\n        vel_theta_options = np.linspace(-self.config[\'max_vel_theta\'],\n                                       self.config[\'max_vel_theta\'], 7)\n\n        for vel_x in vel_x_options:\n            for vel_theta in vel_theta_options:\n                cmd_vel = np.array([vel_x, vel_theta])\n\n                # Generate trajectory for this command\n                trajectory = [state.copy()]\n                current_state = state.copy()\n\n                for _ in range(self.steps):\n                    current_state = self.predict_motion(current_state, cmd_vel)\n                    trajectory.append(current_state.copy())\n\n                trajectories.append((trajectory, cmd_vel))\n\n        return trajectories\n\n    def select_best_trajectory(self, state: np.ndarray, goal: np.ndarray,\n                              obstacles: List[np.ndarray]) -> np.ndarray:\n        """\n        Select the best trajectory based on evaluation\n        """\n        trajectories = self.generate_trajectories(state)\n\n        best_cost = float(\'inf\')\n        best_cmd_vel = np.array([0.0, 0.0])\n\n        for trajectory, cmd_vel in trajectories:\n            cost = self.evaluate_trajectory(trajectory, goal, obstacles)\n\n            if cost < best_cost:\n                best_cost = cost\n                best_cmd_vel = cmd_vel\n\n        return best_cmd_vel\n'})}),"\n",(0,a.jsx)(e.h2,{id:"4-integration-with-ros-2-navigation-stack",children:"4. Integration with ROS 2 Navigation Stack"}),"\n",(0,a.jsx)(e.h3,{id:"41-ros-2-navigation-2-nav2-components",children:"4.1 ROS 2 Navigation 2 (Nav2) Components"}),"\n",(0,a.jsx)(e.p,{children:"The ROS 2 Navigation 2 stack provides a complete navigation framework with plugins for different components:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Example ROS 2 Navigation node\nimport rclpy\nfrom rclpy.node import Node\nfrom nav2_msgs.action import NavigateToPose\nfrom geometry_msgs.msg import PoseStamped\nfrom sensor_msgs.msg import LaserScan\nfrom nav_msgs.msg import OccupancyGrid\nimport tf2_ros\nfrom rclpy.action import ActionClient\n\nclass NavigationNode(Node):\n    def __init__(self):\n        super().__init__(\'navigation_node\')\n\n        # Action client for navigation\n        self.nav_client = ActionClient(self, NavigateToPose, \'navigate_to_pose\')\n\n        # Subscribers\n        self.scan_sub = self.create_subscription(\n            LaserScan,\n            \'/scan\',\n            self.scan_callback,\n            10\n        )\n\n        self.map_sub = self.create_subscription(\n            OccupancyGrid,\n            \'/map\',\n            self.map_callback,\n            10\n        )\n\n        # TF buffer for coordinate transforms\n        self.tf_buffer = tf2_ros.Buffer()\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)\n\n        # Navigation parameters\n        self.global_frame = \'map\'\n        self.robot_frame = \'base_link\'\n\n        # Wait for navigation server\n        self.nav_client.wait_for_server()\n\n    def navigate_to_pose(self, x: float, y: float, theta: float) -> None:\n        """\n        Navigate to a specific pose\n        """\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.frame_id = self.global_frame\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\n\n        goal_msg.pose.pose.position.x = x\n        goal_msg.pose.pose.position.y = y\n        goal_msg.pose.pose.position.z = 0.0\n\n        # Convert theta to quaternion\n        from math import sin, cos\n        s = sin(theta / 2.0)\n        c = cos(theta / 2.0)\n        goal_msg.pose.pose.orientation.x = 0.0\n        goal_msg.pose.pose.orientation.y = 0.0\n        goal_msg.pose.pose.orientation.z = s\n        goal_msg.pose.pose.orientation.w = c\n\n        # Send navigation goal\n        self.nav_client.send_goal_async(goal_msg)\n\n    def scan_callback(self, msg: LaserScan) -> None:\n        """\n        Process laser scan data for obstacle detection\n        """\n        # Process scan data for local obstacle avoidance\n        # This would typically be handled by the Nav2 local planner\n        pass\n\n    def map_callback(self, msg: OccupancyGrid) -> None:\n        """\n        Process map data for global planning\n        """\n        # Store map for global path planning\n        # This would typically be handled by the Nav2 global planner\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n    nav_node = NavigationNode()\n\n    # Example: Navigate to position (5.0, 5.0) with orientation 0\n    nav_node.navigate_to_pose(5.0, 5.0, 0.0)\n\n    try:\n        rclpy.spin(nav_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        nav_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(e.h3,{id:"42-custom-navigation-plugin",children:"4.2 Custom Navigation Plugin"}),"\n",(0,a.jsx)(e.p,{children:"Creating a custom navigation plugin for specific requirements:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Custom local planner plugin\nimport numpy as np\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\nfrom nav_msgs.msg import Odometry\nfrom tf2_ros import TransformException\nimport tf2_geometry_msgs\nimport tf2_ros\n\nclass CustomLocalPlanner:\n    def __init__(self):\n        self.max_vel_x = 0.5  # m/s\n        self.max_vel_theta = 1.0  # rad/s\n        self.min_vel_x = 0.1\n        self.safe_distance = 0.5  # meters\n        self.obstacle_threshold = 0.3  # meters\n\n        # Goal following parameters\n        self.kp_linear = 1.0\n        self.kp_angular = 2.0\n\n        # Current state\n        self.current_pose = None\n        self.current_twist = None\n        self.laser_data = None\n        self.goal_pose = None\n\n    def set_goal(self, goal_pose):\n        """\n        Set the navigation goal\n        """\n        self.goal_pose = goal_pose\n\n    def update_laser_data(self, laser_msg):\n        """\n        Update laser scan data\n        """\n        self.laser_data = laser_msg\n\n    def update_odometry(self, odom_msg):\n        """\n        Update robot odometry\n        """\n        self.current_pose = odom_msg.pose.pose\n        self.current_twist = odom_msg.twist.twist\n\n    def obstacle_in_direction(self, angle, laser_data):\n        """\n        Check for obstacles in a specific direction\n        """\n        if laser_data is None:\n            return False\n\n        # Calculate the index for the given angle\n        angle_min = laser_data.angle_min\n        angle_increment = laser_data.angle_increment\n        index = int((angle - angle_min) / angle_increment)\n\n        if 0 <= index < len(laser_data.ranges):\n            range_val = laser_data.ranges[index]\n            return range_val < self.obstacle_threshold\n\n        return False\n\n    def compute_velocity_commands(self):\n        """\n        Compute velocity commands based on current state and goal\n        """\n        if self.goal_pose is None or self.current_pose is None:\n            return Twist()\n\n        # Calculate error to goal\n        dx = self.goal_pose.position.x - self.current_pose.position.x\n        dy = self.goal_pose.position.y - self.current_pose.position.y\n        distance_to_goal = np.sqrt(dx**2 + dy**2)\n\n        # Calculate goal angle\n        goal_angle = np.arctan2(dy, dx)\n\n        # Get current robot angle from quaternion\n        q = self.current_pose.orientation\n        current_angle = np.arctan2(\n            2.0 * (q.w * q.z + q.x * q.y),\n            1.0 - 2.0 * (q.y * q.y + q.z * q.z)\n        )\n\n        # Calculate angle error\n        angle_error = goal_angle - current_angle\n        angle_error = np.arctan2(np.sin(angle_error), np.cos(angle_error))  # Normalize to [-pi, pi]\n\n        cmd_vel = Twist()\n\n        # Check for obstacles\n        if self.laser_data is not None:\n            # Check forward direction\n            if self.obstacle_in_direction(0.0, self.laser_data):\n                # Stop or slow down if obstacle ahead\n                cmd_vel.linear.x = 0.0\n                cmd_vel.angular.z = self.kp_angular * angle_error\n                return cmd_vel\n\n            # Check left and right for obstacles\n            left_clear = not self.obstacle_in_direction(0.5, self.laser_data)\n            right_clear = not self.obstacle_in_direction(-0.5, self.laser_data)\n\n            # If path is blocked but not directly ahead, try to turn\n            if not left_clear and not right_clear:\n                cmd_vel.angular.z = self.kp_angular * 0.5  # Turn right\n                return cmd_vel\n\n        # Normal navigation behavior\n        if distance_to_goal > 0.1:  # If not close to goal\n            # Proportional control for linear velocity\n            cmd_vel.linear.x = min(self.kp_linear * distance_to_goal, self.max_vel_x)\n\n            # Proportional control for angular velocity\n            cmd_vel.angular.z = self.kp_angular * angle_error\n        else:\n            # Close to goal, slow down\n            cmd_vel.linear.x = 0.0\n            cmd_vel.angular.z = 0.0\n\n        # Apply velocity limits\n        cmd_vel.linear.x = max(min(cmd_vel.linear.x, self.max_vel_x), 0.0)\n        cmd_vel.angular.z = max(min(cmd_vel.angular.z, self.max_vel_theta), -self.max_vel_theta)\n\n        return cmd_vel\n'})}),"\n",(0,a.jsx)(e.h2,{id:"5-navigation-performance-evaluation",children:"5. Navigation Performance Evaluation"}),"\n",(0,a.jsx)(e.h3,{id:"51-metrics-and-evaluation",children:"5.1 Metrics and Evaluation"}),"\n",(0,a.jsx)(e.p,{children:"Evaluating navigation performance requires several key metrics:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import numpy as np\nfrom typing import List, Tuple\nimport matplotlib.pyplot as plt\n\nclass NavigationEvaluator:\n    def __init__(self):\n        self.trajectory_history = []\n        self.execution_times = []\n        self.success_count = 0\n        self.total_attempts = 0\n\n    def add_trajectory(self, trajectory: List[Tuple[float, float]],\n                      execution_time: float, success: bool):\n        \"\"\"\n        Add a completed navigation trajectory for evaluation\n        \"\"\"\n        self.trajectory_history.append(trajectory)\n        self.execution_times.append(execution_time)\n        self.total_attempts += 1\n        if success:\n            self.success_count += 1\n\n    def calculate_path_efficiency(self, planned_path: List[Tuple[float, float]],\n                                 executed_path: List[Tuple[float, float]]) -> float:\n        \"\"\"\n        Calculate path efficiency as ratio of optimal path length to actual path length\n        \"\"\"\n        if len(planned_path) < 2 or len(executed_path) < 2:\n            return 0.0\n\n        # Calculate planned path length\n        planned_length = 0\n        for i in range(1, len(planned_path)):\n            dx = planned_path[i][0] - planned_path[i-1][0]\n            dy = planned_path[i][1] - planned_path[i-1][1]\n            planned_length += np.sqrt(dx**2 + dy**2)\n\n        # Calculate executed path length\n        executed_length = 0\n        for i in range(1, len(executed_path)):\n            dx = executed_path[i][0] - executed_path[i-1][0]\n            dy = executed_path[i][1] - executed_path[i-1][1]\n            executed_length += np.sqrt(dx**2 + dy**2)\n\n        if planned_length == 0:\n            return 0.0\n\n        return planned_length / executed_length if executed_length > 0 else 0.0\n\n    def calculate_smoothness(self, path: List[Tuple[float, float]]) -> float:\n        \"\"\"\n        Calculate path smoothness based on curvature\n        \"\"\"\n        if len(path) < 3:\n            return 1.0  # Perfectly smooth for short paths\n\n        total_curvature = 0.0\n        segments = 0\n\n        for i in range(1, len(path) - 1):\n            p1 = np.array(path[i-1])\n            p2 = np.array(path[i])\n            p3 = np.array(path[i+1])\n\n            # Calculate vectors\n            v1 = p2 - p1\n            v2 = p3 - p2\n\n            # Calculate angle between segments\n            cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2) + 1e-6)\n            angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n            # Curvature is proportional to change in direction\n            total_curvature += abs(np.pi - angle)\n            segments += 1\n\n        if segments == 0:\n            return 1.0\n\n        # Convert to smoothness (inverse of curvature)\n        avg_curvature = total_curvature / segments\n        smoothness = 1.0 / (1.0 + avg_curvature)  # Higher is better\n\n        return smoothness\n\n    def evaluate_navigation_performance(self) -> dict:\n        \"\"\"\n        Evaluate overall navigation performance\n        \"\"\"\n        if self.total_attempts == 0:\n            return {}\n\n        results = {}\n\n        # Success rate\n        results['success_rate'] = self.success_count / self.total_attempts\n\n        # Average execution time\n        if self.execution_times:\n            results['avg_execution_time'] = np.mean(self.execution_times)\n            results['std_execution_time'] = np.std(self.execution_times)\n\n        # Path efficiency (if we have trajectory data)\n        if self.trajectory_history:\n            efficiencies = []\n            smoothnesses = []\n\n            for traj in self.trajectory_history:\n                if len(traj) > 1:\n                    # For evaluation, we'd need both planned and executed paths\n                    # Here we'll just evaluate the smoothness of the executed path\n                    smoothness = self.calculate_smoothness(traj)\n                    smoothnesses.append(smoothness)\n\n            if smoothnesses:\n                results['avg_smoothness'] = np.mean(smoothnesses)\n                results['std_smoothness'] = np.std(smoothnesses)\n\n        return results\n\n    def plot_performance(self):\n        \"\"\"\n        Plot navigation performance metrics\n        \"\"\"\n        if not self.execution_times:\n            print(\"No execution time data to plot\")\n            return\n\n        fig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n        # Execution time histogram\n        axes[0, 0].hist(self.execution_times, bins=20)\n        axes[0, 0].set_title('Execution Time Distribution')\n        axes[0, 0].set_xlabel('Time (s)')\n        axes[0, 0].set_ylabel('Frequency')\n\n        # Success rate\n        axes[0, 1].bar(['Success', 'Failure'],\n                      [self.success_count, self.total_attempts - self.success_count])\n        axes[0, 1].set_title(f'Success Rate: {self.success_count/self.total_attempts:.2%}')\n        axes[0, 1].set_ylabel('Count')\n\n        # Trajectory examples (if available)\n        if self.trajectory_history and len(self.trajectory_history) > 0:\n            for i, traj in enumerate(self.trajectory_history[:3]):  # Show first 3 trajectories\n                if len(traj) > 1:\n                    x_coords = [point[0] for point in traj]\n                    y_coords = [point[1] for point in traj]\n                    axes[1, 0].plot(x_coords, y_coords, label=f'Trajectory {i+1}', alpha=0.7)\n\n            axes[1, 0].set_title('Navigation Trajectories')\n            axes[1, 0].set_xlabel('X (m)')\n            axes[1, 0].set_ylabel('Y (m)')\n            axes[1, 0].legend()\n            axes[1, 0].grid(True)\n\n        # Success rate over time (if we had time-ordered data)\n        cumulative_success = []\n        for i in range(1, len(self.execution_times) + 1):\n            subset_success = sum(1 for j in range(i)\n                               if j < self.success_count) / i if i <= self.success_count else self.success_count / i\n            cumulative_success.append(subset_success)\n\n        if cumulative_success:\n            axes[1, 1].plot(range(1, len(cumulative_success) + 1), cumulative_success)\n            axes[1, 1].set_title('Cumulative Success Rate')\n            axes[1, 1].set_xlabel('Attempt Number')\n            axes[1, 1].set_ylabel('Success Rate')\n            axes[1, 1].grid(True)\n\n        plt.tight_layout()\n        plt.show()\n"})}),"\n",(0,a.jsx)(e.h2,{id:"6-advanced-navigation-topics",children:"6. Advanced Navigation Topics"}),"\n",(0,a.jsx)(e.h3,{id:"61-multi-robot-navigation",children:"6.1 Multi-Robot Navigation"}),"\n",(0,a.jsx)(e.p,{children:"Coordinating navigation for multiple robots requires additional considerations for collision avoidance:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import Dict, List, Tuple\nfrom dataclasses import dataclass\n\n@dataclass\nclass RobotState:\n    position: Tuple[float, float]\n    velocity: Tuple[float, float]\n    radius: float\n    id: int\n\nclass MultiRobotNavigator:\n    def __init__(self, safety_margin: float = 0.5):\n        self.safety_margin = safety_margin\n        self.robots: Dict[int, RobotState] = {}\n        self.prediction_horizon = 2.0  # seconds\n        self.time_step = 0.1  # seconds\n\n    def add_robot(self, robot_id: int, position: Tuple[float, float],\n                  velocity: Tuple[float, float], radius: float = 0.3):\n        """\n        Add a robot to the navigation system\n        """\n        self.robots[robot_id] = RobotState(position, velocity, radius, robot_id)\n\n    def update_robot_state(self, robot_id: int, position: Tuple[float, float],\n                          velocity: Tuple[float, float]):\n        """\n        Update a robot\'s state\n        """\n        if robot_id in self.robots:\n            self.robots[robot_id].position = position\n            self.robots[robot_id].velocity = velocity\n\n    def predict_collision(self, robot1: RobotState, robot2: RobotState) -> bool:\n        """\n        Predict if two robots will collide based on their current velocities\n        """\n        # Simple collision prediction using constant velocity model\n        pos1 = np.array(robot1.position)\n        vel1 = np.array(robot1.velocity)\n        pos2 = np.array(robot2.position)\n        vel2 = np.array(robot2.velocity)\n\n        # Relative position and velocity\n        rel_pos = pos2 - pos1\n        rel_vel = vel2 - vel1\n\n        # Minimum distance between trajectories\n        # This is a simplified approach - full implementation would be more complex\n        min_distance = np.linalg.norm(rel_pos)\n\n        # If robots are already too close, consider it a collision risk\n        combined_radius = robot1.radius + robot2.radius + self.safety_margin\n        return min_distance < combined_radius\n\n    def compute_velocity_obstacles(self, robot_id: int, other_robot_id: int) -> List[Tuple[float, float]]:\n        """\n        Compute velocity obstacles for collision avoidance\n        """\n        robot = self.robots[robot_id]\n        other = self.robots[other_robot_id]\n\n        # Vector from other robot to this robot\n        rel_pos = np.array(robot.position) - np.array(other.position)\n        distance = np.linalg.norm(rel_pos)\n\n        if distance == 0:\n            return []  # Same position, avoid all velocities\n\n        # Unit vector pointing from other to this\n        rel_dir = rel_pos / distance\n\n        # Combined radius with safety margin\n        combined_radius = robot.radius + other.radius + self.safety_margin\n\n        # Velocity obstacle is a cone around the "collision velocity"\n        collision_velocity = np.array(other.velocity) + rel_dir * (combined_radius / self.prediction_horizon)\n\n        # Return a simple velocity obstacle region\n        obstacle_cone = []\n        for angle_offset in np.linspace(-0.5, 0.5, 5):\n            rotated_dir = np.array([\n                rel_dir[0] * np.cos(angle_offset) - rel_dir[1] * np.sin(angle_offset),\n                rel_dir[0] * np.sin(angle_offset) + rel_dir[1] * np.cos(angle_offset)\n            ])\n            obstacle_cone.append(tuple(collision_velocity + rotated_dir * 0.2))\n\n        return obstacle_cone\n\n    def avoid_collisions(self, robot_id: int, desired_velocity: Tuple[float, float]) -> Tuple[float, float]:\n        """\n        Adjust desired velocity to avoid collisions with other robots\n        """\n        if robot_id not in self.robots:\n            return desired_velocity\n\n        robot = self.robots[robot_id]\n\n        # Check against all other robots\n        for other_id, other_robot in self.robots.items():\n            if other_id == robot_id:\n                continue\n\n            # Compute velocity obstacles\n            vo = self.compute_velocity_obstacles(robot_id, other_id)\n\n            # If desired velocity is in velocity obstacle, adjust it\n            desired_vec = np.array(desired_velocity)\n            for vo_point in vo:\n                vo_vec = np.array(vo_point)\n                # Simple adjustment: move away from the velocity obstacle\n                if np.linalg.norm(desired_vec - vo_vec) < 0.2:  # If too close to obstacle\n                    avoidance_vec = desired_vec - vo_vec\n                    avoidance_vec = avoidance_vec / (np.linalg.norm(avoidance_vec) + 1e-6)\n                    desired_velocity = tuple(desired_vec + avoidance_vec * 0.1)\n                    desired_velocity = (np.clip(desired_velocity[0], -1.0, 1.0),\n                                      np.clip(desired_velocity[1], -1.0, 1.0))\n\n        return desired_velocity\n'})}),"\n",(0,a.jsx)(e.h3,{id:"62-navigation-in-dynamic-environments",children:"6.2 Navigation in Dynamic Environments"}),"\n",(0,a.jsx)(e.p,{children:"Handling moving obstacles and changing environments:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Tuple\nfrom dataclasses import dataclass\nimport time\n\n@dataclass\nclass DynamicObstacle:\n    id: int\n    position: Tuple[float, float]\n    velocity: Tuple[float, float]\n    radius: float\n    last_seen: float\n\nclass DynamicEnvironmentNavigator:\n    def __init__(self):\n        self.dynamic_obstacles: Dict[int, DynamicObstacle] = {}\n        self.obstacle_timeout = 2.0  # seconds before removing unseen obstacles\n        self.prediction_horizon = 1.0  # seconds to predict obstacle positions\n\n    def update_dynamic_obstacle(self, obs_id: int, position: Tuple[float, float],\n                               velocity: Tuple[float, float], radius: float = 0.5):\n        """\n        Update or add a dynamic obstacle\n        """\n        current_time = time.time()\n        self.dynamic_obstacles[obs_id] = DynamicObstacle(\n            obs_id, position, velocity, radius, current_time\n        )\n\n    def remove_expired_obstacles(self):\n        """\n        Remove obstacles that haven\'t been seen recently\n        """\n        current_time = time.time()\n        expired_ids = []\n\n        for obs_id, obstacle in self.dynamic_obstacles.items():\n            if current_time - obstacle.last_seen > self.obstacle_timeout:\n                expired_ids.append(obs_id)\n\n        for obs_id in expired_ids:\n            del self.dynamic_obstacles[obs_id]\n\n    def predict_obstacle_positions(self, time_ahead: float) -> List[Tuple[float, float, float]]:\n        """\n        Predict positions of all dynamic obstacles at a future time\n        Returns list of (x, y, radius) tuples\n        """\n        predicted_positions = []\n        current_time = time.time()\n\n        for obstacle in self.dynamic_obstacles.values():\n            # Predict position based on current velocity\n            dt = time_ahead\n            pred_x = obstacle.position[0] + obstacle.velocity[0] * dt\n            pred_y = obstacle.position[1] + obstacle.velocity[1] * dt\n            predicted_positions.append((pred_x, pred_y, obstacle.radius))\n\n        return predicted_positions\n\n    def check_dynamic_collision(self, path: List[Tuple[float, float]],\n                               time_steps: List[float]) -> Tuple[bool, float]:\n        """\n        Check if a path collides with any predicted dynamic obstacles\n        Returns (collision_detected, time_of_collision)\n        """\n        for i, (path_point, t) in enumerate(zip(path, time_steps)):\n            predicted_obstacles = self.predict_obstacle_positions(t)\n\n            for obs_x, obs_y, obs_radius in predicted_obstacles:\n                distance = np.sqrt((path_point[0] - obs_x)**2 + (path_point[1] - obs_y)**2)\n                if distance <= obs_radius:\n                    return True, t\n\n        return False, 0.0\n\n    def replan_if_needed(self, current_position: Tuple[float, float],\n                        goal: Tuple[float, float], robot_radius: float = 0.3) -> bool:\n        """\n        Determine if replanning is needed due to dynamic obstacles\n        """\n        # Predict obstacle positions in the near future\n        near_future_obstacles = self.predict_obstacle_positions(0.5)  # 0.5 seconds ahead\n\n        # Check if any obstacles are on our path or getting close\n        for obs_x, obs_y, obs_radius in near_future_obstacles:\n            distance = np.sqrt((current_position[0] - obs_x)**2 +\n                              (current_position[1] - obs_y)**2)\n            combined_radius = robot_radius + obs_radius + 0.5  # Safety margin\n\n            if distance < combined_radius:\n                return True  # Replan needed\n\n        return False\n'})}),"\n",(0,a.jsx)(e.h2,{id:"7-implementation-best-practices",children:"7. Implementation Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"71-safety-considerations",children:"7.1 Safety Considerations"}),"\n",(0,a.jsx)(e.p,{children:"Navigation systems must prioritize safety above all other considerations:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Always maintain safety margins around obstacles"}),"\n",(0,a.jsx)(e.li,{children:"Implement emergency stop mechanisms"}),"\n",(0,a.jsx)(e.li,{children:"Use conservative velocity profiles near obstacles"}),"\n",(0,a.jsx)(e.li,{children:"Validate all paths before execution"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"72-performance-optimization",children:"7.2 Performance Optimization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Use appropriate data structures for fast nearest neighbor searches"}),"\n",(0,a.jsx)(e.li,{children:"Implement efficient collision detection algorithms"}),"\n",(0,a.jsx)(e.li,{children:"Use hierarchical planning to reduce computational load"}),"\n",(0,a.jsx)(e.li,{children:"Cache frequently computed values"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"73-robustness",children:"7.3 Robustness"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Handle sensor failures gracefully"}),"\n",(0,a.jsx)(e.li,{children:"Implement fallback behaviors"}),"\n",(0,a.jsx)(e.li,{children:"Monitor system health continuously"}),"\n",(0,a.jsx)(e.li,{children:"Validate all inputs and outputs"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"8-chapter-summary",children:"8. Chapter Summary"}),"\n",(0,a.jsx)(e.p,{children:"This section has covered the fundamental concepts and implementation techniques for navigation systems in Physical AI applications. We've explored global path planning algorithms like A* and RRT, local path planning methods like DWA, and integration with ROS 2 Navigation 2 stack. We've also discussed performance evaluation, multi-robot navigation, and dynamic environment handling."}),"\n",(0,a.jsx)(e.p,{children:"The next section will explore sim-to-real transfer techniques that enable navigation systems developed in simulation to work effectively in real-world environments."}),"\n",(0,a.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Implementation Exercise"}),": Implement a complete navigation system that combines A* global planning with DWA local planning. Test it on a simulated environment with various obstacle configurations."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Analysis Exercise"}),": Compare the performance of different path planning algorithms (A*, Dijkstra, RRT) in terms of computation time, path optimality, and success rate in different environments."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Integration Exercise"}),": Create a ROS 2 package that integrates your custom local planner with the Navigation 2 stack."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Optimization Exercise"}),": Implement a dynamic window approach planner with obstacle prediction for moving obstacles."]}),"\n"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);