"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[4433],{1925:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var t=s(4848),i=s(8453);const a={title:"Chapter 4 - Topics Communication in ROS 2"},r="Topics Communication in ROS 2",o={id:"physical-ai/ros2-communication/topics-communication",title:"Chapter 4 - Topics Communication in ROS 2",description:"Introduction",source:"@site/docs/physical-ai/ros2-communication/02-topics-communication.mdx",sourceDirName:"physical-ai/ros2-communication",slug:"/physical-ai/ros2-communication/topics-communication",permalink:"/physical-ai-textbook/physical-ai/physical-ai/ros2-communication/topics-communication",draft:!1,unlisted:!1,editUrl:"https://github.com/your-username/physical-ai-textbook/tree/main/docs/physical-ai/ros2-communication/02-topics-communication.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Chapter 4 - Topics Communication in ROS 2"}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Basic Topic Implementation",id:"basic-topic-implementation",level:2},{value:"Advanced Topic Patterns",id:"advanced-topic-patterns",level:2},{value:"Topic Filtering and Transformation",id:"topic-filtering-and-transformation",level:3},{value:"Topic Monitoring and Statistics",id:"topic-monitoring-and-statistics",level:3},{value:"Quality of Service (QoS) Profiles",id:"quality-of-service-qos-profiles",level:2},{value:"Topic Bridge and Data Transformation",id:"topic-bridge-and-data-transformation",level:2},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Memory Optimization with Pre-allocation",id:"memory-optimization-with-pre-allocation",level:3},{value:"Topic Communication Best Practices",id:"topic-communication-best-practices",level:2},{value:"Error Handling and Robustness",id:"error-handling-and-robustness",level:3},{value:"Integration with Other Communication Patterns",id:"integration-with-other-communication-patterns",level:2},{value:"Chapter Summary",id:"chapter-summary",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"topics-communication-in-ros-2",children:"Topics Communication in ROS 2"}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Topics form the backbone of ROS 2's publish/subscribe communication model. They enable asynchronous, decoupled communication between multiple publishers and subscribers, making them ideal for continuous data streams like sensor readings, status updates, and robot state information."}),"\n",(0,t.jsx)(n.h2,{id:"basic-topic-implementation",children:"Basic Topic Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Topics enable asynchronous, many-to-many communication for continuous data streams. Here's a basic implementation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Int32, Float64\nfrom sensor_msgs.msg import LaserScan, Imu, JointState\nfrom geometry_msgs.msg import Twist, PoseStamped\nfrom nav_msgs.msg import Odometry\nimport threading\nimport time\nfrom collections import deque\nimport numpy as np\n\nclass BasicTopicNode(Node):\n    def __init__(self):\n        super().__init__('basic_topic_node')\n\n        # Publishers for different data types\n        self.status_publisher = self.create_publisher(String, 'robot_status', 10)\n        self.odometry_publisher = self.create_publisher(Odometry, 'odometry', 10)\n        self.cmd_vel_publisher = self.create_publisher(Twist, 'cmd_vel', 10)\n        self.joint_states_publisher = self.create_publisher(JointState, 'joint_states', 10)\n\n        # Subscribers with different QoS profiles\n        self.command_subscriber = self.create_subscription(\n            Twist, 'cmd_vel', self.cmd_vel_callback, 10\n        )\n        self.sensor_subscriber = self.create_subscription(\n            LaserScan, 'laser_scan', self.laser_callback, 10\n        )\n        self.imu_subscriber = self.create_subscription(\n            Imu, 'imu/data', self.imu_callback, 10\n        )\n\n        # Timer for periodic publishing\n        self.publish_timer = self.create_timer(0.1, self.publish_robot_state)\n\n        # Robot state data\n        self.robot_state = {\n            'position': {'x': 0.0, 'y': 0.0, 'theta': 0.0},\n            'velocity': {'linear': 0.0, 'angular': 0.0},\n            'joint_positions': [0.0] * 6,  # Example 6-DOF robot\n            'battery_level': 100.0\n        }\n\n    def cmd_vel_callback(self, msg):\n        \"\"\"Handle velocity commands.\"\"\"\n        # Update robot state based on command\n        self.robot_state['velocity']['linear'] = msg.linear.x\n        self.robot_state['velocity']['angular'] = msg.angular.z\n\n        self.get_logger().info(\n            f'Received velocity command: linear={msg.linear.x}, angular={msg.angular.z}'\n        )\n\n    def laser_callback(self, msg):\n        \"\"\"Handle laser scan data.\"\"\"\n        # Process laser data for obstacle detection\n        min_range = min([r for r in msg.ranges if not np.isnan(r)], default=float('inf'))\n\n        if min_range < 1.0:  # Obstacle within 1 meter\n            self.get_logger().warn(f'Obstacle detected at {min_range:.2f}m')\n\n    def imu_callback(self, msg):\n        \"\"\"Handle IMU data.\"\"\"\n        # Extract orientation and angular velocity\n        orientation = msg.orientation\n        angular_velocity = msg.angular_velocity\n\n        self.get_logger().info(\n            f'IMU: orientation=({orientation.x:.3f}, {orientation.y:.3f}, {orientation.z:.3f}, {orientation.w:.3f})'\n        )\n\n    def publish_robot_state(self):\n        \"\"\"Publish robot state information.\"\"\"\n        # Update odometry message\n        odom_msg = Odometry()\n        odom_msg.header.stamp = self.get_clock().now().to_msg()\n        odom_msg.header.frame_id = 'odom'\n        odom_msg.child_frame_id = 'base_link'\n\n        # Set position (simplified for example)\n        odom_msg.pose.pose.position.x = self.robot_state['position']['x']\n        odom_msg.pose.pose.position.y = self.robot_state['position']['y']\n\n        # Set velocity\n        odom_msg.twist.twist.linear.x = self.robot_state['velocity']['linear']\n        odom_msg.twist.twist.angular.z = self.robot_state['velocity']['angular']\n\n        # Update joint states\n        joint_msg = JointState()\n        joint_msg.header.stamp = self.get_clock().now().to_msg()\n        joint_msg.name = [f'joint_{i}' for i in range(6)]\n        joint_msg.position = self.robot_state['joint_positions']\n\n        # Update status\n        status_msg = String()\n        status_msg.data = f'Battery: {self.robot_state[\"battery_level\"]:.1f}%, Pos: ({self.robot_state[\"position\"][\"x\"]:.2f}, {self.robot_state[\"position\"][\"y\"]:.2f})'\n\n        # Publish all messages\n        self.odometry_publisher.publish(odom_msg)\n        self.joint_states_publisher.publish(joint_msg)\n        self.status_publisher.publish(status_msg)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-topic-patterns",children:"Advanced Topic Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"topic-filtering-and-transformation",children:"Topic Filtering and Transformation"}),"\n",(0,t.jsx)(n.p,{children:"Advanced topic handling often requires filtering, transforming, or aggregating data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from sensor_msgs.msg import PointCloud2, LaserScan\nimport sensor_msgs.point_cloud2 as pc2\nfrom std_msgs.msg import Header\nfrom geometry_msgs.msg import Point32\n\nclass TopicFilterNode(Node):\n    def __init__(self):\n        super().__init__('topic_filter_node')\n\n        # Subscribe to raw sensor data\n        self.pointcloud_sub = self.create_subscription(\n            PointCloud2, 'raw_pointcloud', self.pointcloud_callback, 10\n        )\n\n        self.laser_sub = self.create_subscription(\n            LaserScan, 'raw_laser', self.laser_callback, 10\n        )\n\n        # Publish filtered data\n        self.filtered_pc_pub = self.create_publisher(PointCloud2, 'filtered_pointcloud', 10)\n        self.filtered_laser_pub = self.create_publisher(LaserScan, 'filtered_laser', 10)\n\n        # Parameters for filtering\n        self.declare_parameter('min_distance', 0.5)\n        self.declare_parameter('max_distance', 10.0)\n        self.declare_parameter('x_min', -5.0)\n        self.declare_parameter('x_max', 5.0)\n        self.declare_parameter('y_min', -5.0)\n        self.declare_parameter('y_max', 5.0)\n\n    def pointcloud_callback(self, msg):\n        \"\"\"Filter point cloud data.\"\"\"\n        try:\n            # Convert PointCloud2 to list of points\n            points = list(pc2.read_points(msg, field_names=(\"x\", \"y\", \"z\"), skip_nans=True))\n\n            # Apply spatial filtering\n            filtered_points = []\n            min_dist = self.get_parameter('min_distance').value\n            max_dist = self.get_parameter('max_distance').value\n            x_min = self.get_parameter('x_min').value\n            x_max = self.get_parameter('x_max').value\n            y_min = self.get_parameter('y_min').value\n            y_max = self.get_parameter('y_max').value\n\n            for point in points:\n                x, y, z = point\n                distance = np.sqrt(x**2 + y**2 + z**2)\n\n                if (min_dist <= distance <= max_dist and\n                    x_min <= x <= x_max and\n                    y_min <= y <= y_max):\n                    filtered_points.append([x, y, z])\n\n            # Create new PointCloud2 message with filtered points\n            header = Header()\n            header.stamp = msg.header.stamp\n            header.frame_id = msg.header.frame_id\n\n            filtered_msg = pc2.create_cloud_xyz32(header, filtered_points)\n            self.filtered_pc_pub.publish(filtered_msg)\n\n        except Exception as e:\n            self.get_logger().error(f'Error filtering point cloud: {e}')\n\n    def laser_callback(self, msg):\n        \"\"\"Filter laser scan data.\"\"\"\n        # Apply range filtering\n        filtered_ranges = []\n        min_range = self.get_parameter('min_distance').value\n        max_range = self.get_parameter('max_distance').value\n\n        for range_val in msg.ranges:\n            if np.isnan(range_val) or range_val < min_range or range_val > max_range:\n                filtered_ranges.append(float('inf'))  # Mark as invalid\n            else:\n                filtered_ranges.append(range_val)\n\n        # Create filtered message\n        filtered_msg = LaserScan()\n        filtered_msg.header = msg.header\n        filtered_msg.angle_min = msg.angle_min\n        filtered_msg.angle_max = msg.angle_max\n        filtered_msg.angle_increment = msg.angle_increment\n        filtered_msg.time_increment = msg.time_increment\n        filtered_msg.scan_time = msg.scan_time\n        filtered_msg.range_min = min_range\n        filtered_msg.range_max = max_range\n        filtered_msg.ranges = filtered_ranges\n        filtered_msg.intensities = msg.intensities  # Keep original intensities\n\n        self.filtered_laser_pub.publish(filtered_msg)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"topic-monitoring-and-statistics",children:"Topic Monitoring and Statistics"}),"\n",(0,t.jsx)(n.p,{children:"Monitoring topic performance is essential for robust robotic systems:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from rclpy.qos import qos_profile_sensor_data\nfrom std_msgs.msg import String\nimport time\nfrom collections import deque\nimport statistics\n\nclass TopicMonitorNode(Node):\n    def __init__(self):\n        super().__init__(\'topic_monitor\')\n\n        # Subscribe to topic with monitoring\n        self.monitored_sub = self.create_subscription(\n            String, \'monitored_topic\', self.monitored_callback,\n            qos_profile=qos_profile_sensor_data\n        )\n\n        # Statistics publishers\n        self.stats_pub = self.create_publisher(String, \'topic_statistics\', 10)\n        self.health_pub = self.create_publisher(String, \'topic_health\', 10)\n\n        # Statistics tracking\n        self.message_count = 0\n        self.message_times = deque(maxlen=1000)  # Store timestamps\n        self.message_sizes = deque(maxlen=1000)  # Store sizes\n        self.message_intervals = deque(maxlen=1000)  # Store intervals\n        self.start_time = self.get_clock().now()\n\n        # Monitoring timer\n        self.monitor_timer = self.create_timer(5.0, self.publish_monitoring_data)\n\n        # Health monitoring\n        self.last_message_time = self.get_clock().now()\n        self.health_timer = self.create_timer(1.0, self.check_health)\n\n    def monitored_callback(self, msg):\n        """Monitor incoming messages."""\n        current_time = self.get_clock().now()\n        self.message_count += 1\n\n        # Store timing information\n        self.message_times.append(current_time.nanoseconds)\n        self.message_sizes.append(len(msg.data.encode(\'utf-8\')))\n\n        # Calculate interval if we have previous message\n        if len(self.message_times) > 1:\n            interval = (self.message_times[-1] - self.message_times[-2]) / 1e9\n            self.message_intervals.append(interval)\n\n        # Update last message time for health monitoring\n        self.last_message_time = current_time\n\n        # Process the message\n        self.process_monitored_message(msg)\n\n    def process_monitored_message(self, msg):\n        """Process the monitored message."""\n        # Implement specific message processing logic here\n        self.get_logger().debug(f\'Monitored: {msg.data}\')\n\n    def publish_monitoring_data(self):\n        """Publish monitoring statistics."""\n        if self.message_count == 0:\n            return\n\n        # Calculate statistics\n        elapsed_time = (self.get_clock().now() - self.start_time).nanoseconds / 1e9\n        message_rate = self.message_count / elapsed_time if elapsed_time > 0 else 0\n\n        # Calculate interval statistics\n        avg_interval = statistics.mean(self.message_intervals) if self.message_intervals else 0\n        std_interval = statistics.stdev(self.message_intervals) if len(self.message_intervals) > 1 else 0\n        min_interval = min(self.message_intervals) if self.message_intervals else 0\n        max_interval = max(self.message_intervals) if self.message_intervals else 0\n\n        # Calculate size statistics\n        avg_size = statistics.mean(self.message_sizes) if self.message_sizes else 0\n        std_size = statistics.stdev(self.message_sizes) if len(self.message_sizes) > 1 else 0\n\n        # Create statistics message\n        stats_msg = String()\n        stats_msg.data = (\n            f"Topic Statistics:\\n"\n            f"  Total Messages: {self.message_count}\\n"\n            f"  Message Rate: {message_rate:.2f} Hz\\n"\n            f"  Avg Interval: {avg_interval:.4f}s (\xb1{std_interval:.4f}s)\\n"\n            f"  Interval Range: {min_interval:.4f}s - {max_interval:.4f}s\\n"\n            f"  Avg Size: {avg_size:.2f} bytes (\xb1{std_size:.2f} bytes)\\n"\n            f"  Elapsed Time: {elapsed_time:.2f}s\\n"\n        )\n\n        self.stats_pub.publish(stats_msg)\n\n    def check_health(self):\n        """Check topic health."""\n        current_time = self.get_clock().now()\n        time_since_last = (current_time - self.last_message_time).nanoseconds / 1e9\n\n        health_msg = String()\n        if time_since_last > 5.0:  # No message in 5 seconds\n            health_msg.data = f"ALERT: No messages received for {time_since_last:.2f}s"\n        else:\n            health_msg.data = f"OK: Last message {time_since_last:.2f}s ago"\n\n        self.health_pub.publish(health_msg)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"quality-of-service-qos-profiles",children:"Quality of Service (QoS) Profiles"}),"\n",(0,t.jsx)(n.p,{children:"QoS profiles control how messages are delivered between publishers and subscribers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy, LivelinessPolicy\n\nclass QoSTopicNode(Node):\n    def __init__(self):\n        super().__init__('qos_topic_node')\n\n        # Different QoS profiles for different use cases\n        # For sensor data (high frequency, best effort)\n        sensor_qos = QoSProfile(\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            history=HistoryPolicy.KEEP_LAST,\n            depth=10,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        # For critical commands (reliable delivery)\n        command_qos = QoSProfile(\n            reliability=ReliabilityPolicy.RELIABLE,\n            history=HistoryPolicy.KEEP_ALL,\n            depth=1,\n            durability=DurabilityPolicy.TRANSIENT_LOCAL\n        )\n\n        # For status updates (balance between performance and reliability)\n        status_qos = QoSProfile(\n            reliability=ReliabilityPolicy.RELIABLE,\n            history=HistoryPolicy.KEEP_LAST,\n            depth=5,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        # Publishers with different QoS profiles\n        self.sensor_pub = self.create_publisher(\n            LaserScan, 'sensor_data', sensor_qos\n        )\n        self.command_pub = self.create_publisher(\n            Twist, 'robot_command', command_qos\n        )\n        self.status_pub = self.create_publisher(\n            String, 'robot_status', status_qos\n        )\n\n        # Subscribers with matching QoS profiles\n        self.sensor_sub = self.create_subscription(\n            LaserScan, 'sensor_data', self.sensor_callback, sensor_qos\n        )\n        self.command_sub = self.create_subscription(\n            Twist, 'robot_command', self.command_callback, command_qos\n        )\n        self.status_sub = self.create_subscription(\n            String, 'robot_status', self.status_callback, status_qos\n        )\n\n    def sensor_callback(self, msg):\n        \"\"\"Handle sensor data with best-effort delivery.\"\"\"\n        self.get_logger().debug('Received sensor data')\n\n    def command_callback(self, msg):\n        \"\"\"Handle critical commands with reliable delivery.\"\"\"\n        self.get_logger().info('Received critical command')\n\n    def status_callback(self, msg):\n        \"\"\"Handle status updates.\"\"\"\n        self.get_logger().info(f'Robot status: {msg.data}')\n"})}),"\n",(0,t.jsx)(n.h2,{id:"topic-bridge-and-data-transformation",children:"Topic Bridge and Data Transformation"}),"\n",(0,t.jsx)(n.p,{children:"Topic bridges allow connecting different parts of a system:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class TopicBridgeNode(Node):\n    def __init__(self):\n        super().__init__('topic_bridge')\n\n        # Subscribe to input topics\n        self.input_sub = self.create_subscription(\n            String, 'input_topic', self.input_callback, 10\n        )\n\n        # Publish to output topics\n        self.output_pub = self.create_publisher(\n            Float64, 'output_topic', 10\n        )\n\n        # Bridge between different message types\n        self.transform_sub = self.create_subscription(\n            Float64, 'raw_value', self.transform_callback, 10\n        )\n        self.transformed_pub = self.create_publisher(\n            String, 'processed_value', 10\n        )\n\n    def input_callback(self, msg):\n        \"\"\"Bridge input to output with transformation.\"\"\"\n        try:\n            # Convert string to number (with error handling)\n            value = float(msg.data)\n\n            # Create output message\n            output_msg = Float64()\n            output_msg.data = value * 2  # Example transformation\n\n            self.output_pub.publish(output_msg)\n\n        except ValueError:\n            self.get_logger().error(f'Cannot convert {msg.data} to float')\n\n    def transform_callback(self, msg):\n        \"\"\"Transform data from one format to another.\"\"\"\n        # Apply processing to the input value\n        processed_value = msg.data ** 2  # Example: square the value\n\n        # Create and publish transformed message\n        output_msg = String()\n        output_msg.data = f'Processed: {processed_value:.2f}'\n        self.transformed_pub.publish(output_msg)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(n.h3,{id:"memory-optimization-with-pre-allocation",children:"Memory Optimization with Pre-allocation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class OptimizedTopicNode(Node):\n    def __init__(self):\n        super().__init__('optimized_topic_node')\n\n        # Pre-allocate message objects to reduce allocation overhead\n        self._string_msg = String()\n        self._float_msg = Float64()\n        self._twist_msg = Twist()\n\n        # Publisher for high-frequency data\n        self.optimized_pub = self.create_publisher(\n            String, 'optimized_topic', 10\n        )\n\n        # Timer for optimized publishing\n        self.timer = self.create_timer(0.001, self.optimized_publish)\n\n    def optimized_publish(self):\n        \"\"\"Optimized publishing using pre-allocated messages.\"\"\"\n        # Reuse message object instead of creating new ones\n        self._string_msg.data = f'Optimized message at {self.get_clock().now().nanoseconds}'\n        self.optimized_pub.publish(self._string_msg)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"topic-communication-best-practices",children:"Topic Communication Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"error-handling-and-robustness",children:"Error Handling and Robustness"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class RobustTopicNode(Node):\n    def __init__(self):\n        super().__init__('robust_topic_node')\n\n        # Publishers with error handling\n        self.status_pub = self.create_publisher(String, 'status', 10)\n        self.error_pub = self.create_publisher(String, 'errors', 10)\n\n        # Subscribers with validation\n        self.data_sub = self.create_subscription(\n            String, 'input_data', self.robust_callback, 10\n        )\n\n        # Statistics for monitoring\n        self.message_stats = {\n            'received': 0,\n            'errors': 0,\n            'processed': 0\n        }\n\n    def robust_callback(self, msg):\n        \"\"\"Handle messages with comprehensive error handling.\"\"\"\n        try:\n            # Validate message content\n            if not self.validate_message(msg):\n                self.get_logger().error(f'Invalid message: {msg.data}')\n                self.message_stats['errors'] += 1\n                self.publish_error(f'Invalid message: {msg.data}')\n                return\n\n            # Process the message\n            processed_data = self.process_message(msg.data)\n            self.message_stats['processed'] += 1\n\n            # Publish status update\n            status_msg = String()\n            status_msg.data = f'Processed: {processed_data}'\n            self.status_pub.publish(status_msg)\n\n        except Exception as e:\n            self.get_logger().error(f'Error processing message: {e}')\n            self.message_stats['errors'] += 1\n            self.publish_error(f'Processing error: {str(e)}')\n\n        finally:\n            self.message_stats['received'] += 1\n\n    def validate_message(self, msg):\n        \"\"\"Validate incoming message.\"\"\"\n        if not msg.data or len(msg.data) == 0:\n            return False\n        if len(msg.data) > 1000:  # Max message size check\n            self.get_logger().warn(f'Message too large: {len(msg.data)} chars')\n            return False\n        return True\n\n    def process_message(self, data):\n        \"\"\"Process message data.\"\"\"\n        # Implement actual processing logic here\n        return data.upper()  # Example transformation\n\n    def publish_error(self, error_msg):\n        \"\"\"Publish error message.\"\"\"\n        error = String()\n        error.data = error_msg\n        self.error_pub.publish(error)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"integration-with-other-communication-patterns",children:"Integration with Other Communication Patterns"}),"\n",(0,t.jsx)(n.p,{children:"Topics work together with services and actions in complex systems:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class IntegratedTopicNode(Node):\n    def __init__(self):\n        super().__init__(\'integrated_topic_node\')\n\n        # Topic publishers and subscribers\n        self.state_pub = self.create_publisher(String, \'robot_state\', 10)\n        self.command_sub = self.create_subscription(\n            String, \'commands\', self.command_callback, 10\n        )\n\n        # Service client for coordination\n        self.service_client = self.create_client(\n            SetBool, \'system_status\'\n        )\n\n        # Timer for periodic state updates\n        self.state_timer = self.create_timer(1.0, self.publish_state)\n\n    def command_callback(self, msg):\n        """Handle commands received via topic."""\n        command = msg.data\n        self.get_logger().info(f\'Received command: {command}\')\n\n        # Process command and potentially call service\n        if command == \'status_check\':\n            self.check_system_status()\n\n    def check_system_status(self):\n        """Check system status using service."""\n        if self.service_client.service_is_ready():\n            request = SetBool.Request()\n            request.data = True\n            self.service_client.call_async(request)\n\n    def publish_state(self):\n        """Publish current robot state."""\n        state_msg = String()\n        state_msg.data = \'ACTIVE\'\n        self.state_pub.publish(state_msg)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,t.jsx)(n.p,{children:"This section covered the comprehensive implementation of topics in ROS 2:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Basic Implementation"}),": Creating publishers and subscribers for different message types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Advanced Patterns"}),": Topic filtering, transformation, and monitoring"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"QoS Configuration"}),": Using Quality of Service profiles for different communication needs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance Optimization"}),": Memory optimization and pre-allocation techniques"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Building robust topic communication with validation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Integration"}),": How topics work with other communication patterns"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Topics provide the foundation for asynchronous, decoupled communication in ROS 2 systems, making them essential for sensor data, status updates, and other continuous data streams."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var t=s(6540);const i={},a=t.createContext(i);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);