"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[9708],{5299:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var i=t(4848),o=t(8453);const a={title:"Unity Visualization Techniques for Robotics"},r="Unity Visualization Techniques for Robotics",s={id:"physical-ai/unity-visualization/visualization",title:"Unity Visualization Techniques for Robotics",description:"Introduction to Robotics Visualization",source:"@site/docs/physical-ai/unity-visualization/02-visualization.mdx",sourceDirName:"physical-ai/unity-visualization",slug:"/physical-ai/unity-visualization/visualization",permalink:"/physical-ai-textbook/physical-ai/physical-ai/unity-visualization/visualization",draft:!1,unlisted:!1,editUrl:"https://github.com/your-username/physical-ai-textbook/tree/main/docs/physical-ai/unity-visualization/02-visualization.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Unity Visualization Techniques for Robotics"},sidebar:"tutorialSidebar",previous:{title:"Chapter 8 - Human-Robot Interaction Design Principles",permalink:"/physical-ai-textbook/physical-ai/physical-ai/unity-visualization/human-robot-interaction"},next:{title:"Chapter 8 - Unity Visualization & Human-Robot Interaction Chapter Summary",permalink:"/physical-ai-textbook/physical-ai/physical-ai/unity-visualization/chapter-summary"}},l={},c=[{value:"Introduction to Robotics Visualization",id:"introduction-to-robotics-visualization",level:2},{value:"Robot Model Visualization",id:"robot-model-visualization",level:2},{value:"Creating Accurate Robot Representations",id:"creating-accurate-robot-representations",level:3},{value:"Real-time Robot State Visualization",id:"real-time-robot-state-visualization",level:3},{value:"Sensor Data Visualization",id:"sensor-data-visualization",level:2},{value:"Point Cloud Visualization",id:"point-cloud-visualization",level:3},{value:"Camera Feed Visualization",id:"camera-feed-visualization",level:3},{value:"Advanced Visualization Techniques",id:"advanced-visualization-techniques",level:2},{value:"Custom Shaders for Robotics Visualization",id:"custom-shaders-for-robotics-visualization",level:3},{value:"Performance Optimization for Large-Scale Visualization",id:"performance-optimization-for-large-scale-visualization",level:3},{value:"Best Practices for Robotics Visualization",id:"best-practices-for-robotics-visualization",level:2},{value:"Data Management and Memory Optimization",id:"data-management-and-memory-optimization",level:3}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"unity-visualization-techniques-for-robotics",children:"Unity Visualization Techniques for Robotics"}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-robotics-visualization",children:"Introduction to Robotics Visualization"}),"\n",(0,i.jsx)(e.p,{children:"Visualization in robotics serves multiple critical purposes: debugging robot behaviors, monitoring system states, presenting sensor data to human operators, and creating immersive interfaces for human-robot interaction. Unity's powerful rendering engine and flexible architecture make it an ideal platform for creating sophisticated visualization systems that can handle the complex data streams typical in robotics applications."}),"\n",(0,i.jsx)(e.h2,{id:"robot-model-visualization",children:"Robot Model Visualization"}),"\n",(0,i.jsx)(e.h3,{id:"creating-accurate-robot-representations",children:"Creating Accurate Robot Representations"}),"\n",(0,i.jsx)(e.p,{children:"Accurate robot visualization requires faithful representation of the physical robot's geometry, kinematics, and dynamics. Unity provides several approaches to visualize robot models:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\n\npublic class RobotModelVisualizer : MonoBehaviour\n{\n    [Header("Model Configuration")]\n    public GameObject robotPrefab;\n    public Transform[] jointTransforms;\n    public string[] jointNames;\n    public float[] jointLimitsMin;\n    public float[] jointLimitsMax;\n\n    [Header("Visualization Settings")]\n    public bool showJointAxes = true;\n    public bool showEndEffectors = true;\n    public Color jointColor = Color.yellow;\n    public Color endEffectorColor = Color.red;\n\n    private GameObject robotInstance;\n    private LineRenderer[] jointAxes;\n    private GameObject[] endEffectors;\n\n    void Start()\n    {\n        CreateRobotModel();\n        SetupJointVisualization();\n        SetupEndEffectorVisualization();\n    }\n\n    void CreateRobotModel()\n    {\n        robotInstance = Instantiate(robotPrefab, transform.position, transform.rotation);\n        robotInstance.transform.SetParent(transform);\n\n        // Get joint transforms from the instantiated model\n        jointTransforms = GetJointTransforms(robotInstance);\n    }\n\n    Transform[] GetJointTransforms(GameObject robot)\n    {\n        // Find all joint transforms in the robot hierarchy\n        Transform[] allTransforms = robot.GetComponentsInChildren<Transform>();\n        System.Collections.Generic.List<Transform> joints = new System.Collections.Generic.List<Transform>();\n\n        foreach (Transform t in allTransforms)\n        {\n            if (t.name.ToLower().Contains("joint") || t.name.ToLower().Contains("link"))\n            {\n                joints.Add(t);\n            }\n        }\n\n        return joints.ToArray();\n    }\n\n    void SetupJointVisualization()\n    {\n        if (!showJointAxes) return;\n\n        jointAxes = new LineRenderer[jointTransforms.Length];\n\n        for (int i = 0; i < jointTransforms.Length; i++)\n        {\n            GameObject axisObject = new GameObject($"JointAxis_{i}");\n            axisObject.transform.SetParent(jointTransforms[i]);\n            axisObject.transform.localPosition = Vector3.zero;\n            axisObject.transform.localRotation = Quaternion.identity;\n\n            LineRenderer lineRenderer = axisObject.AddComponent<LineRenderer>();\n            lineRenderer.material = new Material(Shader.Find("Sprites/Default"));\n            lineRenderer.color = jointColor;\n            lineRenderer.startWidth = 0.02f;\n            lineRenderer.endWidth = 0.02f;\n            lineRenderer.positionCount = 2;\n\n            // Set positions for the axis line (X-axis direction)\n            lineRenderer.SetPosition(0, Vector3.zero);\n            lineRenderer.SetPosition(1, Vector3.right * 0.1f);\n\n            jointAxes[i] = lineRenderer;\n        }\n    }\n\n    void SetupEndEffectorVisualization()\n    {\n        if (!showEndEffectors) return;\n\n        // Find end effectors (typically at the end of kinematic chains)\n        endEffectors = new GameObject[jointTransforms.Length];\n\n        for (int i = 0; i < jointTransforms.Length; i++)\n        {\n            if (IsEndEffector(jointTransforms[i]))\n            {\n                GameObject effector = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n                effector.transform.SetParent(jointTransforms[i]);\n                effector.transform.localPosition = Vector3.zero;\n                effector.transform.localScale = Vector3.one * 0.05f;\n\n                Renderer renderer = effector.GetComponent<Renderer>();\n                renderer.material = new Material(Shader.Find("Sprites/Default"));\n                renderer.material.color = endEffectorColor;\n\n                // Make it non-interactive\n                Destroy(effector.GetComponent<Collider>());\n\n                endEffectors[i] = effector;\n            }\n        }\n    }\n\n    bool IsEndEffector(Transform joint)\n    {\n        // Simple heuristic: joints with no children are likely end effectors\n        return joint.childCount == 0;\n    }\n\n    public void UpdateRobotJoints(float[] jointAngles)\n    {\n        for (int i = 0; i < jointTransforms.Length && i < jointAngles.Length; i++)\n        {\n            // Clamp joint angles to limits\n            float clampedAngle = Mathf.Clamp(jointAngles[i] * Mathf.Rad2Deg,\n                                           jointLimitsMin[i], jointLimitsMax[i]);\n\n            // Apply rotation to joint\n            jointTransforms[i].localRotation = Quaternion.Euler(0, 0, clampedAngle);\n        }\n    }\n\n    void Update()\n    {\n        // Update visualization based on current robot state\n        UpdateJointAxes();\n    }\n\n    void UpdateJointAxes()\n    {\n        if (!showJointAxes) return;\n\n        for (int i = 0; i < jointAxes.Length; i++)\n        {\n            // Update joint axis orientation to match current joint rotation\n            Vector3 axisDirection = jointTransforms[i].TransformDirection(Vector3.right);\n            jointAxes[i].SetPosition(1, axisDirection * 0.1f);\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"real-time-robot-state-visualization",children:"Real-time Robot State Visualization"}),"\n",(0,i.jsx)(e.p,{children:"Visualizing real-time robot states requires efficient data processing and rendering:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\n\npublic class RealTimeRobotVisualizer : MonoBehaviour\n{\n    [Header("State Visualization")]\n    public GameObject robotModel;\n    public GameObject trajectoryTrail;\n    public Material trajectoryMaterial;\n    public Color trajectoryColor = Color.blue;\n    public int maxTrajectoryPoints = 1000;\n\n    [Header("State Data")]\n    public float[] jointPositions;\n    public float[] jointVelocities;\n    public Vector3 robotPosition;\n    public Quaternion robotOrientation;\n\n    [Header("Visualization Settings")]\n    public bool showTrajectory = true;\n    public bool showVelocityVectors = true;\n    public bool showAccelerationZones = true;\n    public float velocityScale = 0.1f;\n\n    private LineRenderer trajectoryRenderer;\n    private System.Collections.Generic.List<Vector3> trajectoryPoints;\n    private GameObject[] velocityVectors;\n    private MaterialPropertyBlock materialPropertyBlock;\n\n    void Start()\n    {\n        InitializeVisualization();\n    }\n\n    void InitializeVisualization()\n    {\n        trajectoryPoints = new System.Collections.Generic.List<Vector3>();\n\n        // Setup trajectory renderer\n        if (showTrajectory)\n        {\n            trajectoryRenderer = trajectoryTrail.GetComponent<LineRenderer>();\n            if (trajectoryRenderer == null)\n            {\n                trajectoryRenderer = trajectoryTrail.AddComponent<LineRenderer>();\n            }\n\n            trajectoryRenderer.material = trajectoryMaterial ?? new Material(Shader.Find("Sprites/Default"));\n            trajectoryRenderer.startColor = trajectoryColor;\n            trajectoryRenderer.endColor = trajectoryColor;\n            trajectoryRenderer.startWidth = 0.05f;\n            trajectoryRenderer.endWidth = 0.02f;\n        }\n\n        // Setup velocity vectors\n        if (showVelocityVectors)\n        {\n            velocityVectors = new GameObject[1]; // For robot velocity\n            CreateVelocityVector(0, "RobotVelocity");\n        }\n\n        materialPropertyBlock = new MaterialPropertyBlock();\n    }\n\n    public void UpdateRobotState(Vector3 newPosition, Quaternion newOrientation,\n                                float[] newJointPositions, float[] newJointVelocities)\n    {\n        robotPosition = newPosition;\n        robotOrientation = newOrientation;\n        jointPositions = newJointPositions;\n        jointVelocities = newJointVelocities;\n\n        UpdateRobotModel();\n        UpdateTrajectory();\n        UpdateVelocityVectors();\n    }\n\n    void UpdateRobotModel()\n    {\n        if (robotModel != null)\n        {\n            robotModel.transform.position = robotPosition;\n            robotModel.transform.rotation = robotOrientation;\n        }\n\n        // Update joint positions if we have a RobotModelVisualizer\n        RobotModelVisualizer modelVis = robotModel.GetComponent<RobotModelVisualizer>();\n        if (modelVis != null && jointPositions != null)\n        {\n            modelVis.UpdateRobotJoints(jointPositions);\n        }\n    }\n\n    void UpdateTrajectory()\n    {\n        if (!showTrajectory) return;\n\n        trajectoryPoints.Add(robotPosition);\n\n        // Limit trajectory length\n        if (trajectoryPoints.Count > maxTrajectoryPoints)\n        {\n            trajectoryPoints.RemoveAt(0);\n        }\n\n        if (trajectoryRenderer != null)\n        {\n            trajectoryRenderer.positionCount = trajectoryPoints.Count;\n            trajectoryRenderer.SetPositions(trajectoryPoints.ToArray());\n        }\n    }\n\n    void UpdateVelocityVectors()\n    {\n        if (!showVelocityVectors || velocityVectors == null) return;\n\n        // For now, just update the robot\'s velocity vector\n        // In a real implementation, this would come from velocity data\n        Vector3 velocity = CalculateRobotVelocity();\n        UpdateVelocityVector(0, velocity);\n    }\n\n    Vector3 CalculateRobotVelocity()\n    {\n        // This would typically come from odometry or state estimation\n        // For demonstration, we\'ll use a simple approximation\n        return Vector3.forward * 0.5f; // Placeholder\n    }\n\n    void UpdateVelocityVector(int index, Vector3 velocity)\n    {\n        if (index >= velocityVectors.Length) return;\n\n        GameObject velocityObj = velocityVectors[index];\n        if (velocityObj == null) return;\n\n        // Set the direction and magnitude of the velocity vector\n        velocityObj.transform.position = robotPosition;\n        velocityObj.transform.LookAt(robotPosition + velocity * velocityScale);\n        velocityObj.transform.localScale = new Vector3(\n            0.02f, 0.02f, velocity.magnitude * velocityScale\n        );\n    }\n\n    void CreateVelocityVector(int index, string name)\n    {\n        GameObject velocityObj = GameObject.CreatePrimitive(PrimitiveType.Cylinder);\n        velocityObj.name = name;\n        velocityObj.transform.SetParent(transform);\n\n        // Make it look like an arrow\n        GameObject arrowHead = GameObject.CreatePrimitive(PrimitiveType.Cone);\n        arrowHead.transform.SetParent(velocityObj.transform);\n        arrowHead.transform.localPosition = Vector3.forward;\n        arrowHead.transform.localRotation = Quaternion.Euler(0, 0, -90); // Rotate to point forward\n        arrowHead.transform.localScale = Vector3.one * 0.1f;\n\n        // Color it\n        Renderer[] renderers = velocityObj.GetComponentsInChildren<Renderer>();\n        foreach (Renderer r in renderers)\n        {\n            r.material = new Material(Shader.Find("Sprites/Default"));\n            r.material.color = Color.green;\n        }\n\n        velocityVectors[index] = velocityObj;\n\n        // Make non-interactive\n        Collider[] colliders = velocityObj.GetComponentsInChildren<Collider>();\n        foreach (Collider c in colliders)\n        {\n            Destroy(c);\n        }\n    }\n\n    public void ClearTrajectory()\n    {\n        trajectoryPoints.Clear();\n        if (trajectoryRenderer != null)\n        {\n            trajectoryRenderer.positionCount = 0;\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"sensor-data-visualization",children:"Sensor Data Visualization"}),"\n",(0,i.jsx)(e.h3,{id:"point-cloud-visualization",children:"Point Cloud Visualization"}),"\n",(0,i.jsx)(e.p,{children:"Visualizing 3D sensor data like LiDAR or depth cameras requires efficient rendering techniques:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\n\npublic class PointCloudVisualizer : MonoBehaviour\n{\n    [Header("Point Cloud Settings")]\n    public int maxPoints = 100000;\n    public float pointSize = 0.02f;\n    public Color pointColor = Color.white;\n    public bool useIntensityColor = true;\n    public Gradient intensityGradient;\n\n    [Header("Performance Settings")]\n    public int pointsPerFrame = 1000; // Limit points updated per frame\n    public bool useObjectPooling = true;\n\n    private Vector3[] points;\n    private float[] intensities;\n    private GameObject[] pointPool;\n    private int poolIndex = 0;\n    private int currentPointCount = 0;\n\n    void Start()\n    {\n        InitializePointCloud();\n    }\n\n    void InitializePointCloud()\n    {\n        points = new Vector3[maxPoints];\n        intensities = new float[maxPoints];\n\n        if (useObjectPooling)\n        {\n            CreatePointPool();\n        }\n\n        // Setup intensity gradient if using intensity colors\n        if (useIntensityColor && intensityGradient == null)\n        {\n            intensityGradient = new Gradient();\n            GradientColorKey[] colorKeys = new GradientColorKey[3];\n            colorKeys[0] = new GradientColorKey(Color.blue, 0.0f);\n            colorKeys[1] = new GradientColorKey(Color.yellow, 0.5f);\n            colorKeys[2] = new GradientColorKey(Color.red, 1.0f);\n            intensityGradient.colorKeys = colorKeys;\n        }\n    }\n\n    void CreatePointPool()\n    {\n        pointPool = new GameObject[maxPoints];\n\n        for (int i = 0; i < maxPoints; i++)\n        {\n            GameObject point = CreatePointObject();\n            point.SetActive(false);\n            pointPool[i] = point;\n        }\n    }\n\n    GameObject CreatePointObject()\n    {\n        GameObject point = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n        point.transform.SetParent(transform);\n        point.transform.localScale = Vector3.one * pointSize;\n\n        Renderer renderer = point.GetComponent<Renderer>();\n        renderer.material = new Material(Shader.Find("Sprites/Default"));\n\n        // Make non-interactive\n        Destroy(point.GetComponent<Collider>());\n\n        return point;\n    }\n\n    public void UpdatePointCloud(Vector3[] newPoints, float[] newIntensities = null)\n    {\n        int newPointCount = Mathf.Min(newPoints.Length, maxPoints);\n\n        // Clear existing points\n        ClearPoints();\n\n        // Update with new data\n        for (int i = 0; i < newPointCount; i++)\n        {\n            points[i] = newPoints[i];\n            intensities[i] = (newIntensities != null && i < newIntensities.Length) ?\n                            newIntensities[i] : 1.0f;\n        }\n\n        currentPointCount = newPointCount;\n\n        if (useObjectPooling)\n        {\n            UpdatePointPool();\n        }\n        else\n        {\n            CreateNewPointObjects();\n        }\n    }\n\n    void ClearPoints()\n    {\n        if (useObjectPooling)\n        {\n            for (int i = 0; i < pointPool.Length; i++)\n            {\n                if (pointPool[i] != null)\n                {\n                    pointPool[i].SetActive(false);\n                }\n            }\n        }\n        else\n        {\n            // Destroy all child objects\n            foreach (Transform child in transform)\n            {\n                DestroyImmediate(child.gameObject);\n            }\n        }\n\n        poolIndex = 0;\n    }\n\n    void UpdatePointPool()\n    {\n        for (int i = 0; i < currentPointCount; i++)\n        {\n            if (poolIndex >= pointPool.Length) break;\n\n            GameObject pointObj = pointPool[poolIndex];\n            pointObj.SetActive(true);\n            pointObj.transform.position = points[i];\n\n            // Set color based on intensity if enabled\n            if (useIntensityColor)\n            {\n                Color pointColor = intensityGradient.Evaluate(intensities[i]);\n                Renderer renderer = pointObj.GetComponent<Renderer>();\n                renderer.material.color = pointColor;\n            }\n\n            poolIndex++;\n        }\n    }\n\n    void CreateNewPointObjects()\n    {\n        for (int i = 0; i < currentPointCount; i++)\n        {\n            GameObject pointObj = CreatePointObject();\n            pointObj.transform.position = points[i];\n\n            // Set color based on intensity if enabled\n            if (useIntensityColor)\n            {\n                Color pointColor = intensityGradient.Evaluate(intensities[i]);\n                Renderer renderer = pointObj.GetComponent<Renderer>();\n                renderer.material.color = pointColor;\n            }\n        }\n    }\n\n    public void UpdateIncrementally(Vector3[] newPoints, float[] newIntensities = null)\n    {\n        // Update points incrementally to avoid frame drops\n        int pointsToAdd = Mathf.Min(newPoints.Length, pointsPerFrame);\n\n        for (int i = 0; i < pointsToAdd; i++)\n        {\n            if (currentPointCount + i >= maxPoints) break;\n\n            points[currentPointCount + i] = newPoints[i];\n            intensities[currentPointCount + i] = (newIntensities != null && i < newIntensities.Length) ?\n                                                newIntensities[i] : 1.0f;\n\n            if (useObjectPooling && poolIndex < pointPool.Length)\n            {\n                GameObject pointObj = pointPool[poolIndex];\n                pointObj.SetActive(true);\n                pointObj.transform.position = points[currentPointCount + i];\n\n                if (useIntensityColor)\n                {\n                    Color pointColor = intensityGradient.Evaluate(intensities[currentPointCount + i]);\n                    Renderer renderer = pointObj.GetComponent<Renderer>();\n                    renderer.material.color = pointColor;\n                }\n\n                poolIndex++;\n            }\n        }\n\n        currentPointCount += pointsToAdd;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"camera-feed-visualization",children:"Camera Feed Visualization"}),"\n",(0,i.jsx)(e.p,{children:"Displaying camera feeds in Unity for robotics applications:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing UnityEngine.UI;\n\npublic class CameraFeedVisualizer : MonoBehaviour\n{\n    [Header("Camera Feed Settings")]\n    public RawImage cameraDisplay;\n    public AspectRatioFitter aspectRatioFitter;\n    public bool showCameraFeed = true;\n    public bool showDetectionOverlay = true;\n    public Color detectionColor = Color.red;\n\n    [Header("Performance Settings")]\n    public int targetResolutionWidth = 640;\n    public int targetResolutionHeight = 480;\n    public float updateInterval = 0.1f;\n\n    [Header("Detection Overlay")]\n    public GameObject detectionPrefab;\n    public float detectionMinConfidence = 0.5f;\n\n    private Texture2D cameraTexture;\n    private float lastUpdateTime;\n    private System.Collections.Generic.List<DetectedObject> detections;\n\n    [System.Serializable]\n    public class DetectedObject\n    {\n        public string label;\n        public float confidence;\n        public Rect boundingBox; // Normalized coordinates (0-1)\n    }\n\n    void Start()\n    {\n        InitializeCameraFeed();\n    }\n\n    void InitializeCameraFeed()\n    {\n        cameraTexture = new Texture2D(targetResolutionWidth, targetResolutionHeight, TextureFormat.RGB24, false);\n        cameraDisplay.texture = cameraTexture;\n\n        if (aspectRatioFitter != null)\n        {\n            aspectRatioFitter.aspectRatio = (float)targetResolutionWidth / targetResolutionHeight;\n        }\n\n        detections = new System.Collections.Generic.List<DetectedObject>();\n    }\n\n    public void UpdateCameraFeed(byte[] imageData)\n    {\n        if (!showCameraFeed || cameraTexture == null) return;\n\n        if (Time.time - lastUpdateTime >= updateInterval)\n        {\n            // Load image data into texture\n            cameraTexture.LoadImage(imageData);\n            lastUpdateTime = Time.time;\n        }\n    }\n\n    public void UpdateCameraFeed(Texture2D newTexture)\n    {\n        if (!showCameraFeed || newTexture == null) return;\n\n        if (Time.time - lastUpdateTime >= updateInterval)\n        {\n            // Resize texture if needed\n            if (newTexture.width != cameraTexture.width || newTexture.height != cameraTexture.height)\n            {\n                cameraTexture.Resize(newTexture.width, newTexture.height);\n            }\n\n            // Copy texture data\n            Graphics.CopyTexture(newTexture, cameraTexture);\n            lastUpdateTime = Time.time;\n        }\n    }\n\n    public void UpdateDetections(System.Collections.Generic.List<DetectedObject> newDetections)\n    {\n        if (!showDetectionOverlay) return;\n\n        detections.Clear();\n        detections.AddRange(newDetections);\n\n        UpdateDetectionOverlay();\n    }\n\n    void UpdateDetectionOverlay()\n    {\n        if (!showDetectionOverlay || detectionPrefab == null) return;\n\n        // Clear existing detection objects\n        foreach (Transform child in cameraDisplay.transform)\n        {\n            if (child.name.StartsWith("Detection_"))\n            {\n                Destroy(child.gameObject);\n            }\n        }\n\n        // Create new detection objects\n        foreach (DetectedObject detection in detections)\n        {\n            if (detection.confidence < detectionMinConfidence) continue;\n\n            GameObject detectionObj = Instantiate(detectionPrefab, cameraDisplay.transform);\n            detectionObj.name = $"Detection_{detection.label}";\n\n            // Convert normalized coordinates to UI coordinates\n            RectTransform rectTransform = detectionObj.GetComponent<RectTransform>();\n            if (rectTransform != null)\n            {\n                // Calculate position and size based on normalized bounding box\n                float width = detection.boundingBox.width * cameraDisplay.rectTransform.rect.width;\n                float height = detection.boundingBox.height * cameraDisplay.rectTransform.rect.height;\n                float x = (detection.boundingBox.x - 0.5f) * cameraDisplay.rectTransform.rect.width;\n                float y = (detection.boundingBox.y - 0.5f) * cameraDisplay.rectTransform.rect.height;\n\n                rectTransform.anchoredPosition = new Vector2(x, -y); // Flip Y for UI\n                rectTransform.sizeDelta = new Vector2(width, height);\n            }\n\n            // Set detection label\n            Text labelComponent = detectionObj.GetComponentInChildren<Text>();\n            if (labelComponent != null)\n            {\n                labelComponent.text = $"{detection.label}: {(detection.confidence * 100):F1}%";\n            }\n\n            // Set detection color\n            Image imageComponent = detectionObj.GetComponent<Image>();\n            if (imageComponent != null)\n            {\n                Color color = detectionColor;\n                color.a = 0.3f; // Semi-transparent\n                imageComponent.color = color;\n            }\n        }\n    }\n\n    public void SetCameraVisibility(bool visible)\n    {\n        showCameraFeed = visible;\n        cameraDisplay.gameObject.SetActive(visible);\n    }\n\n    public void SetDetectionVisibility(bool visible)\n    {\n        showDetectionOverlay = visible;\n\n        // Hide all detection objects\n        foreach (Transform child in cameraDisplay.transform)\n        {\n            if (child.name.StartsWith("Detection_"))\n            {\n                child.gameObject.SetActive(visible);\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"advanced-visualization-techniques",children:"Advanced Visualization Techniques"}),"\n",(0,i.jsx)(e.h3,{id:"custom-shaders-for-robotics-visualization",children:"Custom Shaders for Robotics Visualization"}),"\n",(0,i.jsx)(e.p,{children:"Creating custom shaders for specialized robotics visualization:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'// This would typically be in a separate .shader file, but shown here as a string for context\npublic class RoboticsShaders : MonoBehaviour\n{\n    public static string GetPointCloudShader()\n    {\n        return @"\n            Shader ""Custom/PointCloudShader""\n            {\n                Properties\n                {\n                    _PointSize (""Point Size"", Range(0.01, 0.1)) = 0.02\n                    _PointColor (""Point Color"", Color) = (1,1,1,1)\n                    _MinIntensity (""Min Intensity"", Range(0, 1)) = 0\n                    _MaxIntensity (""Max Intensity"", Range(0, 1)) = 1\n                }\n                SubShader\n                {\n                    Pass\n                    {\n                        CGPROGRAM\n                        #pragma vertex vert\n                        #pragma fragment frag\n                        #include ""UnityCG.cginc""\n\n                        struct appdata\n                        {\n                            float4 vertex : POSITION;\n                            float intensity : TEXCOORD0;\n                        };\n\n                        struct v2f\n                        {\n                            float4 pos : SV_POSITION;\n                            fixed4 color : COLOR;\n                        };\n\n                        float _PointSize;\n                        fixed4 _PointColor;\n                        float _MinIntensity;\n                        float _MaxIntensity;\n\n                        v2f vert (appdata v)\n                        {\n                            v2f o;\n                            o.pos = UnityObjectToClipPos(v.vertex);\n                            o.color = _PointColor;\n\n                            // Map intensity to color\n                            float intensity = saturate((v.intensity - _MinIntensity) / (_MaxIntensity - _MinIntensity));\n                            o.color.rgb = lerp(fixed3(0,0,1), fixed3(1,0,0), intensity);\n\n                            return o;\n                        }\n\n                        fixed4 frag (v2f i) : SV_Target\n                        {\n                            return i.color;\n                        }\n                        ENDCG\n                    }\n                }\n            }";\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"performance-optimization-for-large-scale-visualization",children:"Performance Optimization for Large-Scale Visualization"}),"\n",(0,i.jsx)(e.p,{children:"Optimizing Unity applications for handling large amounts of robotics data:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing System.Collections.Generic;\n\npublic class VisualizationOptimizer : MonoBehaviour\n{\n    [Header("LOD Settings")]\n    public int[] lodDistances = { 10, 20, 50 }; // Distances for each LOD level\n    public int maxLODLevel = 3;\n\n    [Header("Culling Settings")]\n    public float maxVisualizationDistance = 100.0f;\n    public bool enableFrustumCulling = true;\n    public bool enableOcclusionCulling = false;\n\n    [Header("Performance Settings")]\n    public float targetFrameRate = 60.0f;\n    public bool dynamicQualityAdjustment = true;\n    public float qualityAdjustmentInterval = 1.0f;\n\n    [Header("Visualization Toggles")]\n    public bool showTrajectories = true;\n    public bool showSensorData = true;\n    public bool showDebugInfo = false;\n\n    private float lastQualityAdjustmentTime;\n    private int currentQualityLevel = 2; // Start at medium quality\n    private float currentFrameRate;\n    private Queue<float> frameRateHistory = new Queue<float>();\n    private const int frameRateHistorySize = 30;\n\n    void Start()\n    {\n        SetupOptimization();\n    }\n\n    void SetupOptimization()\n    {\n        Application.targetFrameRate = Mathf.RoundToInt(targetFrameRate);\n\n        // Setup quality settings\n        SetupQualityLevels();\n    }\n\n    void SetupQualityLevels()\n    {\n        // Define different quality levels\n        QualitySettings.SetQualityLevel(currentQualityLevel);\n    }\n\n    void Update()\n    {\n        UpdateFrameRate();\n\n        if (dynamicQualityAdjustment &&\n            Time.time - lastQualityAdjustmentTime >= qualityAdjustmentInterval)\n        {\n            AdjustQualityBasedOnPerformance();\n            lastQualityAdjustmentTime = Time.time;\n        }\n\n        ApplyVisualizationSettings();\n    }\n\n    void UpdateFrameRate()\n    {\n        float frameRate = 1.0f / Time.unscaledDeltaTime;\n\n        // Maintain history for smoothing\n        frameRateHistory.Enqueue(frameRate);\n        if (frameRateHistory.Count > frameRateHistorySize)\n        {\n            frameRateHistory.Dequeue();\n        }\n\n        // Calculate average frame rate\n        float sum = 0;\n        foreach (float rate in frameRateHistory)\n        {\n            sum += rate;\n        }\n        currentFrameRate = sum / frameRateHistory.Count;\n    }\n\n    void AdjustQualityBasedOnPerformance()\n    {\n        // Adjust quality based on current frame rate\n        if (currentFrameRate < targetFrameRate * 0.7f)\n        {\n            // Performance is poor, reduce quality\n            if (currentQualityLevel > 0)\n            {\n                currentQualityLevel--;\n                QualitySettings.SetQualityLevel(currentQualityLevel);\n\n                // Also reduce visualization complexity\n                ReduceVisualizationComplexity();\n            }\n        }\n        else if (currentFrameRate > targetFrameRate * 0.9f)\n        {\n            // Performance is good, increase quality\n            if (currentQualityLevel < QualitySettings.names.Length - 1)\n            {\n                currentQualityLevel++;\n                QualitySettings.SetQualityLevel(currentQualityLevel);\n\n                // Restore visualization complexity\n                RestoreVisualizationComplexity();\n            }\n        }\n    }\n\n    void ReduceVisualizationComplexity()\n    {\n        // Reduce visualization complexity to improve performance\n        showTrajectories = false;\n        showSensorData = false;\n        showDebugInfo = false;\n    }\n\n    void RestoreVisualizationComplexity()\n    {\n        // Restore visualization complexity\n        showTrajectories = true;\n        showSensorData = true;\n        showDebugInfo = false; // Keep debug off by default\n    }\n\n    void ApplyVisualizationSettings()\n    {\n        // Apply visualization settings to child components\n        RobotVisualizer[] robotVisualizers = GetComponentsInChildren<RobotVisualizer>();\n        foreach (RobotVisualizer visualizer in robotVisualizers)\n        {\n            if (visualizer != null)\n            {\n                visualizer.showTrajectory = showTrajectories;\n                visualizer.showSensorData = showSensorData;\n            }\n        }\n\n        RealTimeRobotVisualizer[] realTimeVisualizers = GetComponentsInChildren<RealTimeRobotVisualizer>();\n        foreach (RealTimeRobotVisualizer visualizer in realTimeVisualizers)\n        {\n            if (visualizer != null)\n            {\n                visualizer.showTrajectory = showTrajectories;\n                visualizer.showVelocityVectors = showSensorData;\n            }\n        }\n    }\n\n    public void SetVisualizationQuality(int qualityLevel)\n    {\n        currentQualityLevel = Mathf.Clamp(qualityLevel, 0, QualitySettings.names.Length - 1);\n        QualitySettings.SetQualityLevel(currentQualityLevel);\n    }\n\n    public float GetCurrentFrameRate()\n    {\n        return currentFrameRate;\n    }\n\n    public float GetTargetFrameRate()\n    {\n        return targetFrameRate;\n    }\n\n    public bool IsPerformanceOptimal()\n    {\n        return currentFrameRate >= targetFrameRate * 0.9f;\n    }\n\n    public void ForceQualityAdjustment()\n    {\n        AdjustQualityBasedOnPerformance();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"best-practices-for-robotics-visualization",children:"Best Practices for Robotics Visualization"}),"\n",(0,i.jsx)(e.h3,{id:"data-management-and-memory-optimization",children:"Data Management and Memory Optimization"}),"\n",(0,i.jsx)(e.p,{children:"Efficiently handling large amounts of robotics data:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing System.Collections.Generic;\n\npublic class RoboticsDataManager : MonoBehaviour\n{\n    [Header("Data Management")]\n    public int maxDataPoints = 10000;\n    public float dataRetentionTime = 30.0f; // seconds\n    public bool compressOldData = true;\n\n    private Dictionary<string, CircularBuffer<Vector3>> positionBuffers;\n    private Dictionary<string, CircularBuffer<float>> scalarBuffers;\n    private Dictionary<string, float> lastUpdateTime;\n\n    [System.Serializable]\n    public class CircularBuffer<T>\n    {\n        private T[] buffer;\n        private int head;\n        private int count;\n        private int capacity;\n\n        public CircularBuffer(int size)\n        {\n            capacity = size;\n            buffer = new T[capacity];\n            head = 0;\n            count = 0;\n        }\n\n        public void Add(T item)\n        {\n            if (count < capacity)\n            {\n                buffer[count] = item;\n                count++;\n            }\n            else\n            {\n                buffer[head] = item;\n                head = (head + 1) % capacity;\n            }\n        }\n\n        public T this[int index]\n        {\n            get\n            {\n                if (index >= count) throw new System.IndexOutOfRangeException();\n                int actualIndex = (head + index) % capacity;\n                return buffer[actualIndex];\n            }\n        }\n\n        public int Count { get { return count; } }\n        public int Capacity { get { return capacity; } }\n    }\n\n    void Start()\n    {\n        InitializeDataBuffers();\n    }\n\n    void InitializeDataBuffers()\n    {\n        positionBuffers = new Dictionary<string, CircularBuffer<Vector3>>();\n        scalarBuffers = new Dictionary<string, CircularBuffer<float>>();\n        lastUpdateTime = new Dictionary<string, float>();\n    }\n\n    public void AddPositionData(string topic, Vector3 position)\n    {\n        if (!positionBuffers.ContainsKey(topic))\n        {\n            positionBuffers[topic] = new CircularBuffer<Vector3>(maxDataPoints);\n        }\n\n        positionBuffers[topic].Add(position);\n        lastUpdateTime[topic] = Time.time;\n    }\n\n    public void AddScalarData(string topic, float value)\n    {\n        if (!scalarBuffers.ContainsKey(topic))\n        {\n            scalarBuffers[topic] = new CircularBuffer<float>(maxDataPoints);\n        }\n\n        scalarBuffers[topic].Add(value);\n        lastUpdateTime[topic] = Time.time;\n    }\n\n    public List<Vector3> GetPositionHistory(string topic, int count = -1)\n    {\n        if (!positionBuffers.ContainsKey(topic)) return new List<Vector3>();\n\n        CircularBuffer<Vector3> buffer = positionBuffers[topic];\n        int actualCount = count == -1 ? buffer.Count : Mathf.Min(count, buffer.Count);\n\n        List<Vector3> result = new List<Vector3>(actualCount);\n\n        for (int i = 0; i < actualCount; i++)\n        {\n            int bufferIndex = buffer.Count - actualCount + i;\n            result.Add(buffer[bufferIndex]);\n        }\n\n        return result;\n    }\n\n    public List<float> GetScalarHistory(string topic, int count = -1)\n    {\n        if (!scalarBuffers.ContainsKey(topic)) return new List<float>();\n\n        CircularBuffer<float> buffer = scalarBuffers[topic];\n        int actualCount = count == -1 ? buffer.Count : Mathf.Min(count, buffer.Count);\n\n        List<float> result = new List<float>(actualCount);\n\n        for (int i = 0; i < actualCount; i++)\n        {\n            int bufferIndex = buffer.Count - actualCount + i;\n            result.Add(buffer[bufferIndex]);\n        }\n\n        return result;\n    }\n\n    public Vector3 GetLatestPosition(string topic)\n    {\n        if (!positionBuffers.ContainsKey(topic) || positionBuffers[topic].Count == 0)\n        {\n            return Vector3.zero;\n        }\n\n        CircularBuffer<Vector3> buffer = positionBuffers[topic];\n        return buffer[buffer.Count - 1];\n    }\n\n    public float GetLatestScalar(string topic)\n    {\n        if (!scalarBuffers.ContainsKey(topic) || scalarBuffers[topic].Count == 0)\n        {\n            return 0.0f;\n        }\n\n        CircularBuffer<float> buffer = scalarBuffers[topic];\n        return buffer[buffer.Count - 1];\n    }\n\n    void Update()\n    {\n        // Clean up old data periodically\n        if (Time.frameCount % 60 == 0) // Every ~1 second at 60 FPS\n        {\n            CleanupOldData();\n        }\n    }\n\n    void CleanupOldData()\n    {\n        List<string> topicsToRemove = new List<string>();\n\n        foreach (var pair in lastUpdateTime)\n        {\n            if (Time.time - pair.Value > dataRetentionTime)\n            {\n                topicsToRemove.Add(pair.Key);\n            }\n        }\n\n        foreach (string topic in topicsToRemove)\n        {\n            if (positionBuffers.ContainsKey(topic))\n            {\n                positionBuffers.Remove(topic);\n            }\n            if (scalarBuffers.ContainsKey(topic))\n            {\n                scalarBuffers.Remove(topic);\n            }\n            if (lastUpdateTime.ContainsKey(topic))\n            {\n                lastUpdateTime.Remove(topic);\n            }\n        }\n    }\n\n    public void ClearAllData()\n    {\n        positionBuffers.Clear();\n        scalarBuffers.Clear();\n        lastUpdateTime.Clear();\n    }\n\n    public void ClearTopicData(string topic)\n    {\n        if (positionBuffers.ContainsKey(topic))\n        {\n            positionBuffers.Remove(topic);\n        }\n        if (scalarBuffers.ContainsKey(topic))\n        {\n            scalarBuffers.Remove(topic);\n        }\n        if (lastUpdateTime.ContainsKey(topic))\n        {\n            lastUpdateTime.Remove(topic);\n        }\n    }\n\n    public int GetBufferCount(string topic)\n    {\n        if (positionBuffers.ContainsKey(topic))\n        {\n            return positionBuffers[topic].Count;\n        }\n        if (scalarBuffers.ContainsKey(topic))\n        {\n            return scalarBuffers[topic].Count;\n        }\n        return 0;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"Unity visualization techniques for robotics provide powerful tools for creating immersive and informative interfaces. By implementing efficient data management, optimized rendering techniques, and proper performance optimization, you can create visualization systems that effectively support human-robot interaction and robot monitoring in Physical AI applications."})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>s});var i=t(6540);const o={},a=i.createContext(o);function r(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);