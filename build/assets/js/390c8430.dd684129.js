"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[2925],{4880:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var i=t(4848),o=t(8453);const r={title:"Chapter 8 - Unity Workflows for Robotics"},a="Unity Workflows for Robotics",s={id:"unity-visualization/unity-workflows",title:"Chapter 8 - Unity Workflows for Robotics",description:"Introduction to Unity Robotics Workflows",source:"@site/docs/physical-ai/unity-visualization/03-unity-workflows.mdx",sourceDirName:"unity-visualization",slug:"/unity-visualization/unity-workflows",permalink:"/unity-visualization/unity-workflows",draft:!1,unlisted:!1,editUrl:"https://github.com/MuhammadFuzail591/new-book-physical-ai/tree/main/docs/physical-ai/unity-visualization/03-unity-workflows.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Chapter 8 - Unity Workflows for Robotics"}},l={},c=[{value:"Introduction to Unity Robotics Workflows",id:"introduction-to-unity-robotics-workflows",level:2},{value:"Development Environment Setup",id:"development-environment-setup",level:2},{value:"Unity Installation for Robotics",id:"unity-installation-for-robotics",level:3},{value:"Essential Unity Packages for Robotics",id:"essential-unity-packages-for-robotics",level:3},{value:"Project Configuration",id:"project-configuration",level:3},{value:"Importing Robot Models",id:"importing-robot-models",level:2},{value:"URDF Import Workflow",id:"urdf-import-workflow",level:3},{value:"Model Optimization Workflow",id:"model-optimization-workflow",level:3},{value:"Unity-ROS Integration Workflows",id:"unity-ros-integration-workflows",level:2},{value:"Setting up ROS Connection",id:"setting-up-ros-connection",level:3},{value:"Publisher and Subscriber Patterns",id:"publisher-and-subscriber-patterns",level:3},{value:"Visualization Workflows",id:"visualization-workflows",level:2},{value:"Real-time Data Visualization",id:"real-time-data-visualization",level:3},{value:"Performance Optimization Workflows",id:"performance-optimization-workflows",level:2},{value:"Scene Optimization",id:"scene-optimization",level:3},{value:"Build and Deployment Workflows",id:"build-and-deployment-workflows",level:2},{value:"Building for Different Platforms",id:"building-for-different-platforms",level:3},{value:"Testing and Validation Workflows",id:"testing-and-validation-workflows",level:2},{value:"Automated Testing for Robotics Visualization",id:"automated-testing-for-robotics-visualization",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"unity-workflows-for-robotics",children:"Unity Workflows for Robotics"}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-unity-robotics-workflows",children:"Introduction to Unity Robotics Workflows"}),"\n",(0,i.jsx)(e.p,{children:"Unity workflows for robotics encompass the complete pipeline from setting up the development environment to deploying applications for robot visualization and interaction. These workflows integrate Unity's powerful rendering engine with robotics frameworks to create immersive and functional interfaces for human-robot interaction, teleoperation, and robot monitoring."}),"\n",(0,i.jsx)(e.h2,{id:"development-environment-setup",children:"Development Environment Setup"}),"\n",(0,i.jsx)(e.h3,{id:"unity-installation-for-robotics",children:"Unity Installation for Robotics"}),"\n",(0,i.jsx)(e.p,{children:"Setting up Unity for robotics applications requires specific configurations and packages:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Unity Hub is the recommended way to manage Unity installations\n# Download from: https://unity3d.com/get-unity/download\n\n# Install Unity LTS version (recommended for stability)\n# At the time of writing, Unity 2022.3.x LTS is recommended\n\n# During installation, select the following modules:\n# - Android Build Support (if targeting mobile VR)\n# - iOS Build Support (if targeting iOS devices)\n# - Windows Build Support\n# - Linux Build Support\n# - Visual Studio integration\n"})}),"\n",(0,i.jsx)(e.h3,{id:"essential-unity-packages-for-robotics",children:"Essential Unity Packages for Robotics"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'// Unity Robotics Package Manager entries (Packages/manifest.json)\n{\n  "dependencies": {\n    "com.unity.robotics.ros-tcp-connector": "0.7.0",\n    "com.unity.robotics.urdf-importer": "0.5.2",\n    "com.unity.robotics.visualizations": "0.1.0",\n    "com.unity.xr.legacyinputhelpers": "2.1.10",\n    "com.unity.inputsystem": "1.5.1"\n  }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"project-configuration",children:"Project Configuration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing UnityEditor;\n\npublic class RoboticsProjectSetup : MonoBehaviour\n{\n    [MenuItem("Robotics/Setup Project")]\n    public static void SetupRoboticsProject()\n    {\n        // Configure project settings for robotics applications\n        ConfigureGraphicsSettings();\n        ConfigurePhysicsSettings();\n        ConfigureXRSettings();\n        ConfigureLayers();\n\n        Debug.Log("Robotics project setup completed!");\n    }\n\n    private static void ConfigureGraphicsSettings()\n    {\n        // Set up rendering for real-time robotics visualization\n        QualitySettings.vSyncCount = 0; // Disable VSync for consistent frame rate\n        Application.targetFrameRate = 60;\n\n        // Configure rendering pipeline (URP/HDRP/Standard)\n        // For robotics visualization, Standard is often sufficient\n    }\n\n    private static void ConfigurePhysicsSettings()\n    {\n        // Adjust physics settings for robotics simulation\n        Physics.defaultSolverIterations = 8;\n        Physics.defaultSolverVelocityIterations = 2;\n        Physics.sleepThreshold = 0.001f;\n    }\n\n    private static void ConfigureXRSettings()\n    {\n        // Configure XR settings if using VR/AR\n        // This is optional for basic visualization\n    }\n\n    private static void ConfigureLayers()\n    {\n        // Set up layers for different robot components\n        // Layer 8: RobotBase\n        // Layer 9: RobotLinks\n        // Layer 10: RobotJoints\n        // Layer 11: Environment\n        // Layer 12: Sensors\n        // Layer 13: UI\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"importing-robot-models",children:"Importing Robot Models"}),"\n",(0,i.jsx)(e.h3,{id:"urdf-import-workflow",children:"URDF Import Workflow"}),"\n",(0,i.jsx)(e.p,{children:"Unity provides tools for importing URDF (Unified Robot Description Format) files:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.URDF;\n\npublic class RobotModelImporter : MonoBehaviour\n{\n    [Header("URDF Import Settings")]\n    public string urdfPath = "Assets/Robots/my_robot.urdf";\n    public ImportSettings importSettings;\n\n    [System.Serializable]\n    public class ImportSettings\n    {\n        public bool useCollisionMeshes = true;\n        public bool createArticulations = true;\n        public bool importInertial = true;\n        public bool importMaterials = true;\n        public float scale = 1.0f;\n    }\n\n    public void ImportURDF()\n    {\n        if (string.IsNullOrEmpty(urdfPath))\n        {\n            Debug.LogError("URDF path is not set!");\n            return;\n        }\n\n        try\n        {\n            // Import the URDF model\n            GameObject robot = URDFRobotExtensions.LoadRobot(urdfPath);\n\n            if (robot != null)\n            {\n                robot.name = "ImportedRobot";\n\n                // Configure the imported robot\n                ConfigureImportedRobot(robot);\n\n                Debug.Log($"Successfully imported robot from: {urdfPath}");\n            }\n            else\n            {\n                Debug.LogError($"Failed to import robot from: {urdfPath}");\n            }\n        }\n        catch (System.Exception e)\n        {\n            Debug.LogError($"Error importing URDF: {e.Message}");\n        }\n    }\n\n    void ConfigureImportedRobot(GameObject robot)\n    {\n        // Add robotics-specific components to the imported model\n        RobotModelVisualizer visualizer = robot.AddComponent<RobotModelVisualizer>();\n        visualizer.InitializeFromURDF();\n\n        // Set up joint controllers\n        SetupJointControllers(robot);\n    }\n\n    void SetupJointControllers(GameObject robot)\n    {\n        // Find all joint objects and set up controllers\n        Joint[] joints = robot.GetComponentsInChildren<Joint>();\n\n        foreach (Joint joint in joints)\n        {\n            // Configure joint for Unity physics\n            if (joint is HingeJoint)\n            {\n                HingeJoint hinge = joint as HingeJoint;\n                // Configure hinge joint parameters\n                hinge.useLimits = true;\n                JointLimits limits = hinge.limits;\n                limits.min = -180f;\n                limits.max = 180f;\n                hinge.limits = limits;\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"model-optimization-workflow",children:"Model Optimization Workflow"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\n\npublic class RobotModelOptimizer : MonoBehaviour\n{\n    [Header("Optimization Settings")]\n    public bool optimizeMeshes = true;\n    public bool optimizeMaterials = true;\n    public bool optimizeTextures = true;\n    public int targetPolyCount = 50000; // Target polygon count\n\n    [Header("LOD Settings")]\n    public bool generateLODs = true;\n    public int lodCount = 3;\n    public float[] lodDistances = {10f, 20f, 50f};\n\n    public void OptimizeRobotModel()\n    {\n        GameObject robot = gameObject;\n\n        if (optimizeMeshes)\n        {\n            OptimizeMeshes(robot);\n        }\n\n        if (optimizeMaterials)\n        {\n            OptimizeMaterials(robot);\n        }\n\n        if (generateLODs)\n        {\n            GenerateLODs(robot);\n        }\n\n        Debug.Log("Robot model optimization completed!");\n    }\n\n    void OptimizeMeshes(GameObject robot)\n    {\n        // Reduce polygon count while maintaining visual quality\n        MeshFilter[] meshFilters = robot.GetComponentsInChildren<MeshFilter>();\n\n        foreach (MeshFilter filter in meshFilters)\n        {\n            // Apply mesh optimization techniques\n            OptimizeSingleMesh(filter);\n        }\n    }\n\n    void OptimizeSingleMesh(MeshFilter filter)\n    {\n        // In a real implementation, this would use mesh optimization algorithms\n        // Unity\'s built-in tools or third-party solutions like Simplygon\n        Mesh originalMesh = filter.mesh;\n\n        // Apply optimization based on target polygon count\n        // This is a simplified placeholder\n        Debug.Log($"Optimizing mesh: {filter.name}");\n    }\n\n    void OptimizeMaterials(GameObject robot)\n    {\n        // Combine similar materials and reduce texture count\n        Renderer[] renderers = robot.GetComponentsInChildren<Renderer>();\n\n        // Group renderers by material properties\n        System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<Renderer>> materialGroups =\n            new System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<Renderer>>();\n\n        foreach (Renderer renderer in renderers)\n        {\n            foreach (Material material in renderer.sharedMaterials)\n            {\n                string materialKey = GetMaterialKey(material);\n\n                if (!materialGroups.ContainsKey(materialKey))\n                {\n                    materialGroups[materialKey] = new System.Collections.Generic.List<Renderer>();\n                }\n\n                materialGroups[materialKey].Add(renderer);\n            }\n        }\n\n        // Combine materials where possible\n        CombineSimilarMaterials(materialGroups);\n    }\n\n    string GetMaterialKey(Material material)\n    {\n        // Create a unique key based on material properties\n        return material.shader.name + "_" +\n               material.GetTexture("_MainTex")?.name ?? "NoTexture";\n    }\n\n    void CombineSimilarMaterials(System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<Renderer>> materialGroups)\n    {\n        // Combine renderers that use similar materials\n        foreach (var group in materialGroups)\n        {\n            if (group.Value.Count > 1)\n            {\n                // Combine meshes that use the same material\n                CombineRenderersWithSameMaterial(group.Value);\n            }\n        }\n    }\n\n    void CombineRenderersWithSameMaterial(System.Collections.Generic.List<Renderer> renderers)\n    {\n        // Combine multiple renderers into a single renderer\n        // This reduces draw calls and improves performance\n        Debug.Log($"Combining {renderers.Count} renderers with similar materials");\n    }\n\n    void GenerateLODs(GameObject robot)\n    {\n        // Create Level of Detail (LOD) groups for the robot\n        LODGroup lodGroup = robot.GetComponent<LODGroup>();\n        if (lodGroup == null)\n        {\n            lodGroup = robot.AddComponent<LODGroup>();\n        }\n\n        // Create LOD levels with different detail\n        LOD[] lods = new LOD[lodCount];\n\n        for (int i = 0; i < lodCount; i++)\n        {\n            float screenRelativeTransitionHeight = lodDistances[i] / 100f; // Normalize\n            Renderer[] renderers = GetLODRenderers(robot, i);\n\n            lods[i] = new LOD(screenRelativeTransitionHeight, renderers);\n        }\n\n        lodGroup.SetLODs(lods);\n        lodGroup.RecalculateBounds();\n    }\n\n    Renderer[] GetLODRenderers(GameObject robot, int lodLevel)\n    {\n        // Return appropriate renderers for each LOD level\n        // In practice, this would involve hiding/showing different components\n        return robot.GetComponentsInChildren<Renderer>();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"unity-ros-integration-workflows",children:"Unity-ROS Integration Workflows"}),"\n",(0,i.jsx)(e.h3,{id:"setting-up-ros-connection",children:"Setting up ROS Connection"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing RosMessageTypes.Std;\n\npublic class ROSConnectionManager : MonoBehaviour\n{\n    [Header("ROS Connection Settings")]\n    public string rosIP = "127.0.0.1";\n    public int rosPort = 10000;\n    public float connectionTimeout = 10.0f;\n\n    [Header("Connection Status")]\n    public bool isConnected = false;\n    public float lastHeartbeatTime;\n\n    private ROSConnection rosConnection;\n    private float connectionAttemptTime;\n\n    void Start()\n    {\n        InitializeROSConnection();\n    }\n\n    void InitializeROSConnection()\n    {\n        try\n        {\n            rosConnection = ROSConnection.instance;\n\n            // Set up connection event handlers\n            rosConnection.OnConnected += OnConnected;\n            rosConnection.OnDisconnected += OnDisconnected;\n\n            // Attempt to connect to ROS\n            ConnectToROS();\n        }\n        catch (System.Exception e)\n        {\n            Debug.LogError($"Error initializing ROS connection: {e.Message}");\n        }\n    }\n\n    public void ConnectToROS()\n    {\n        try\n        {\n            rosConnection.Initialize(rosIP, rosPort);\n            connectionAttemptTime = Time.time;\n            Debug.Log($"Attempting to connect to ROS at {rosIP}:{rosPort}");\n        }\n        catch (System.Exception e)\n        {\n            Debug.LogError($"Failed to initialize ROS connection: {e.Message}");\n        }\n    }\n\n    void OnConnected()\n    {\n        isConnected = true;\n        lastHeartbeatTime = Time.time;\n        Debug.Log("Connected to ROS!");\n\n        // Subscribe to relevant topics\n        SetupROSTopics();\n    }\n\n    void OnDisconnected()\n    {\n        isConnected = false;\n        Debug.LogWarning("Disconnected from ROS!");\n\n        // Attempt reconnection after delay\n        Invoke("ConnectToROS", 2.0f);\n    }\n\n    void SetupROSTopics()\n    {\n        // Subscribe to robot state topics\n        rosConnection.Subscribe<UInt8Msg>("robot_mode", OnRobotModeReceived);\n        rosConnection.Subscribe<UInt32Msg>("robot_status", OnRobotStatusReceived);\n\n        // Subscribe to sensor topics\n        rosConnection.Subscribe<UInt8MultiArrayMsg>("sensor_data", OnSensorDataReceived);\n\n        Debug.Log("Subscribed to ROS topics");\n    }\n\n    void OnRobotModeReceived(UInt8Msg mode)\n    {\n        // Handle robot mode updates\n        Debug.Log($"Robot mode updated: {mode.data}");\n    }\n\n    void OnRobotStatusReceived(UInt32Msg status)\n    {\n        // Handle robot status updates\n        Debug.Log($"Robot status: {status.data}");\n        lastHeartbeatTime = Time.time;\n    }\n\n    void OnSensorDataReceived(UInt8MultiArrayMsg data)\n    {\n        // Handle sensor data\n        Debug.Log($"Received sensor data: {data.data.Length} bytes");\n    }\n\n    void Update()\n    {\n        CheckConnectionHealth();\n    }\n\n    void CheckConnectionHealth()\n    {\n        if (isConnected && (Time.time - lastHeartbeatTime) > 5.0f)\n        {\n            // Consider connection stale, check if still alive\n            // Send a heartbeat message to verify connection\n            SendHeartbeat();\n        }\n\n        if (!isConnected && (Time.time - connectionAttemptTime) > connectionTimeout)\n        {\n            // Force reconnection if timeout reached\n            ConnectToROS();\n        }\n    }\n\n    void SendHeartbeat()\n    {\n        // Send a heartbeat message to verify connection\n        var heartbeat = new UInt32Msg();\n        heartbeat.data = (uint)System.DateTime.Now.Ticks;\n\n        rosConnection.Send("unity_heartbeat", heartbeat);\n    }\n\n    void OnApplicationQuit()\n    {\n        if (rosConnection != null)\n        {\n            rosConnection.OnConnected -= OnConnected;\n            rosConnection.OnDisconnected -= OnDisconnected;\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"publisher-and-subscriber-patterns",children:"Publisher and Subscriber Patterns"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing RosMessageTypes.Std;\nusing RosMessageTypes.Geometry;\nusing RosMessageTypes.Sensor;\n\npublic class RobotControlPublisher : MonoBehaviour\n{\n    [Header("ROS Topics")]\n    public string jointCommandTopic = "joint_group_position_controller/command";\n    public string twistCommandTopic = "cmd_vel";\n    public string trajectoryTopic = "move_group/display_planned_path";\n\n    [Header("Control Settings")]\n    public float commandRate = 10.0f; // Hz\n    public float lastCommandTime;\n\n    private ROSConnection ros;\n\n    void Start()\n    {\n        ros = ROSConnection.instance;\n        lastCommandTime = Time.time;\n    }\n\n    void Update()\n    {\n        // Send commands at specified rate\n        if (Time.time - lastCommandTime >= 1.0f/commandRate)\n        {\n            SendRobotCommands();\n            lastCommandTime = Time.time;\n        }\n    }\n\n    public void SendJointCommands(float[] positions)\n    {\n        if (ros == null) return;\n\n        // Create joint trajectory message\n        var jointMsg = new JointTrajectoryMsg();\n        jointMsg.header.stamp = new TimeStamp(ROSConnection.GetNodeTime());\n        jointMsg.header.frame_id = "base_link";\n\n        // Set joint names (this should match your robot\'s joint names)\n        jointMsg.joint_names = new string[] { "joint1", "joint2", "joint3", "joint4", "joint5", "joint6" };\n\n        // Create trajectory point\n        var point = new JointTrajectoryPointMsg();\n        point.positions = new double[positions.Length];\n        for (int i = 0; i < positions.Length; i++)\n        {\n            point.positions[i] = positions[i];\n        }\n\n        // Set velocities to smooth movement\n        point.velocities = new double[positions.Length];\n        for (int i = 0; i < positions.Length; i++)\n        {\n            point.velocities[i] = 0.0; // Let the controller handle velocities\n        }\n\n        // Set time from start\n        point.time_from_start = new Duration(1, 0); // 1 second\n\n        jointMsg.points = new JointTrajectoryPointMsg[] { point };\n\n        ros.Send(jointCommandTopic, jointMsg);\n    }\n\n    public void SendVelocityCommand(float linearX, float angularZ)\n    {\n        if (ros == null) return;\n\n        var twistMsg = new TwistMsg();\n        twistMsg.linear = new Vector3Msg(linearX, 0, 0);\n        twistMsg.angular = new Vector3Msg(0, 0, angularZ);\n\n        ros.Send(twistCommandTopic, twistMsg);\n    }\n\n    public void SendTrajectoryCommand(JointTrajectoryPointMsg[] trajectoryPoints)\n    {\n        if (ros == null) return;\n\n        var trajMsg = new JointTrajectoryMsg();\n        trajMsg.header.stamp = new TimeStamp(ROSConnection.GetNodeTime());\n        trajMsg.header.frame_id = "base_link";\n        trajMsg.joint_names = new string[] { "joint1", "joint2", "joint3", "joint4", "joint5", "joint6" };\n        trajMsg.points = trajectoryPoints;\n\n        ros.Send(trajectoryTopic, trajMsg);\n    }\n\n    void SendRobotCommands()\n    {\n        // This method is called at the specified rate\n        // Override with specific command logic as needed\n    }\n}\n\npublic class RobotStateSubscriber : MonoBehaviour\n{\n    [Header("ROS Topics")]\n    public string jointStateTopic = "joint_states";\n    public string odometryTopic = "odom";\n    public string tfTopic = "tf";\n\n    [Header("Visualization Settings")]\n    public GameObject robotModel;\n    public bool updateRobotPosition = true;\n    public bool updateJointPositions = true;\n\n    private ROSConnection ros;\n    private float[] currentJointPositions;\n    private Vector3 currentRobotPosition;\n    private Quaternion currentRobotRotation;\n\n    void Start()\n    {\n        ros = ROSConnection.instance;\n\n        // Subscribe to robot state topics\n        ros.Subscribe<JointStateMsg>(jointStateTopic, OnJointStateReceived);\n        ros.Subscribe<OdometryMsg>(odometryTopic, OnOdometryReceived);\n    }\n\n    void OnJointStateReceived(JointStateMsg jointState)\n    {\n        if (!updateJointPositions || robotModel == null) return;\n\n        // Update joint positions in the Unity model\n        if (jointState.position.Length > 0)\n        {\n            currentJointPositions = new float[jointState.position.Length];\n            for (int i = 0; i < jointState.position.Length; i++)\n            {\n                currentJointPositions[i] = (float)jointState.position[i];\n            }\n\n            // Update the robot model with new joint positions\n            UpdateRobotJoints();\n        }\n    }\n\n    void OnOdometryReceived(OdometryMsg odometry)\n    {\n        if (!updateRobotPosition || robotModel == null) return;\n\n        // Update robot position and orientation\n        currentRobotPosition = new Vector3(\n            (float)odometry.pose.pose.position.x,\n            (float)odometry.pose.pose.position.y,\n            (float)odometry.pose.pose.position.z\n        );\n\n        currentRobotRotation = new Quaternion(\n            (float)odometry.pose.pose.orientation.x,\n            (float)odometry.pose.pose.orientation.y,\n            (float)odometry.pose.pose.orientation.z,\n            (float)odometry.pose.pose.orientation.w\n        );\n\n        // Apply to robot model\n        robotModel.transform.position = currentRobotPosition;\n        robotModel.transform.rotation = currentRobotRotation;\n    }\n\n    void UpdateRobotJoints()\n    {\n        if (robotModel == null || currentJointPositions == null) return;\n\n        // Find all joint objects in the robot model\n        Transform[] allTransforms = robotModel.GetComponentsInChildren<Transform>();\n\n        for (int i = 0; i < currentJointPositions.Length && i < allTransforms.Length; i++)\n        {\n            // Update joint rotation based on received position\n            // This is a simplified example - real implementation would depend on joint types\n            allTransforms[i].Rotate(Vector3.up, currentJointPositions[i] * Mathf.Rad2Deg);\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"visualization-workflows",children:"Visualization Workflows"}),"\n",(0,i.jsx)(e.h3,{id:"real-time-data-visualization",children:"Real-time Data Visualization"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing System.Collections.Generic;\n\npublic class RealTimeDataVisualizer : MonoBehaviour\n{\n    [Header("Data Visualization")]\n    public GameObject trajectoryPrefab;\n    public GameObject sensorPointPrefab;\n    public GameObject velocityVectorPrefab;\n    public Material trajectoryMaterial;\n\n    [Header("Visualization Settings")]\n    public int maxTrajectoryPoints = 1000;\n    public float trajectoryUpdateInterval = 0.1f;\n    public Color trajectoryColor = Color.blue;\n    public bool showVelocityVectors = true;\n    public bool showSensorData = true;\n\n    private List<Vector3> trajectoryPoints;\n    private float lastTrajectoryUpdate;\n    private LineRenderer trajectoryRenderer;\n    private GameObject[] velocityVectors;\n    private GameObject[] sensorPoints;\n\n    void Start()\n    {\n        InitializeVisualization();\n    }\n\n    void InitializeVisualization()\n    {\n        trajectoryPoints = new List<Vector3>();\n\n        // Setup trajectory renderer\n        SetupTrajectoryRenderer();\n\n        // Initialize visualization objects\n        velocityVectors = new GameObject[0]; // Will be created as needed\n        sensorPoints = new GameObject[0]; // Will be created as needed\n    }\n\n    void SetupTrajectoryRenderer()\n    {\n        trajectoryRenderer = gameObject.AddComponent<LineRenderer>();\n        trajectoryRenderer.material = trajectoryMaterial ?? new Material(Shader.Find("Sprites/Default"));\n        trajectoryRenderer.startColor = trajectoryColor;\n        trajectoryRenderer.endColor = trajectoryColor;\n        trajectoryRenderer.startWidth = 0.05f;\n        trajectoryRenderer.endWidth = 0.02f;\n    }\n\n    public void AddTrajectoryPoint(Vector3 point)\n    {\n        if (Time.time - lastTrajectoryUpdate >= trajectoryUpdateInterval)\n        {\n            trajectoryPoints.Add(point);\n\n            // Limit trajectory length\n            if (trajectoryPoints.Count > maxTrajectoryPoints)\n            {\n                trajectoryPoints.RemoveAt(0);\n            }\n\n            // Update the line renderer\n            trajectoryRenderer.positionCount = trajectoryPoints.Count;\n            trajectoryRenderer.SetPositions(trajectoryPoints.ToArray());\n\n            lastTrajectoryUpdate = Time.time;\n        }\n    }\n\n    public void UpdateTrajectory(List<Vector3> newTrajectory)\n    {\n        trajectoryPoints.Clear();\n        trajectoryPoints.AddRange(newTrajectory);\n\n        // Limit trajectory length\n        if (trajectoryPoints.Count > maxTrajectoryPoints)\n        {\n            int removeCount = trajectoryPoints.Count - maxTrajectoryPoints;\n            trajectoryPoints.RemoveRange(0, removeCount);\n        }\n\n        // Update the line renderer\n        trajectoryRenderer.positionCount = trajectoryPoints.Count;\n        trajectoryRenderer.SetPositions(trajectoryPoints.ToArray());\n    }\n\n    public void VisualizeVelocity(Vector3 position, Vector3 velocity, float scale = 1.0f)\n    {\n        if (!showVelocityVectors) return;\n\n        // Create or reuse velocity vector object\n        GameObject velocityObj = GetOrCreateVelocityVector();\n\n        // Position and orient the velocity vector\n        velocityObj.transform.position = position;\n        velocityObj.transform.LookAt(position + velocity * scale);\n        velocityObj.transform.localScale = new Vector3(0.1f, 0.1f, velocity.magnitude * scale);\n    }\n\n    GameObject GetOrCreateVelocityVector()\n    {\n        // Find an inactive velocity vector or create a new one\n        foreach (GameObject obj in velocityVectors)\n        {\n            if (obj != null && !obj.activeInHierarchy)\n            {\n                obj.SetActive(true);\n                return obj;\n            }\n        }\n\n        // Create new velocity vector\n        GameObject newObj = Instantiate(velocityVectorPrefab, transform);\n        newObj.name = $"VelocityVector_{velocityVectors.Length}";\n\n        // Resize array and add new object\n        System.Array.Resize(ref velocityVectors, velocityVectors.Length + 1);\n        velocityVectors[velocityVectors.Length - 1] = newObj;\n\n        return newObj;\n    }\n\n    public void VisualizeSensorData(Vector3[] sensorPointsData)\n    {\n        if (!showSensorData) return;\n\n        // Clear existing sensor points\n        foreach (GameObject point in sensorPoints)\n        {\n            if (point != null)\n            {\n                point.SetActive(false);\n            }\n        }\n\n        // Create new sensor points\n        System.Array.Resize(ref sensorPoints, sensorPointsData.Length);\n\n        for (int i = 0; i < sensorPointsData.Length; i++)\n        {\n            GameObject pointObj = Instantiate(sensorPointPrefab, sensorPointsData[i], Quaternion.identity);\n            pointObj.transform.SetParent(transform);\n            sensorPoints[i] = pointObj;\n        }\n    }\n\n    public void ClearTrajectory()\n    {\n        trajectoryPoints.Clear();\n        trajectoryRenderer.positionCount = 0;\n    }\n\n    public void ClearAllVisualizations()\n    {\n        ClearTrajectory();\n\n        // Deactivate all visualization objects\n        foreach (GameObject obj in velocityVectors)\n        {\n            if (obj != null)\n            {\n                obj.SetActive(false);\n            }\n        }\n\n        foreach (GameObject obj in sensorPoints)\n        {\n            if (obj != null)\n            {\n                obj.SetActive(false);\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"performance-optimization-workflows",children:"Performance Optimization Workflows"}),"\n",(0,i.jsx)(e.h3,{id:"scene-optimization",children:"Scene Optimization"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing System.Collections.Generic;\n\npublic class SceneOptimizer : MonoBehaviour\n{\n    [Header("Optimization Settings")]\n    public bool enableOcclusionCulling = true;\n    public bool enableLOD = true;\n    public bool enableFrustumCulling = true;\n    public int targetFrameRate = 60;\n\n    [Header("Dynamic Batching")]\n    public bool enableDynamicBatching = true;\n    public int dynamicBatchThreshold = 300; // vertices\n\n    [Header("Quality Settings")]\n    public int qualityLevel = 2; // Medium\n    public bool useQualitySettings = true;\n\n    private List<Renderer> staticRenderers;\n    private List<Renderer> dynamicRenderers;\n    private Dictionary<Renderer, float> rendererDistances;\n\n    void Start()\n    {\n        InitializeOptimization();\n    }\n\n    void InitializeOptimization()\n    {\n        // Apply quality settings\n        if (useQualitySettings)\n        {\n            QualitySettings.SetQualityLevel(qualityLevel);\n            Application.targetFrameRate = targetFrameRate;\n        }\n\n        // Find all renderers in the scene\n        FindAllRenderers();\n\n        // Configure occlusion culling\n        ConfigureOcclusionCulling();\n\n        // Setup LOD groups where appropriate\n        SetupLODGroups();\n    }\n\n    void FindAllRenderers()\n    {\n        staticRenderers = new List<Renderer>();\n        dynamicRenderers = new List<Renderer>();\n        rendererDistances = new Dictionary<Renderer, float>();\n\n        Renderer[] allRenderers = FindObjectsOfType<Renderer>();\n\n        foreach (Renderer renderer in allRenderers)\n        {\n            // Classify renderers as static or dynamic\n            if (renderer.CompareTag("Static"))\n            {\n                staticRenderers.Add(renderer);\n            }\n            else\n            {\n                dynamicRenderers.Add(renderer);\n            }\n\n            rendererDistances[renderer] = float.MaxValue; // Initialize distance\n        }\n    }\n\n    void ConfigureOcclusionCulling()\n    {\n        if (enableOcclusionCulling)\n        {\n            // Enable occlusion culling in the scene\n            // This is typically done in the Lighting window in Unity Editor\n            // At runtime, we can adjust occlusion area settings\n            OcclusionArea[] occlusionAreas = FindObjectsOfType<OcclusionArea>();\n\n            foreach (OcclusionArea area in occlusionAreas)\n            {\n                area.center = area.transform.position;\n                area.size = area.transform.localScale;\n            }\n        }\n    }\n\n    void SetupLODGroups()\n    {\n        if (!enableLOD) return;\n\n        // Find robot models and setup LOD groups\n        GameObject[] robotModels = GameObject.FindGameObjectsWithTag("Robot");\n\n        foreach (GameObject robot in robotModels)\n        {\n            LODGroup lodGroup = robot.GetComponent<LODGroup>();\n            if (lodGroup == null)\n            {\n                lodGroup = robot.AddComponent<LODGroup>();\n            }\n\n            // Create LOD levels for robot model\n            SetupRobotLOD(robot, lodGroup);\n        }\n    }\n\n    void SetupRobotLOD(GameObject robot, LODGroup lodGroup)\n    {\n        // Create LOD levels for robot model\n        // This is a simplified example - real implementation would be more complex\n        Renderer[] renderers = robot.GetComponentsInChildren<Renderer>();\n\n        // Create LODs with different levels of detail\n        LOD[] lods = new LOD[3];\n\n        // LOD 0: High detail (full model)\n        Renderer[] lod0Renderers = renderers; // All renderers\n        lods[0] = new LOD(0.5f, lod0Renderers); // Visible at 50% screen height\n\n        // LOD 1: Medium detail (simplified model)\n        // For this example, we\'ll use the same renderers but could use simplified versions\n        lods[1] = new LOD(0.2f, lod0Renderers); // Visible at 20% screen height\n\n        // LOD 2: Low detail (bounding box or simple representation)\n        Renderer[] lod2Renderers = GetSimpleRepresentation(robot);\n        lods[2] = new LOD(0.05f, lod2Renderers); // Visible at 5% screen height\n\n        lodGroup.SetLODs(lods);\n        lodGroup.RecalculateBounds();\n    }\n\n    Renderer[] GetSimpleRepresentation(GameObject robot)\n    {\n        // Return simplified representation of the robot\n        // This could be a single mesh, bounding box, or simple primitive\n        GameObject simpleRep = GameObject.CreatePrimitive(PrimitiveType.Capsule);\n        simpleRep.transform.SetParent(robot.transform);\n        simpleRep.transform.localPosition = Vector3.zero;\n        simpleRep.transform.localRotation = Quaternion.identity;\n        simpleRep.transform.localScale = Vector3.one * 0.5f;\n\n        return new Renderer[] { simpleRep.GetComponent<Renderer>() };\n    }\n\n    void Update()\n    {\n        OptimizeBasedOnPerformance();\n    }\n\n    void OptimizeBasedOnPerformance()\n    {\n        // Adjust rendering quality based on current performance\n        float currentFrameRate = 1.0f / Time.unscaledDeltaTime;\n\n        if (currentFrameRate < targetFrameRate * 0.8f)\n        {\n            // Performance is poor, reduce quality\n            ReduceRenderingQuality();\n        }\n        else if (currentFrameRate > targetFrameRate * 0.95f)\n        {\n            // Performance is good, increase quality\n            IncreaseRenderingQuality();\n        }\n\n        // Update renderer visibility based on distance and frustum\n        UpdateRendererVisibility();\n    }\n\n    void ReduceRenderingQuality()\n    {\n        // Reduce quality settings to improve performance\n        QualitySettings.currentLevel = QualitySettings.GetQualityLevel() - 1;\n\n        // Reduce shadow quality\n        QualitySettings.shadows = ShadowQuality.HardOnly;\n        QualitySettings.shadowResolution = ShadowResolution.Low;\n\n        // Reduce anti-aliasing\n        QualitySettings.antiAliasing = 0;\n    }\n\n    void IncreaseRenderingQuality()\n    {\n        // Increase quality settings if performance allows\n        int currentLevel = QualitySettings.GetQualityLevel();\n        if (currentLevel < QualitySettings.names.Length - 1)\n        {\n            QualitySettings.currentLevel = currentLevel + 1;\n        }\n    }\n\n    void UpdateRendererVisibility()\n    {\n        // Update which renderers should be visible based on distance and frustum\n        Camera mainCamera = Camera.main;\n        if (mainCamera == null) return;\n\n        Vector3 cameraPos = mainCamera.transform.position;\n\n        // Update distances for all renderers\n        foreach (Renderer renderer in staticRenderers)\n        {\n            float distance = Vector3.Distance(cameraPos, renderer.bounds.center);\n            rendererDistances[renderer] = distance;\n\n            // Update visibility based on distance and frustum\n            if (enableFrustumCulling)\n            {\n                renderer.enabled = IsInFrustum(renderer, mainCamera) &&\n                                 distance < 100.0f; // Cull beyond 100 units\n            }\n        }\n    }\n\n    bool IsInFrustum(Renderer renderer, Camera camera)\n    {\n        // Check if renderer bounds are within camera frustum\n        return GeometryUtility.TestPlanesAABB(\n            GeometryUtility.CalculateFrustumPlanes(camera),\n            renderer.bounds\n        );\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"build-and-deployment-workflows",children:"Build and Deployment Workflows"}),"\n",(0,i.jsx)(e.h3,{id:"building-for-different-platforms",children:"Building for Different Platforms"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing UnityEditor;\nusing System.IO;\n\npublic class RoboticsBuildManager : MonoBehaviour\n{\n    [Header("Build Settings")]\n    public BuildTarget buildTarget = BuildTarget.StandaloneWindows64;\n    public string buildPath = "Builds/RoboticsVisualization";\n    public bool developmentBuild = false;\n    public bool autoRunBuild = false;\n\n    [Header("Platform Specific")]\n    public bool enableXR = false;\n    public bool enableMobileOptimizations = false;\n\n    [MenuItem("Robotics/Build Visualization")]\n    public static void BuildVisualization()\n    {\n        RoboticsBuildManager buildManager = FindObjectOfType<RoboticsBuildManager>();\n        if (buildManager != null)\n        {\n            buildManager.PerformBuild();\n        }\n        else\n        {\n            Debug.LogError("RoboticsBuildManager not found in scene!");\n        }\n    }\n\n    public void PerformBuild()\n    {\n        // Configure build settings\n        PlayerSettings.companyName = "RoboticsLab";\n        PlayerSettings.productName = "Robotics Visualization";\n        PlayerSettings.bundleVersion = "1.0.0";\n\n        // Set up scenes to include in build\n        string[] scenes = GetBuildScenes();\n\n        // Configure platform-specific settings\n        ConfigurePlatformSettings();\n\n        // Perform the build\n        BuildPipeline.BuildPlayer(scenes, GetBuildPath(), buildTarget,\n                                developmentBuild ? BuildOptions.Development : BuildOptions.None);\n\n        Debug.Log($"Build completed to: {GetBuildPath()}");\n\n        if (autoRunBuild)\n        {\n            RunBuild();\n        }\n    }\n\n    string[] GetBuildScenes()\n    {\n        // Get all enabled scenes in build settings\n        System.Collections.Generic.List<string> scenePaths =\n            new System.Collections.Generic.List<string>();\n\n        foreach (EditorBuildSettingsScene scene in EditorBuildSettings.scenes)\n        {\n            if (scene.enabled)\n            {\n                scenePaths.Add(scene.path);\n            }\n        }\n\n        return scenePaths.ToArray();\n    }\n\n    string GetBuildPath()\n    {\n        // Ensure build path exists\n        string fullPath = Path.Combine(Application.dataPath, "..", buildPath);\n        Directory.CreateDirectory(fullPath);\n\n        return fullPath;\n    }\n\n    void ConfigurePlatformSettings()\n    {\n        switch (buildTarget)\n        {\n            case BuildTarget.StandaloneWindows64:\n                ConfigureWindowsBuild();\n                break;\n            case BuildTarget.StandaloneLinux64:\n                ConfigureLinuxBuild();\n                break;\n            case BuildTarget.Android:\n                ConfigureAndroidBuild();\n                break;\n            case BuildTarget.iOS:\n                ConfigureIOSBuild();\n                break;\n            default:\n                Debug.LogWarning($"Build target {buildTarget} not specifically configured");\n                break;\n        }\n    }\n\n    void ConfigureWindowsBuild()\n    {\n        PlayerSettings.SetScriptingBackend(BuildTargetGroup.Standalone, ScriptingImplementation.IL2CPP);\n        PlayerSettings.Standalone.allowAudioAutoplayInWebBrowser = true;\n\n        if (enableXR)\n        {\n            // Configure XR settings for Windows\n            PlayerSettings.virtualRealitySupported = true;\n        }\n    }\n\n    void ConfigureLinuxBuild()\n    {\n        PlayerSettings.SetScriptingBackend(BuildTargetGroup.Standalone, ScriptingImplementation.IL2CPP);\n\n        if (enableXR)\n        {\n            PlayerSettings.virtualRealitySupported = true;\n        }\n    }\n\n    void ConfigureAndroidBuild()\n    {\n        PlayerSettings.SetScriptingBackend(BuildTargetGroup.Android, ScriptingImplementation.IL2CPP);\n        PlayerSettings.Android.minSdkVersion = AndroidSdkVersions.AndroidApiLevel24; // Android 7.0\n\n        if (enableMobileOptimizations)\n        {\n            // Optimize for mobile\n            QualitySettings.SetQualityLevel(0); // Lowest quality\n            PlayerSettings.stripEngineCode = true;\n        }\n\n        if (enableXR)\n        {\n            PlayerSettings.virtualRealitySupported = true;\n            PlayerSettings.Android.targetArchitectures = AndroidArchitecture.ARM64;\n        }\n    }\n\n    void ConfigureIOSBuild()\n    {\n        PlayerSettings.SetScriptingBackend(BuildTargetGroup.iOS, ScriptingImplementation.IL2CPP);\n\n        if (enableMobileOptimizations)\n        {\n            QualitySettings.SetQualityLevel(0); // Lowest quality\n            PlayerSettings.stripEngineCode = true;\n        }\n\n        if (enableXR)\n        {\n            PlayerSettings.virtualRealitySupported = true;\n        }\n    }\n\n    void RunBuild()\n    {\n        string buildPath = GetBuildPath();\n        string executablePath = "";\n\n        switch (buildTarget)\n        {\n            case BuildTarget.StandaloneWindows64:\n                executablePath = Path.Combine(buildPath, PlayerSettings.productName + ".exe");\n                break;\n            case BuildTarget.StandaloneLinux64:\n                executablePath = Path.Combine(buildPath, PlayerSettings.productName);\n                break;\n        }\n\n        if (!string.IsNullOrEmpty(executablePath) && File.Exists(executablePath))\n        {\n            System.Diagnostics.Process.Start(executablePath);\n        }\n        else\n        {\n            Debug.LogWarning("Could not run build - executable not found or not supported platform");\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"testing-and-validation-workflows",children:"Testing and Validation Workflows"}),"\n",(0,i.jsx)(e.h3,{id:"automated-testing-for-robotics-visualization",children:"Automated Testing for Robotics Visualization"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing UnityEngine.TestTools;\nusing NUnit.Framework;\nusing System.Collections;\n\npublic class RoboticsVisualizationTests\n{\n    [Test]\n    public void TestROSConnectionInitialization()\n    {\n        // Test that ROS connection initializes properly\n        GameObject testObject = new GameObject("TestROSConnection");\n        ROSConnectionManager connectionManager = testObject.AddComponent<ROSConnectionManager>();\n\n        // Verify default values\n        Assert.IsFalse(connectionManager.isConnected);\n        Assert.AreEqual("127.0.0.1", connectionManager.rosIP);\n        Assert.AreEqual(10000, connectionManager.rosPort);\n\n        // Clean up\n        Object.DestroyImmediate(testObject);\n    }\n\n    [Test]\n    public void TestTrajectoryVisualization()\n    {\n        // Test trajectory visualization functionality\n        GameObject testObject = new GameObject("TestTrajectory");\n        RealTimeDataVisualizer visualizer = testObject.AddComponent<RealTimeDataVisualizer>();\n\n        // Initialize visualization\n        visualizer.Start();\n\n        // Add some trajectory points\n        Vector3 point1 = new Vector3(0, 0, 0);\n        Vector3 point2 = new Vector3(1, 0, 0);\n        Vector3 point3 = new Vector3(2, 0, 0);\n\n        visualizer.AddTrajectoryPoint(point1);\n        visualizer.AddTrajectoryPoint(point2);\n        visualizer.AddTrajectoryPoint(point3);\n\n        // Verify trajectory was added\n        // Note: This is a simplified test - in reality you\'d need to check the LineRenderer\n        Assert.IsTrue(true); // Placeholder - actual implementation would check LineRenderer positions\n\n        // Clean up\n        Object.DestroyImmediate(testObject);\n    }\n\n    [Test]\n    public void TestRobotModelOptimizer()\n    {\n        // Test robot model optimization\n        GameObject robot = new GameObject("TestRobot");\n        GameObject link = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        link.transform.SetParent(robot.transform);\n\n        RobotModelOptimizer optimizer = robot.AddComponent<RobotModelOptimizer>();\n\n        // Run optimization\n        optimizer.OptimizeRobotModel();\n\n        // Verify optimization ran without errors\n        Assert.IsTrue(true); // Placeholder for actual optimization verification\n\n        // Clean up\n        Object.DestroyImmediate(robot);\n    }\n}\n\n// Performance test for visualization\npublic class RoboticsPerformanceTests\n{\n    [UnityTest]\n    public IEnumerator TestVisualizationPerformance()\n    {\n        // Create a visualization with many objects\n        GameObject visualizerObject = new GameObject("PerformanceTestVisualizer");\n        RealTimeDataVisualizer visualizer = visualizerObject.AddComponent<RealTimeDataVisualizer>();\n        visualizer.Start();\n\n        // Add many trajectory points to test performance\n        for (int i = 0; i < 1000; i++)\n        {\n            Vector3 point = new Vector3(i * 0.01f, 0, 0);\n            visualizer.AddTrajectoryPoint(point);\n\n            // Yield occasionally to prevent editor lockup\n            if (i % 100 == 0)\n            {\n                yield return null;\n            }\n        }\n\n        // Verify that frame rate remains acceptable\n        float frameTime = Time.deltaTime;\n        Assert.Less(frameTime, 1.0f/30.0f); // Should maintain at least 30 FPS\n\n        // Clean up\n        Object.DestroyImmediate(visualizerObject);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"Unity workflows for robotics visualization provide a structured approach to developing, optimizing, and deploying applications that bridge the gap between complex robotics data and intuitive human interfaces. By following these workflows, developers can create efficient, maintainable, and high-performance visualization systems for robotics applications."})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>s});var i=t(6540);const o={},r=i.createContext(o);function a(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);