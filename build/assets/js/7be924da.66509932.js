"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[7741],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},8995:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>_,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=t(4848),a=t(8453);const i={title:"Chapter 4 - Services and Actions in ROS 2"},r="Services and Actions in ROS 2",o={id:"ros2-communication/services-actions",title:"Chapter 4 - Services and Actions in ROS 2",description:"Introduction",source:"@site/docs/physical-ai/ros2-communication/03-services-actions.mdx",sourceDirName:"ros2-communication",slug:"/ros2-communication/services-actions",permalink:"/ros2-communication/services-actions",draft:!1,unlisted:!1,editUrl:"https://github.com/fuzailpalook/new-book/tree/main/docs/physical-ai/ros2-communication/03-services-actions.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Chapter 4 - Services and Actions in ROS 2"}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Service Implementation",id:"service-implementation",level:2},{value:"Basic Service Architecture",id:"basic-service-architecture",level:3},{value:"Robust Service Architecture",id:"robust-service-architecture",level:3},{value:"Service Chaining and Coordination",id:"service-chaining-and-coordination",level:3},{value:"Action Implementation",id:"action-implementation",level:2},{value:"Basic Action Server",id:"basic-action-server",level:3},{value:"Advanced Action Server with Complex State Management",id:"advanced-action-server-with-complex-state-management",level:3},{value:"Advanced Action Client with Comprehensive Features",id:"advanced-action-client-with-comprehensive-features",level:3},{value:"Communication Pattern Selection",id:"communication-pattern-selection",level:2},{value:"When to Use Each Pattern",id:"when-to-use-each-pattern",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Multi-Pattern Robot Controller",id:"multi-pattern-robot-controller",level:3},{value:"Performance Optimization and Best Practices",id:"performance-optimization-and-best-practices",level:2},{value:"Service Optimization",id:"service-optimization",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"services-and-actions-in-ros-2",children:"Services and Actions in ROS 2"}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Services and actions represent two critical communication patterns in ROS 2 that complement topics. Services provide synchronous request/response communication for immediate computations, while actions handle goal-oriented, long-running tasks with feedback and cancellation capabilities."}),"\n",(0,s.jsx)(n.h2,{id:"service-implementation",children:"Service Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"basic-service-architecture",children:"Basic Service Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Services provide synchronous request/response communication for immediate computations and operations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\nfrom example_interfaces.srv import AddTwoInts, SetBool\nfrom std_srvs.srv import Trigger, Empty\nfrom sensor_msgs.srv import SetCameraInfo\nimport time\nimport threading\nfrom rclpy.task import Future\n\nclass BasicServiceNode(Node):\n    def __init__(self):\n        super().__init__('basic_service_node')\n\n        # Multiple service servers\n        self.add_service = self.create_service(\n            AddTwoInts, 'add_two_ints', self.add_callback\n        )\n\n        self.toggle_service = self.create_service(\n            SetBool, 'toggle_device', self.toggle_callback\n        )\n\n        self.trigger_service = self.create_service(\n            Trigger, 'trigger_operation', self.trigger_callback\n        )\n\n    def add_callback(self, request, response):\n        \"\"\"Basic addition service.\"\"\"\n        try:\n            result = request.a + request.b\n            response.sum = result\n            response.success = True\n            response.message = f'Successfully calculated {request.a} + {request.b} = {result}'\n            self.get_logger().info(f'Add service: {request.a} + {request.b} = {result}')\n        except Exception as e:\n            self.get_logger().error(f'Add service error: {e}')\n            response.success = False\n            response.message = f'Calculation error: {str(e)}'\n\n        return response\n\n    def toggle_callback(self, request, response):\n        \"\"\"Basic toggle service.\"\"\"\n        try:\n            device_state = request.data\n            self.get_logger().info(f'Toggling device to state: {device_state}')\n\n            # Simulate hardware operation time\n            time.sleep(0.1)\n\n            response.success = True\n            response.message = f'Device toggled to {\"ON\" if device_state else \"OFF\"}'\n\n        except Exception as e:\n            self.get_logger().error(f'Toggle service error: {e}')\n            response.success = False\n            response.message = f'Toggle operation failed: {str(e)}'\n\n        return response\n\n    def trigger_callback(self, request, response):\n        \"\"\"Basic trigger service.\"\"\"\n        try:\n            # Perform operation\n            success = self.perform_operation()\n\n            response.success = success\n            response.message = 'Operation completed successfully' if success else 'Operation failed'\n\n        except Exception as e:\n            self.get_logger().error(f'Trigger service error: {e}')\n            response.success = False\n            response.message = f'Trigger operation failed: {str(e)}'\n\n        return response\n\n    def perform_operation(self):\n        \"\"\"Perform a simple operation.\"\"\"\n        # Simulate operation\n        time.sleep(0.5)\n        return True\n"})}),"\n",(0,s.jsx)(n.h3,{id:"robust-service-architecture",children:"Robust Service Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Advanced service implementations with comprehensive error handling and monitoring:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class RobustServiceNode(Node):\n    def __init__(self):\n        super().__init__('robust_service_node')\n\n        # Multiple service servers\n        self.add_service = self.create_service(\n            AddTwoInts, 'robust_add_two_ints', self.robust_add_callback\n        )\n\n        self.toggle_service = self.create_service(\n            SetBool, 'toggle_device', self.toggle_callback\n        )\n\n        self.trigger_service = self.create_service(\n            Trigger, 'trigger_operation', self.trigger_callback\n        )\n\n        # Service clients for internal coordination\n        self.dependency_client = self.create_client(\n            Trigger, 'dependency_service'\n        )\n\n        # Statistics for monitoring\n        self.service_stats = {\n            'add': {'requests': 0, 'errors': 0, 'avg_time': 0.0},\n            'toggle': {'requests': 0, 'errors': 0, 'avg_time': 0.0},\n            'trigger': {'requests': 0, 'errors': 0, 'avg_time': 0.0}\n        }\n\n        # Thread-safe statistics\n        self.stats_lock = threading.Lock()\n\n    def robust_add_callback(self, request, response):\n        \"\"\"Robust addition service with error handling.\"\"\"\n        start_time = time.time()\n        self._update_stats('add', 'requests')\n\n        try:\n            # Validate inputs\n            if not self._validate_numbers(request.a, request.b):\n                self.get_logger().error('Invalid numbers provided to add service')\n                response.success = False\n                response.message = 'Invalid input numbers'\n                self._update_stats('add', 'errors')\n                return response\n\n            # Perform calculation\n            result = self._safe_add(request.a, request.b)\n            response.sum = result\n            response.success = True\n            response.message = f'Successfully calculated {request.a} + {request.b} = {result}'\n\n            # Log successful operation\n            processing_time = time.time() - start_time\n            self._update_avg_time('add', processing_time)\n            self.get_logger().info(\n                f'Add service: {request.a} + {request.b} = {result} '\n                f'(time: {processing_time:.4f}s)'\n            )\n\n        except Exception as e:\n            self.get_logger().error(f'Add service error: {e}')\n            response.success = False\n            response.message = f'Calculation error: {str(e)}'\n            self._update_stats('add', 'errors')\n\n        return response\n\n    def toggle_callback(self, request, response):\n        \"\"\"Toggle service with state management.\"\"\"\n        start_time = time.time()\n        self._update_stats('toggle', 'requests')\n\n        try:\n            # Simulate device toggle operation\n            device_state = request.data\n            self.get_logger().info(f'Toggling device to state: {device_state}')\n\n            # Simulate hardware operation time\n            time.sleep(0.1)\n\n            response.success = True\n            response.message = f'Device toggled to {\"ON\" if device_state else \"OFF\"}'\n\n            processing_time = time.time() - start_time\n            self._update_avg_time('toggle', processing_time)\n\n        except Exception as e:\n            self.get_logger().error(f'Toggle service error: {e}')\n            response.success = False\n            response.message = f'Toggle operation failed: {str(e)}'\n            self._update_stats('toggle', 'errors')\n\n        return response\n\n    def trigger_callback(self, request, response):\n        \"\"\"Trigger service with complex operations.\"\"\"\n        start_time = time.time()\n        self._update_stats('trigger', 'requests')\n\n        try:\n            # Check dependencies\n            if not self._check_dependencies():\n                response.success = False\n                response.message = 'Required dependencies not available'\n                self._update_stats('trigger', 'errors')\n                return response\n\n            # Perform complex operation\n            success = self._perform_complex_operation()\n\n            response.success = success\n            response.message = 'Operation completed successfully' if success else 'Operation failed'\n\n            processing_time = time.time() - start_time\n            self._update_avg_time('trigger', processing_time)\n\n        except Exception as e:\n            self.get_logger().error(f'Trigger service error: {e}')\n            response.success = False\n            response.message = f'Trigger operation failed: {str(e)}'\n            self._update_stats('trigger', 'errors')\n\n        return response\n\n    def _validate_numbers(self, a, b):\n        \"\"\"Validate number inputs.\"\"\"\n        if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n            return False\n        if abs(a) > 1e10 or abs(b) > 1e10:\n            self.get_logger().warn('Very large numbers detected')\n        return True\n\n    def _safe_add(self, a, b):\n        \"\"\"Perform safe addition with overflow protection.\"\"\"\n        try:\n            result = a + b\n            if not np.isfinite(result):\n                raise ValueError('Result is not finite')\n            return result\n        except OverflowError:\n            raise ValueError('Addition resulted in overflow')\n\n    def _check_dependencies(self):\n        \"\"\"Check if required dependencies are available.\"\"\"\n        # Simulate dependency check\n        return True\n\n    def _perform_complex_operation(self):\n        \"\"\"Perform a complex operation.\"\"\"\n        # Simulate complex operation\n        time.sleep(0.5)\n        return True\n\n    def _update_stats(self, service_name, stat_type):\n        \"\"\"Thread-safe statistics update.\"\"\"\n        with self.stats_lock:\n            if stat_type == 'requests':\n                self.service_stats[service_name]['requests'] += 1\n            elif stat_type == 'errors':\n                self.service_stats[service_name]['errors'] += 1\n\n    def _update_avg_time(self, service_name, processing_time):\n        \"\"\"Update average processing time.\"\"\"\n        with self.stats_lock:\n            stats = self.service_stats[service_name]\n            current_avg = stats['avg_time']\n            count = stats['requests']\n            stats['avg_time'] = ((current_avg * (count - 1)) + processing_time) / count\n"})}),"\n",(0,s.jsx)(n.h3,{id:"service-chaining-and-coordination",children:"Service Chaining and Coordination"}),"\n",(0,s.jsx)(n.p,{children:"Complex robotic systems often require services that coordinate with other services:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import qos_profile_services_default\nfrom example_interfaces.srv import AddTwoInts, SetBool\nfrom std_srvs.srv import Trigger\nimport asyncio\n\nclass ServiceCoordinatorNode(Node):\n    def __init__(self):\n        super().__init__('service_coordinator')\n\n        # Main service that coordinates other services\n        self.complex_calc_service = self.create_service(\n            AddTwoInts, 'complex_calculation', self.complex_calc_callback\n        )\n\n        # Client for dependency services\n        self.add_client = self.create_client(AddTwoInts, 'robust_add_two_ints')\n        self.multiply_client = self.create_client(AddTwoInts, 'multiply_service')\n        self.validation_client = self.create_client(SetBool, 'validate_inputs')\n\n        # Wait for services to be available\n        self.get_logger().info('Waiting for dependency services...')\n        while not self.add_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Add service not available, waiting...')\n        while not self.multiply_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Multiply service not available, waiting...')\n        while not self.validation_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Validation service not available, waiting...')\n\n    def complex_calc_callback(self, request, response):\n        \"\"\"Complex calculation that chains multiple services.\"\"\"\n        try:\n            # First, validate inputs\n            validation_request = SetBool.Request()\n            validation_request.data = True  # Simplified validation\n            validation_future = self.validation_client.call_async(validation_request)\n\n            # Wait for validation result\n            rclpy.spin_until_future_complete(self, validation_future)\n            validation_result = validation_future.result()\n\n            if not validation_result.success:\n                response.success = False\n                response.message = validation_result.message\n                return response\n\n            # Perform addition using dependency service\n            add_request = AddTwoInts.Request()\n            add_request.a = request.a\n            add_request.b = request.b\n            add_future = self.add_client.call_async(add_request)\n\n            # Wait for addition result\n            rclpy.spin_until_future_complete(self, add_future)\n            add_result = add_future.result()\n\n            if not add_result.sum:\n                response.success = False\n                response.message = 'Addition service failed'\n                return response\n\n            # Multiply result by a factor (simplified example)\n            multiply_request = AddTwoInts.Request()\n            multiply_request.a = add_result.sum\n            multiply_request.b = 2  # Factor of 2\n            multiply_future = self.multiply_client.call_async(multiply_request)\n\n            # Wait for multiplication result\n            rclpy.spin_until_future_complete(self, multiply_future)\n            multiply_result = multiply_future.result()\n\n            response.sum = multiply_result.sum\n            response.success = True\n            response.message = f'Complex calculation completed: ({request.a} + {request.b}) * 2 = {multiply_result.sum}'\n\n        except Exception as e:\n            self.get_logger().error(f'Complex calculation error: {e}')\n            response.success = False\n            response.message = f'Complex calculation failed: {str(e)}'\n\n        return response\n\nclass ServiceLoadBalancerNode(Node):\n    def __init__(self):\n        super().__init__('service_load_balancer')\n\n        # Main service interface\n        self.load_balanced_service = self.create_service(\n            AddTwoInts, 'load_balanced_calc', self.load_balanced_callback\n        )\n\n        # Multiple backend services\n        self.backend_clients = [\n            self.create_client(AddTwoInts, 'backend_calc_1'),\n            self.create_client(AddTwoInts, 'backend_calc_2'),\n            self.create_client(AddTwoInts, 'backend_calc_3')\n        ]\n\n        # Load balancing state\n        self.current_backend = 0\n        self.backend_stats = [0] * len(self.backend_clients)  # Request counts\n\n        # Wait for all backends\n        for i, client in enumerate(self.backend_clients):\n            while not client.wait_for_service(timeout_sec=1.0):\n                self.get_logger().info(f'Backend {i+1} not available, waiting...')\n\n    def load_balanced_callback(self, request, response):\n        \"\"\"Distribute requests across multiple backend services.\"\"\"\n        # Select backend using round-robin\n        selected_client = self.backend_clients[self.current_backend]\n        self.backend_stats[self.current_backend] += 1\n\n        # Update for next request\n        self.current_backend = (self.current_backend + 1) % len(self.backend_clients)\n\n        try:\n            # Call backend service\n            backend_request = AddTwoInts.Request()\n            backend_request.a = request.a\n            backend_request.b = request.b\n\n            backend_future = selected_client.call_async(backend_request)\n            rclpy.spin_until_future_complete(self, backend_future)\n            backend_result = backend_future.result()\n\n            response.sum = backend_result.sum\n            response.success = backend_result.sum is not None\n            response.message = f'Processed by backend {self.current_backend}'\n\n        except Exception as e:\n            self.get_logger().error(f'Load balancer error: {e}')\n            response.success = False\n            response.message = f'Load balancing failed: {str(e)}'\n\n        return response\n"})}),"\n",(0,s.jsx)(n.h2,{id:"action-implementation",children:"Action Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"basic-action-server",children:"Basic Action Server"}),"\n",(0,s.jsx)(n.p,{children:"Actions provide goal-oriented communication with feedback and cancellation for long-running tasks:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom example_interfaces.action import Fibonacci\nfrom geometry_msgs.action import NavigateToPose\nfrom control_msgs.action import FollowJointTrajectory\nimport threading\nimport time\nimport math\nfrom collections import deque\n\nclass BasicActionServer(Node):\n    def __init__(self):\n        super().__init__(\'basic_action_server\')\n\n        # Use reentrant callback group for concurrent access\n        callback_group = ReentrantCallbackGroup()\n\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            \'fibonacci_action\',\n            self.execute_callback,\n            goal_callback=self.goal_callback,\n            handle_accepted_callback=self.handle_accepted_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=callback_group\n        )\n\n        # State tracking\n        self.active_goals = {}\n\n    def goal_callback(self, goal_request):\n        """Validate and accept/reject goals."""\n        # Validate goal\n        if goal_request.order < 0 or goal_request.order > 100:  # Reasonable limit\n            self.get_logger().warn(f\'Goal order out of range: {goal_request.order}\')\n            return GoalResponse.REJECT\n        else:\n            self.get_logger().info(f\'Accepting goal with order: {goal_request.order}\')\n            return GoalResponse.ACCEPT\n\n    def handle_accepted_callback(self, goal_handle):\n        """Handle accepted goal by starting execution."""\n        self.get_logger().info(\'Goal accepted, starting execution\')\n\n        # Store goal in active goals\n        goal_id = goal_handle.goal_id.uuid\n        self.active_goals[goal_id] = goal_handle\n\n        # Start execution in separate thread\n        thread = threading.Thread(target=self.execute_goal, args=(goal_handle,))\n        thread.start()\n\n    def cancel_callback(self, goal_handle):\n        """Handle cancel request."""\n        self.get_logger().info(\'Goal cancellation requested\')\n        return CancelResponse.ACCEPT\n\n    def execute_goal(self, goal_handle):\n        """Execute goal in separate thread."""\n        self.get_logger().info(\'Starting goal execution...\')\n\n        # Create feedback and result messages\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        result_msg = Fibonacci.Result()\n\n        try:\n            # Generate Fibonacci sequence\n            for i in range(1, goal_handle.request.order):\n                # Check for cancellation\n                if goal_handle.is_cancel_requested:\n                    self.get_logger().info(\'Goal cancelled\')\n                    goal_handle.canceled()\n                    result_msg.sequence = feedback_msg.sequence\n\n                    # Remove from active goals\n                    goal_id = goal_handle.goal_id.uuid\n                    if goal_id in self.active_goals:\n                        del self.active_goals[goal_id]\n                    return\n\n                # Simulate processing time\n                time.sleep(0.1)\n\n                # Calculate next Fibonacci number\n                next_fib = feedback_msg.sequence[i] + feedback_msg.sequence[i-1]\n                feedback_msg.sequence.append(next_fib)\n\n                # Publish feedback\n                goal_handle.publish_feedback(feedback_msg)\n\n                self.get_logger().info(f\'Published feedback: {feedback_msg.sequence}\')\n\n            # Complete the goal successfully\n            goal_handle.succeed()\n            result_msg.sequence = feedback_msg.sequence\n            self.get_logger().info(f\'Goal succeeded with result: {result_msg.sequence}\')\n\n        except Exception as e:\n            self.get_logger().error(f\'Error during goal execution: {e}\')\n            goal_handle.abort()\n            result_msg.sequence = feedback_msg.sequence\n\n        finally:\n            # Remove from active goals\n            goal_id = goal_handle.goal_id.uuid\n            if goal_id in self.active_goals:\n                del self.active_goals[goal_id]\n\n            # Publish final result\n            goal_handle.publish_result(result_msg)\n\n    def execute_callback(self, goal_handle):\n        """Execute callback (placeholder - actual execution in separate thread)."""\n        # This method is required by the action server interface\n        # Actual execution happens in execute_goal in separate thread\n        pass\n'})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-action-server-with-complex-state-management",children:"Advanced Action Server with Complex State Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class AdvancedNavigationActionServer(Node):\n    def __init__(self):\n        super().__init__('advanced_navigation_action_server')\n\n        # Use reentrant callback group for concurrent access\n        callback_group = ReentrantCallbackGroup()\n\n        self._action_server = ActionServer(\n            self,\n            NavigateToPose,\n            'navigate_to_pose',\n            self.execute_callback,\n            goal_callback=self.goal_callback,\n            handle_accepted_callback=self.handle_accepted_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=callback_group\n        )\n\n        # State tracking\n        self.current_pose = {'x': 0.0, 'y': 0.0, 'theta': 0.0}\n        self.active_goals = {}\n        self.navigation_history = deque(maxlen=100)\n\n        # Publishers for navigation state\n        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)\n        self.pose_pub = self.create_publisher(PoseStamped, 'current_pose', 10)\n\n        # Timer for periodic state updates\n        self.state_timer = self.create_timer(0.1, self.update_navigation_state)\n\n    def goal_callback(self, goal_request):\n        \"\"\"Validate and accept/reject navigation goals.\"\"\"\n        target_pose = goal_request.pose.pose\n        current_pose = self.current_pose\n\n        # Calculate distance to goal\n        distance = math.sqrt(\n            (target_pose.position.x - current_pose['x'])**2 +\n            (target_pose.position.y - current_pose['y'])**2\n        )\n\n        # Validate goal\n        if distance > 100.0:  # Max navigation distance\n            self.get_logger().warn(f'Navigation goal too far: {distance:.2f}m')\n            return GoalResponse.REJECT\n        elif distance < 0.1:  # Already at goal\n            self.get_logger().info('Already at navigation goal')\n            return GoalResponse.REJECT\n        else:\n            self.get_logger().info(f'Accepting navigation goal, distance: {distance:.2f}m')\n            return GoalResponse.ACCEPT\n\n    def handle_accepted_callback(self, goal_handle):\n        \"\"\"Handle accepted goal by starting execution.\"\"\"\n        self.get_logger().info('Navigation goal accepted, starting execution')\n\n        # Store goal in active goals\n        goal_id = goal_handle.goal_id.uuid\n        self.active_goals[goal_id] = goal_handle\n\n        # Start execution in separate thread\n        thread = threading.Thread(target=self.execute_navigation, args=(goal_handle,))\n        thread.start()\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Handle cancel request.\"\"\"\n        self.get_logger().info('Navigation goal cancellation requested')\n        return CancelResponse.ACCEPT\n\n    def execute_navigation(self, goal_handle):\n        \"\"\"Execute navigation in separate thread.\"\"\"\n        self.get_logger().info('Starting navigation execution...')\n\n        # Extract goal pose\n        target_pose = goal_handle.request.pose.pose\n        target_x = target_pose.position.x\n        target_y = target_pose.position.y\n\n        # Navigation parameters\n        linear_speed = 0.5\n        angular_speed = 0.5\n        tolerance = 0.1  # Distance tolerance in meters\n\n        # Navigation loop\n        while rclpy.ok():\n            # Check for cancellation\n            if goal_handle.is_cancel_requested:\n                self.get_logger().info('Navigation goal cancelled')\n                goal_handle.canceled()\n\n                # Stop robot\n                stop_msg = Twist()\n                self.cmd_vel_pub.publish(stop_msg)\n\n                # Remove from active goals\n                goal_id = goal_handle.goal_id.uuid\n                if goal_id in self.active_goals:\n                    del self.active_goals[goal_id]\n                return\n\n            # Calculate distance to goal\n            distance = math.sqrt(\n                (target_x - self.current_pose['x'])**2 +\n                (target_y - self.current_pose['y'])**2\n            )\n\n            # Check if reached goal\n            if distance <= tolerance:\n                self.get_logger().info('Navigation goal reached')\n\n                # Stop robot\n                stop_msg = Twist()\n                self.cmd_vel_pub.publish(stop_msg)\n\n                # Create result\n                result = NavigateToPose.Result()\n                result.result_code = 1  # Success\n\n                goal_handle.succeed()\n                goal_handle.publish_result(result)\n\n                # Add to history\n                history_entry = {\n                    'start': (self.current_pose['x'], self.current_pose['y']),\n                    'goal': (target_x, target_y),\n                    'distance': distance,\n                    'time': time.time()\n                }\n                self.navigation_history.append(history_entry)\n\n                # Remove from active goals\n                goal_id = goal_handle.goal_id.uuid\n                if goal_id in self.active_goals:\n                    del self.active_goals[goal_id]\n                return\n\n            # Calculate control commands\n            cmd_vel = self.calculate_navigation_command(target_x, target_y, linear_speed, angular_speed)\n\n            # Publish command\n            self.cmd_vel_pub.publish(cmd_vel)\n\n            # Publish feedback\n            feedback = NavigateToPose.Feedback()\n            feedback.current_pose.pose.position.x = self.current_pose['x']\n            feedback.current_pose.pose.position.y = self.current_pose['y']\n            feedback.distance_remaining = distance\n            goal_handle.publish_feedback(feedback)\n\n            # Log progress\n            self.get_logger().info(f'Navigating: {distance:.2f}m remaining')\n\n            # Sleep to control loop rate\n            time.sleep(0.1)\n\n    def calculate_navigation_command(self, target_x, target_y, linear_speed, angular_speed):\n        \"\"\"Calculate navigation commands.\"\"\"\n        # Calculate desired angle\n        desired_angle = math.atan2(\n            target_y - self.current_pose['y'],\n            target_x - self.current_pose['x']\n        )\n\n        # Calculate angle difference\n        angle_diff = desired_angle - self.current_pose['theta']\n\n        # Normalize angle\n        while angle_diff > math.pi:\n            angle_diff -= 2 * math.pi\n        while angle_diff < -math.pi:\n            angle_diff += 2 * math.pi\n\n        # Create command message\n        cmd_vel = Twist()\n        cmd_vel.linear.x = min(linear_speed, linear_speed * (abs(angle_diff) < 0.1))\n        cmd_vel.angular.z = angular_speed * angle_diff\n\n        return cmd_vel\n\n    def update_navigation_state(self):\n        \"\"\"Update navigation state periodically.\"\"\"\n        # Simulate state updates (in real system, this would come from localization)\n        self.current_pose['x'] += 0.01  # Simulated movement\n        self.current_pose['y'] += 0.005  # Simulated movement\n\n        # Publish current pose\n        pose_msg = PoseStamped()\n        pose_msg.header.stamp = self.get_clock().now().to_msg()\n        pose_msg.header.frame_id = 'map'\n        pose_msg.pose.position.x = self.current_pose['x']\n        pose_msg.pose.position.y = self.current_pose['y']\n        pose_msg.pose.orientation.w = 1.0  # Simplified orientation\n\n        self.pose_pub.publish(pose_msg)\n\n    def execute_callback(self, goal_handle):\n        \"\"\"Execute callback (placeholder - actual execution in separate thread).\"\"\"\n        # This method is required by the action server interface\n        # Actual execution happens in execute_navigation in separate thread\n        pass\n"})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-action-client-with-comprehensive-features",children:"Advanced Action Client with Comprehensive Features"}),"\n",(0,s.jsx)(n.p,{children:"Action clients need to handle various scenarios including timeouts, feedback, and result processing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from rclpy.action import ActionClient\nfrom geometry_msgs.action import NavigateToPose\nfrom control_msgs.action import FollowJointTrajectory\nimport time\n\nclass AdvancedNavigationActionClient(Node):\n    def __init__(self):\n        super().__init__('advanced_navigation_action_client')\n\n        # Create action client\n        self._action_client = ActionClient(\n            self, NavigateToPose, 'navigate_to_pose'\n        )\n\n        # Wait for action server\n        self.get_logger().info('Waiting for navigation action server...')\n        self._action_client.wait_for_server()\n        self.get_logger().info('Navigation action server available')\n\n        # Statistics tracking\n        self.navigation_stats = {\n            'completed': 0,\n            'cancelled': 0,\n            'failed': 0,\n            'avg_duration': 0.0\n        }\n\n    def send_navigation_goal(self, x, y, theta=0.0, timeout_sec=60.0):\n        \"\"\"Send navigation goal with comprehensive handling.\"\"\"\n        # Create goal message\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.pose.position.x = x\n        goal_msg.pose.pose.position.y = y\n        goal_msg.pose.pose.orientation.z = math.sin(theta / 2.0)\n        goal_msg.pose.pose.orientation.w = math.cos(theta / 2.0)\n\n        self.get_logger().info(f'Sending navigation goal to ({x}, {y}, {theta})')\n\n        # Send goal asynchronously\n        goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n\n        # Add goal response callback\n        goal_future.add_done_callback(\n            lambda future: self.goal_response_callback(future, timeout_sec)\n        )\n\n        return goal_future\n\n    def goal_response_callback(self, future, timeout_sec):\n        \"\"\"Handle goal response.\"\"\"\n        goal_handle = future.result()\n\n        if not goal_handle.accepted:\n            self.get_logger().info('Navigation goal rejected by server')\n            return\n\n        self.get_logger().info('Navigation goal accepted by server')\n\n        # Get result future\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(self.result_callback)\n\n        # Set up timeout monitoring\n        start_time = time.time()\n        self.monitor_navigation_timeout(goal_handle, start_time, timeout_sec)\n\n    def feedback_callback(self, feedback_msg):\n        \"\"\"Handle navigation feedback.\"\"\"\n        current_pos = feedback_msg.current_pose.pose.position\n        remaining = feedback_msg.distance_remaining\n\n        self.get_logger().info(\n            f'Navigation progress: position=({current_pos.x:.2f}, {current_pos.y:.2f}), '\n            f'distance remaining={remaining:.2f}m'\n        )\n\n    def result_callback(self, result_future):\n        \"\"\"Handle navigation result.\"\"\"\n        result = result_future.result().result\n        status = result_future.result().status\n\n        if status == GoalStatus.STATUS_SUCCEEDED:\n            self.get_logger().info('Navigation completed successfully')\n            self.navigation_stats['completed'] += 1\n        elif status == GoalStatus.STATUS_CANCELED:\n            self.get_logger().info('Navigation was cancelled')\n            self.navigation_stats['cancelled'] += 1\n        elif status == GoalStatus.STATUS_ABORTED:\n            self.get_logger().info('Navigation failed')\n            self.navigation_stats['failed'] += 1\n\n    def monitor_navigation_timeout(self, goal_handle, start_time, timeout_sec):\n        \"\"\"Monitor navigation for timeout.\"\"\"\n        if time.time() - start_time > timeout_sec:\n            self.get_logger().warn('Navigation timeout, cancelling goal...')\n            self.cancel_current_navigation(goal_handle)\n        else:\n            # Schedule next check\n            timer = self.create_timer(\n                1.0,\n                lambda: self.monitor_navigation_timeout(goal_handle, start_time, timeout_sec)\n            )\n\n    def cancel_current_navigation(self, goal_handle):\n        \"\"\"Cancel current navigation goal.\"\"\"\n        cancel_future = goal_handle.cancel_goal_async()\n        cancel_future.add_done_callback(self.cancel_response_callback)\n\n    def cancel_response_callback(self, future):\n        \"\"\"Handle cancellation response.\"\"\"\n        cancel_response = future.result()\n        if len(cancel_response.goals_canceling) > 0:\n            self.get_logger().info('Navigation goal successfully cancelled')\n        else:\n            self.get_logger().info('Navigation goal could not be cancelled')\n\n    def send_multiple_goals(self, waypoints):\n        \"\"\"Send multiple navigation goals in sequence.\"\"\"\n        for i, (x, y, theta) in enumerate(waypoints):\n            self.get_logger().info(f'Sending waypoint {i+1}: ({x}, {y}, {theta})')\n            self.send_navigation_goal(x, y, theta)\n\n            # Wait between goals (in a real implementation, this would be more sophisticated)\n            time.sleep(2)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"communication-pattern-selection",children:"Communication Pattern Selection"}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use-each-pattern",children:"When to Use Each Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Understanding when to use topics, services, or actions is crucial for proper ROS 2 design:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"\"\"\"\nCommunication Pattern Selection Guide:\n\nTOPICS (Publish/Subscribe):\n- Use for: Continuous data streams, sensor data, status updates\n- Characteristics: Asynchronous, many-to-many, fire-and-forget\n- Examples:\n  - Sensor readings (camera, LIDAR, IMU)\n  - Robot state (position, velocity, battery)\n  - Status information (health, diagnostics)\n\nSERVICES (Request/Response):\n- Use for: One-time computations, immediate responses\n- Characteristics: Synchronous, one-to-one, blocking\n- Examples:\n  - Transform lookup (tf2)\n  - Map queries\n  - Configuration changes\n  - Simple calculations\n\nACTIONS (Goal-Based):\n- Use for: Long-running tasks with feedback\n- Characteristics: Asynchronous, with progress tracking and cancellation\n- Examples:\n  - Navigation to goal\n  - Object manipulation\n  - Data processing tasks\n  - Calibration procedures\n\"\"\"\n\nclass CommunicationPatternSelector:\n    @staticmethod\n    def select_pattern(data_type, duration, feedback_needed, criticality):\n        \"\"\"\n        Select the appropriate communication pattern based on requirements.\n\n        Args:\n            data_type: Type of data (sensor, command, status, etc.)\n            duration: Expected duration (instant, short, long)\n            feedback_needed: Whether feedback is required (bool)\n            criticality: How critical the communication is (low, medium, high)\n        \"\"\"\n        if duration == 'continuous':\n            return 'topic'\n        elif duration == 'instant' and not feedback_needed:\n            return 'service'\n        elif duration == 'long' and feedback_needed:\n            return 'action'\n        elif duration == 'short' and not feedback_needed:\n            return 'service'\n        else:\n            return 'topic'  # Default to topic for continuous monitoring\n\n    @staticmethod\n    def get_qos_recommendations(pattern, data_type, criticality):\n        \"\"\"Get recommended QoS settings for different patterns.\"\"\"\n        from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\n\n        if pattern == 'topic':\n            if data_type in ['critical_sensor', 'command', 'emergency']:\n                return QoSProfile(\n                    reliability=ReliabilityPolicy.RELIABLE,\n                    history=HistoryPolicy.KEEP_LAST,\n                    depth=10\n                )\n            elif data_type in ['high_frequency', 'diagnostic', 'status']:\n                return QoSProfile(\n                    reliability=ReliabilityPolicy.BEST_EFFORT,\n                    history=HistoryPolicy.KEEP_LAST,\n                    depth=1\n                )\n        elif pattern == 'service':\n            return QoSProfile(\n                reliability=ReliabilityPolicy.RELIABLE,\n                history=HistoryPolicy.KEEP_LAST,\n                depth=10\n            )\n        elif pattern == 'action':\n            return QoSProfile(\n                reliability=ReliabilityPolicy.RELIABLE,\n                history=HistoryPolicy.KEEP_ALL,\n                depth=1\n            )\n"})}),"\n",(0,s.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,s.jsx)(n.h3,{id:"multi-pattern-robot-controller",children:"Multi-Pattern Robot Controller"}),"\n",(0,s.jsx)(n.p,{children:"Here's a comprehensive example that demonstrates services and actions working together:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from rclpy.qos import QoSProfile, qos_profile_sensor_data\nfrom std_msgs.msg import String, Float64\nfrom example_interfaces.srv import SetBool\nfrom example_interfaces.action import Fibonacci\nfrom rclpy.action import ActionClient\nimport threading\n\nclass IntegratedRobotController(Node):\n    def __init__(self):\n        super().__init__(\'integrated_robot_controller\')\n\n        # SERVICE: Servers for immediate commands\n        self.emergency_service = self.create_service(\n            SetBool, \'emergency_stop\', self.emergency_stop_callback\n        )\n\n        # SERVICE: Clients for external services\n        self.navigation_client = self.create_client(\n            SetBool, \'navigation_service\'\n        )\n\n        # ACTION: Action client for long-running tasks\n        self.movement_action_client = ActionClient(\n            self, Fibonacci, \'movement_sequence\'\n        )\n\n        # Robot state\n        self.current_position = 0.0\n        self.is_emergency_stopped = False\n        self.is_moving = False\n\n    def emergency_stop_callback(self, request, response):\n        """Handle emergency stop via service."""\n        if request.data:\n            self.emergency_stop()\n            response.success = True\n            response.message = \'Emergency stop activated\'\n        else:\n            self.emergency_stop_release()\n            response.success = True\n            response.message = \'Emergency stop released\'\n\n        return response\n\n    def emergency_stop(self):\n        """Emergency stop the robot."""\n        self.is_emergency_stopped = True\n        self.is_moving = False\n        self.get_logger().warn(\'EMERGENCY STOP ACTIVATED\')\n\n    def emergency_stop_release(self):\n        """Release emergency stop."""\n        self.is_emergency_stopped = False\n        self.get_logger().info(\'Emergency stop released\')\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization-and-best-practices",children:"Performance Optimization and Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"service-optimization",children:"Service Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class OptimizedServiceNode(Node):\n    def __init__(self):\n        super().__init__(\'optimized_service\')\n\n        # Optimized service with thread pool\n        self.optimized_service = self.create_service(\n            AddTwoInts, \'optimized_calc\', self.optimized_calc_callback\n        )\n\n        # Thread pool for handling requests\n        self.thread_pool = ThreadPoolExecutor(max_workers=4)\n\n    def optimized_calc_callback(self, request, response):\n        """Handle service request with thread pool."""\n        try:\n            # Perform calculation using thread pool if needed\n            result = self.perform_calculation(request.a, request.b)\n            response.sum = result\n            response.success = True\n            response.message = f\'Calculated: {result}\'\n        except Exception as e:\n            response.success = False\n            response.message = str(e)\n\n        return response\n\n    def perform_calculation(self, a, b):\n        """Perform the actual calculation."""\n        # Implement calculation logic\n        return a + b\n'})}),"\n",(0,s.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,s.jsx)(n.p,{children:"This section covered the comprehensive implementation of services and actions in ROS 2:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Services"}),": Synchronous request/response communication for immediate computations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Actions"}),": Goal-oriented communication with feedback and cancellation for long-running tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pattern Selection"}),": When to use topics, services, or actions based on application requirements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Advanced Features"}),": Service chaining, load balancing, and complex state management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration"}),": How services and actions work together in comprehensive robotic systems"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Services and actions complement topics by providing synchronous communication for immediate responses and goal-oriented communication for complex, long-running operations with feedback and cancellation capabilities."})]})}function _(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);