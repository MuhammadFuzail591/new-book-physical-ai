"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[2188],{4650:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var t=s(4848),a=s(8453);const i={title:"Topics, Services & Actions in ROS 2"},o="Topics, Services & Actions in ROS 2",r={id:"ros2-communication/topics-services-actions",title:"Topics, Services & Actions in ROS 2",description:"Introduction",source:"@site/docs/physical-ai/ros2-communication/topics-services-actions.mdx",sourceDirName:"ros2-communication",slug:"/ros2-communication/topics-services-actions",permalink:"/ros2-communication/topics-services-actions",draft:!1,unlisted:!1,editUrl:"https://github.com/fuzailpalook/new-book/tree/main/docs/physical-ai/ros2-communication/topics-services-actions.mdx",tags:[],version:"current",frontMatter:{title:"Topics, Services & Actions in ROS 2"}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Comprehensive Topic Implementation",id:"comprehensive-topic-implementation",level:2},{value:"Advanced Topic Patterns and Best Practices",id:"advanced-topic-patterns-and-best-practices",level:3},{value:"Topic Filtering and Transformation",id:"topic-filtering-and-transformation",level:3},{value:"Topic Monitoring and Statistics",id:"topic-monitoring-and-statistics",level:3},{value:"Advanced Service Implementation",id:"advanced-service-implementation",level:2},{value:"Robust Service Architecture",id:"robust-service-architecture",level:3},{value:"Service Chaining and Coordination",id:"service-chaining-and-coordination",level:3},{value:"Comprehensive Action Implementation",id:"comprehensive-action-implementation",level:2},{value:"Advanced Action Server with Complex State Management",id:"advanced-action-server-with-complex-state-management",level:3},{value:"Advanced Action Client with Comprehensive Features",id:"advanced-action-client-with-comprehensive-features",level:3},{value:"Communication Pattern Integration",id:"communication-pattern-integration",level:2},{value:"Comprehensive Multi-Pattern System",id:"comprehensive-multi-pattern-system",level:3},{value:"Performance Optimization and Best Practices",id:"performance-optimization-and-best-practices",level:2},{value:"Memory and Resource Optimization",id:"memory-and-resource-optimization",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Further Reading",id:"further-reading",level:2}];function _(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"topics-services--actions-in-ros-2",children:"Topics, Services & Actions in ROS 2"}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Topics, services, and actions represent the three fundamental communication patterns in ROS 2, each designed for specific types of interactions between nodes. Understanding these patterns is crucial for designing effective robotic systems. Topics enable asynchronous, many-to-many communication for continuous data streams. Services provide synchronous, request-response communication for immediate computations. Actions handle goal-oriented, long-running tasks with feedback and cancellation capabilities."}),"\n",(0,t.jsx)(n.h2,{id:"comprehensive-topic-implementation",children:"Comprehensive Topic Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"advanced-topic-patterns-and-best-practices",children:"Advanced Topic Patterns and Best Practices"}),"\n",(0,t.jsx)(n.p,{children:"Topics form the backbone of ROS 2's publish/subscribe communication model. They enable asynchronous, decoupled communication between multiple publishers and subscribers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Int32, Float64\nfrom sensor_msgs.msg import LaserScan, Imu, JointState\nfrom geometry_msgs.msg import Twist, PoseStamped\nfrom nav_msgs.msg import Odometry\nimport threading\nimport time\nfrom collections import deque\nimport numpy as np\n\nclass AdvancedTopicNode(Node):\n    def __init__(self):\n        super().__init__('advanced_topic_node')\n\n        # Multiple publishers for different data types\n        self.status_publisher = self.create_publisher(String, 'robot_status', 10)\n        self.odometry_publisher = self.create_publisher(Odometry, 'odometry', 10)\n        self.cmd_vel_publisher = self.create_publisher(Twist, 'cmd_vel', 10)\n        self.joint_states_publisher = self.create_publisher(JointState, 'joint_states', 10)\n\n        # Multiple subscribers with different QoS profiles\n        self.command_subscriber = self.create_subscription(\n            Twist, 'cmd_vel', self.cmd_vel_callback, 10\n        )\n        self.sensor_subscriber = self.create_subscription(\n            LaserScan, 'laser_scan', self.laser_callback,\n            qos_profile=qos_profile_sensor_data\n        )\n        self.imu_subscriber = self.create_subscription(\n            Imu, 'imu/data', self.imu_callback,\n            qos_profile=qos_profile_sensor_data\n        )\n\n        # Pre-allocated messages for optimization\n        self.odom_msg = Odometry()\n        self.joint_msg = JointState()\n        self.status_msg = String()\n\n        # Timer for periodic publishing\n        self.publish_timer = self.create_timer(0.1, self.publish_robot_state)\n\n        # Data storage for state management\n        self.robot_state = {\n            'position': {'x': 0.0, 'y': 0.0, 'theta': 0.0},\n            'velocity': {'linear': 0.0, 'angular': 0.0},\n            'joint_positions': [0.0] * 6,  # Example 6-DOF robot\n            'battery_level': 100.0\n        }\n\n        # Statistics tracking\n        self.message_stats = {\n            'received': 0,\n            'published': 0,\n            'timestamps': deque(maxlen=100)\n        }\n\n    def cmd_vel_callback(self, msg):\n        \"\"\"Handle velocity commands.\"\"\"\n        self.message_stats['received'] += 1\n        self.message_stats['timestamps'].append(self.get_clock().now().nanoseconds)\n\n        # Update robot state based on command\n        self.robot_state['velocity']['linear'] = msg.linear.x\n        self.robot_state['velocity']['angular'] = msg.angular.z\n\n        self.get_logger().info(\n            f'Received velocity command: linear={msg.linear.x}, angular={msg.angular.z}'\n        )\n\n    def laser_callback(self, msg):\n        \"\"\"Handle laser scan data.\"\"\"\n        # Process laser data for obstacle detection\n        min_range = min([r for r in msg.ranges if not np.isnan(r)], default=float('inf'))\n\n        if min_range < 1.0:  # Obstacle within 1 meter\n            self.get_logger().warn(f'Obstacle detected at {min_range:.2f}m')\n\n    def imu_callback(self, msg):\n        \"\"\"Handle IMU data.\"\"\"\n        # Extract orientation and angular velocity\n        orientation = msg.orientation\n        angular_velocity = msg.angular_velocity\n\n        self.get_logger().info(\n            f'IMU: orientation=({orientation.x:.3f}, {orientation.y:.3f}, {orientation.z:.3f}, {orientation.w:.3f})'\n        )\n\n    def publish_robot_state(self):\n        \"\"\"Publish robot state information.\"\"\"\n        # Update odometry message\n        self.odom_msg.header.stamp = self.get_clock().now().to_msg()\n        self.odom_msg.header.frame_id = 'odom'\n        self.odom_msg.child_frame_id = 'base_link'\n\n        # Set position (simplified for example)\n        self.odom_msg.pose.pose.position.x = self.robot_state['position']['x']\n        self.odom_msg.pose.pose.position.y = self.robot_state['position']['y']\n\n        # Set velocity\n        self.odom_msg.twist.twist.linear.x = self.robot_state['velocity']['linear']\n        self.odom_msg.twist.twist.angular.z = self.robot_state['velocity']['angular']\n\n        # Update joint states\n        self.joint_msg.header.stamp = self.get_clock().now().to_msg()\n        self.joint_msg.name = [f'joint_{i}' for i in range(6)]\n        self.joint_msg.position = self.robot_state['joint_positions']\n\n        # Update status\n        self.status_msg.data = f'Battery: {self.robot_state[\"battery_level\"]:.1f}%, Pos: ({self.robot_state[\"position\"][\"x\"]:.2f}, {self.robot_state[\"position\"][\"y\"]:.2f})'\n\n        # Publish all messages\n        self.odometry_publisher.publish(self.odom_msg)\n        self.joint_states_publisher.publish(self.joint_msg)\n        self.status_publisher.publish(self.status_msg)\n\n        self.message_stats['published'] += 3  # 3 messages published\n"})}),"\n",(0,t.jsx)(n.h3,{id:"topic-filtering-and-transformation",children:"Topic Filtering and Transformation"}),"\n",(0,t.jsx)(n.p,{children:"Advanced topic handling often requires filtering, transforming, or aggregating data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from sensor_msgs.msg import PointCloud2, LaserScan\nimport sensor_msgs.point_cloud2 as pc2\nfrom std_msgs.msg import Header\nfrom geometry_msgs.msg import Point32\n\nclass TopicFilterNode(Node):\n    def __init__(self):\n        super().__init__('topic_filter_node')\n\n        # Subscribe to raw sensor data\n        self.pointcloud_sub = self.create_subscription(\n            PointCloud2, 'raw_pointcloud', self.pointcloud_callback, 10\n        )\n\n        self.laser_sub = self.create_subscription(\n            LaserScan, 'raw_laser', self.laser_callback, 10\n        )\n\n        # Publish filtered data\n        self.filtered_pc_pub = self.create_publisher(PointCloud2, 'filtered_pointcloud', 10)\n        self.filtered_laser_pub = self.create_publisher(LaserScan, 'filtered_laser', 10)\n\n        # Parameters for filtering\n        self.declare_parameter('min_distance', 0.5)\n        self.declare_parameter('max_distance', 10.0)\n        self.declare_parameter('x_min', -5.0)\n        self.declare_parameter('x_max', 5.0)\n        self.declare_parameter('y_min', -5.0)\n        self.declare_parameter('y_max', 5.0)\n\n    def pointcloud_callback(self, msg):\n        \"\"\"Filter point cloud data.\"\"\"\n        try:\n            # Convert PointCloud2 to list of points\n            points = list(pc2.read_points(msg, field_names=(\"x\", \"y\", \"z\"), skip_nans=True))\n\n            # Apply spatial filtering\n            filtered_points = []\n            min_dist = self.get_parameter('min_distance').value\n            max_dist = self.get_parameter('max_distance').value\n            x_min = self.get_parameter('x_min').value\n            x_max = self.get_parameter('x_max').value\n            y_min = self.get_parameter('y_min').value\n            y_max = self.get_parameter('y_max').value\n\n            for point in points:\n                x, y, z = point\n                distance = np.sqrt(x**2 + y**2 + z**2)\n\n                if (min_dist <= distance <= max_dist and\n                    x_min <= x <= x_max and\n                    y_min <= y <= y_max):\n                    filtered_points.append([x, y, z])\n\n            # Create new PointCloud2 message with filtered points\n            header = Header()\n            header.stamp = msg.header.stamp\n            header.frame_id = msg.header.frame_id\n\n            filtered_msg = pc2.create_cloud_xyz32(header, filtered_points)\n            self.filtered_pc_pub.publish(filtered_msg)\n\n        except Exception as e:\n            self.get_logger().error(f'Error filtering point cloud: {e}')\n\n    def laser_callback(self, msg):\n        \"\"\"Filter laser scan data.\"\"\"\n        # Apply range filtering\n        filtered_ranges = []\n        min_range = self.get_parameter('min_distance').value\n        max_range = self.get_parameter('max_distance').value\n\n        for range_val in msg.ranges:\n            if np.isnan(range_val) or range_val < min_range or range_val > max_range:\n                filtered_ranges.append(float('inf'))  # Mark as invalid\n            else:\n                filtered_ranges.append(range_val)\n\n        # Create filtered message\n        filtered_msg = LaserScan()\n        filtered_msg.header = msg.header\n        filtered_msg.angle_min = msg.angle_min\n        filtered_msg.angle_max = msg.angle_max\n        filtered_msg.angle_increment = msg.angle_increment\n        filtered_msg.time_increment = msg.time_increment\n        filtered_msg.scan_time = msg.scan_time\n        filtered_msg.range_min = min_range\n        filtered_msg.range_max = max_range\n        filtered_msg.ranges = filtered_ranges\n        filtered_msg.intensities = msg.intensities  # Keep original intensities\n\n        self.filtered_laser_pub.publish(filtered_msg)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"topic-monitoring-and-statistics",children:"Topic Monitoring and Statistics"}),"\n",(0,t.jsx)(n.p,{children:"Monitoring topic performance is essential for robust robotic systems:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from rclpy.qos import qos_profile_sensor_data\nfrom std_msgs.msg import String\nimport time\nfrom collections import deque\nimport statistics\n\nclass TopicMonitorNode(Node):\n    def __init__(self):\n        super().__init__(\'topic_monitor\')\n\n        # Subscribe to topic with monitoring\n        self.monitored_sub = self.create_subscription(\n            String, \'monitored_topic\', self.monitored_callback,\n            qos_profile=qos_profile_sensor_data\n        )\n\n        # Statistics publishers\n        self.stats_pub = self.create_publisher(String, \'topic_statistics\', 10)\n        self.health_pub = self.create_publisher(String, \'topic_health\', 10)\n\n        # Statistics tracking\n        self.message_count = 0\n        self.message_times = deque(maxlen=1000)  # Store timestamps\n        self.message_sizes = deque(maxlen=1000)  # Store sizes\n        self.message_intervals = deque(maxlen=1000)  # Store intervals\n        self.start_time = self.get_clock().now()\n\n        # Monitoring timer\n        self.monitor_timer = self.create_timer(5.0, self.publish_monitoring_data)\n\n        # Health monitoring\n        self.last_message_time = self.get_clock().now()\n        self.health_timer = self.create_timer(1.0, self.check_health)\n\n    def monitored_callback(self, msg):\n        """Monitor incoming messages."""\n        current_time = self.get_clock().now()\n        self.message_count += 1\n\n        # Store timing information\n        self.message_times.append(current_time.nanoseconds)\n        self.message_sizes.append(len(msg.data.encode(\'utf-8\')))\n\n        # Calculate interval if we have previous message\n        if len(self.message_times) > 1:\n            interval = (self.message_times[-1] - self.message_times[-2]) / 1e9\n            self.message_intervals.append(interval)\n\n        # Update last message time for health monitoring\n        self.last_message_time = current_time\n\n        # Process the message\n        self.process_monitored_message(msg)\n\n    def process_monitored_message(self, msg):\n        """Process the monitored message."""\n        # Implement specific message processing logic here\n        self.get_logger().debug(f\'Monitored: {msg.data}\')\n\n    def publish_monitoring_data(self):\n        """Publish monitoring statistics."""\n        if self.message_count == 0:\n            return\n\n        # Calculate statistics\n        elapsed_time = (self.get_clock().now() - self.start_time).nanoseconds / 1e9\n        message_rate = self.message_count / elapsed_time if elapsed_time > 0 else 0\n\n        # Calculate interval statistics\n        avg_interval = statistics.mean(self.message_intervals) if self.message_intervals else 0\n        std_interval = statistics.stdev(self.message_intervals) if len(self.message_intervals) > 1 else 0\n        min_interval = min(self.message_intervals) if self.message_intervals else 0\n        max_interval = max(self.message_intervals) if self.message_intervals else 0\n\n        # Calculate size statistics\n        avg_size = statistics.mean(self.message_sizes) if self.message_sizes else 0\n        std_size = statistics.stdev(self.message_sizes) if len(self.message_sizes) > 1 else 0\n\n        # Create statistics message\n        stats_msg = String()\n        stats_msg.data = (\n            f"Topic Statistics:\\n"\n            f"  Total Messages: {self.message_count}\\n"\n            f"  Message Rate: {message_rate:.2f} Hz\\n"\n            f"  Avg Interval: {avg_interval:.4f}s (\xb1{std_interval:.4f}s)\\n"\n            f"  Interval Range: {min_interval:.4f}s - {max_interval:.4f}s\\n"\n            f"  Avg Size: {avg_size:.2f} bytes (\xb1{std_size:.2f} bytes)\\n"\n            f"  Elapsed Time: {elapsed_time:.2f}s\\n"\n        )\n\n        self.stats_pub.publish(stats_msg)\n\n    def check_health(self):\n        """Check topic health."""\n        current_time = self.get_clock().now()\n        time_since_last = (current_time - self.last_message_time).nanoseconds / 1e9\n\n        health_msg = String()\n        if time_since_last > 5.0:  # No message in 5 seconds\n            health_msg.data = f"ALERT: No messages received for {time_since_last:.2f}s"\n        else:\n            health_msg.data = f"OK: Last message {time_since_last:.2f}s ago"\n\n        self.health_pub.publish(health_msg)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-service-implementation",children:"Advanced Service Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"robust-service-architecture",children:"Robust Service Architecture"}),"\n",(0,t.jsx)(n.p,{children:"Services provide synchronous request/response communication for immediate computations and operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\nfrom example_interfaces.srv import AddTwoInts, SetBool\nfrom std_srvs.srv import Trigger, Empty\nfrom sensor_msgs.srv import SetCameraInfo\nimport time\nimport threading\nfrom rclpy.task import Future\n\nclass AdvancedServiceNode(Node):\n    def __init__(self):\n        super().__init__('advanced_service_node')\n\n        # Multiple service servers\n        self.add_service = self.create_service(\n            AddTwoInts, 'robust_add_two_ints', self.robust_add_callback\n        )\n\n        self.toggle_service = self.create_service(\n            SetBool, 'toggle_device', self.toggle_callback\n        )\n\n        self.trigger_service = self.create_service(\n            Trigger, 'trigger_operation', self.trigger_callback\n        )\n\n        # Service clients for internal coordination\n        self.dependency_client = self.create_client(\n            Trigger, 'dependency_service'\n        )\n\n        # Statistics for monitoring\n        self.service_stats = {\n            'add': {'requests': 0, 'errors': 0, 'avg_time': 0.0},\n            'toggle': {'requests': 0, 'errors': 0, 'avg_time': 0.0},\n            'trigger': {'requests': 0, 'errors': 0, 'avg_time': 0.0}\n        }\n\n        # Thread-safe statistics\n        self.stats_lock = threading.Lock()\n\n    def robust_add_callback(self, request, response):\n        \"\"\"Robust addition service with error handling.\"\"\"\n        start_time = time.time()\n        self._update_stats('add', 'requests')\n\n        try:\n            # Validate inputs\n            if not self._validate_numbers(request.a, request.b):\n                self.get_logger().error('Invalid numbers provided to add service')\n                response.success = False\n                response.message = 'Invalid input numbers'\n                self._update_stats('add', 'errors')\n                return response\n\n            # Perform calculation\n            result = self._safe_add(request.a, request.b)\n            response.sum = result\n            response.success = True\n            response.message = f'Successfully calculated {request.a} + {request.b} = {result}'\n\n            # Log successful operation\n            processing_time = time.time() - start_time\n            self._update_avg_time('add', processing_time)\n            self.get_logger().info(\n                f'Add service: {request.a} + {request.b} = {result} '\n                f'(time: {processing_time:.4f}s)'\n            )\n\n        except Exception as e:\n            self.get_logger().error(f'Add service error: {e}')\n            response.success = False\n            response.message = f'Calculation error: {str(e)}'\n            self._update_stats('add', 'errors')\n\n        return response\n\n    def toggle_callback(self, request, response):\n        \"\"\"Toggle service with state management.\"\"\"\n        start_time = time.time()\n        self._update_stats('toggle', 'requests')\n\n        try:\n            # Simulate device toggle operation\n            device_state = request.data\n            self.get_logger().info(f'Toggling device to state: {device_state}')\n\n            # Simulate hardware operation time\n            time.sleep(0.1)\n\n            response.success = True\n            response.message = f'Device toggled to {\"ON\" if device_state else \"OFF\"}'\n\n            processing_time = time.time() - start_time\n            self._update_avg_time('toggle', processing_time)\n\n        except Exception as e:\n            self.get_logger().error(f'Toggle service error: {e}')\n            response.success = False\n            response.message = f'Toggle operation failed: {str(e)}'\n            self._update_stats('toggle', 'errors')\n\n        return response\n\n    def trigger_callback(self, request, response):\n        \"\"\"Trigger service with complex operations.\"\"\"\n        start_time = time.time()\n        self._update_stats('trigger', 'requests')\n\n        try:\n            # Check dependencies\n            if not self._check_dependencies():\n                response.success = False\n                response.message = 'Required dependencies not available'\n                self._update_stats('trigger', 'errors')\n                return response\n\n            # Perform complex operation\n            success = self._perform_complex_operation()\n\n            response.success = success\n            response.message = 'Operation completed successfully' if success else 'Operation failed'\n\n            processing_time = time.time() - start_time\n            self._update_avg_time('trigger', processing_time)\n\n        except Exception as e:\n            self.get_logger().error(f'Trigger service error: {e}')\n            response.success = False\n            response.message = f'Trigger operation failed: {str(e)}'\n            self._update_stats('trigger', 'errors')\n\n        return response\n\n    def _validate_numbers(self, a, b):\n        \"\"\"Validate number inputs.\"\"\"\n        if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n            return False\n        if abs(a) > 1e10 or abs(b) > 1e10:\n            self.get_logger().warn('Very large numbers detected')\n        return True\n\n    def _safe_add(self, a, b):\n        \"\"\"Perform safe addition with overflow protection.\"\"\"\n        try:\n            result = a + b\n            if not np.isfinite(result):\n                raise ValueError('Result is not finite')\n            return result\n        except OverflowError:\n            raise ValueError('Addition resulted in overflow')\n\n    def _check_dependencies(self):\n        \"\"\"Check if required dependencies are available.\"\"\"\n        # Simulate dependency check\n        return True\n\n    def _perform_complex_operation(self):\n        \"\"\"Perform a complex operation.\"\"\"\n        # Simulate complex operation\n        time.sleep(0.5)\n        return True\n\n    def _update_stats(self, service_name, stat_type):\n        \"\"\"Thread-safe statistics update.\"\"\"\n        with self.stats_lock:\n            if stat_type == 'requests':\n                self.service_stats[service_name]['requests'] += 1\n            elif stat_type == 'errors':\n                self.service_stats[service_name]['errors'] += 1\n\n    def _update_avg_time(self, service_name, processing_time):\n        \"\"\"Update average processing time.\"\"\"\n        with self.stats_lock:\n            stats = self.service_stats[service_name]\n            current_avg = stats['avg_time']\n            count = stats['requests']\n            stats['avg_time'] = ((current_avg * (count - 1)) + processing_time) / count\n"})}),"\n",(0,t.jsx)(n.h3,{id:"service-chaining-and-coordination",children:"Service Chaining and Coordination"}),"\n",(0,t.jsx)(n.p,{children:"Complex robotic systems often require services that coordinate with other services:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import qos_profile_services_default\nfrom example_interfaces.srv import AddTwoInts, SetBool\nfrom std_srvs.srv import Trigger\nimport asyncio\n\nclass ServiceCoordinatorNode(Node):\n    def __init__(self):\n        super().__init__('service_coordinator')\n\n        # Main service that coordinates other services\n        self.complex_calc_service = self.create_service(\n            AddTwoInts, 'complex_calculation', self.complex_calc_callback\n        )\n\n        # Client for dependency services\n        self.add_client = self.create_client(AddTwoInts, 'robust_add_two_ints')\n        self.multiply_client = self.create_client(AddTwoInts, 'multiply_service')\n        self.validation_client = self.create_client(SetBool, 'validate_inputs')\n\n        # Wait for services to be available\n        self.get_logger().info('Waiting for dependency services...')\n        while not self.add_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Add service not available, waiting...')\n        while not self.multiply_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Multiply service not available, waiting...')\n        while not self.validation_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Validation service not available, waiting...')\n\n    def complex_calc_callback(self, request, response):\n        \"\"\"Complex calculation that chains multiple services.\"\"\"\n        try:\n            # First, validate inputs\n            validation_request = SetBool.Request()\n            validation_request.data = True  # Simplified validation\n            validation_future = self.validation_client.call_async(validation_request)\n\n            # Wait for validation result\n            rclpy.spin_until_future_complete(self, validation_future)\n            validation_result = validation_future.result()\n\n            if not validation_result.success:\n                response.success = False\n                response.message = validation_result.message\n                return response\n\n            # Perform addition using dependency service\n            add_request = AddTwoInts.Request()\n            add_request.a = request.a\n            add_request.b = request.b\n            add_future = self.add_client.call_async(add_request)\n\n            # Wait for addition result\n            rclpy.spin_until_future_complete(self, add_future)\n            add_result = add_future.result()\n\n            if not add_result.sum:\n                response.success = False\n                response.message = 'Addition service failed'\n                return response\n\n            # Multiply result by a factor (simplified example)\n            multiply_request = AddTwoInts.Request()\n            multiply_request.a = add_result.sum\n            multiply_request.b = 2  # Factor of 2\n            multiply_future = self.multiply_client.call_async(multiply_request)\n\n            # Wait for multiplication result\n            rclpy.spin_until_future_complete(self, multiply_future)\n            multiply_result = multiply_future.result()\n\n            response.sum = multiply_result.sum\n            response.success = True\n            response.message = f'Complex calculation completed: ({request.a} + {request.b}) * 2 = {multiply_result.sum}'\n\n        except Exception as e:\n            self.get_logger().error(f'Complex calculation error: {e}')\n            response.success = False\n            response.message = f'Complex calculation failed: {str(e)}'\n\n        return response\n\nclass ServiceLoadBalancerNode(Node):\n    def __init__(self):\n        super().__init__('service_load_balancer')\n\n        # Main service interface\n        self.load_balanced_service = self.create_service(\n            AddTwoInts, 'load_balanced_calc', self.load_balanced_callback\n        )\n\n        # Multiple backend services\n        self.backend_clients = [\n            self.create_client(AddTwoInts, 'backend_calc_1'),\n            self.create_client(AddTwoInts, 'backend_calc_2'),\n            self.create_client(AddTwoInts, 'backend_calc_3')\n        ]\n\n        # Load balancing state\n        self.current_backend = 0\n        self.backend_stats = [0] * len(self.backend_clients)  # Request counts\n\n        # Wait for all backends\n        for i, client in enumerate(self.backend_clients):\n            while not client.wait_for_service(timeout_sec=1.0):\n                self.get_logger().info(f'Backend {i+1} not available, waiting...')\n\n    def load_balanced_callback(self, request, response):\n        \"\"\"Distribute requests across multiple backend services.\"\"\"\n        # Select backend using round-robin\n        selected_client = self.backend_clients[self.current_backend]\n        self.backend_stats[self.current_backend] += 1\n\n        # Update for next request\n        self.current_backend = (self.current_backend + 1) % len(self.backend_clients)\n\n        try:\n            # Call backend service\n            backend_request = AddTwoInts.Request()\n            backend_request.a = request.a\n            backend_request.b = request.b\n\n            backend_future = selected_client.call_async(backend_request)\n            rclpy.spin_until_future_complete(self, backend_future)\n            backend_result = backend_future.result()\n\n            response.sum = backend_result.sum\n            response.success = backend_result.sum is not None\n            response.message = f'Processed by backend {self.current_backend}'\n\n        except Exception as e:\n            self.get_logger().error(f'Load balancer error: {e}')\n            response.success = False\n            response.message = f'Load balancing failed: {str(e)}'\n\n        return response\n"})}),"\n",(0,t.jsx)(n.h2,{id:"comprehensive-action-implementation",children:"Comprehensive Action Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"advanced-action-server-with-complex-state-management",children:"Advanced Action Server with Complex State Management"}),"\n",(0,t.jsx)(n.p,{children:"Actions provide goal-oriented communication with feedback and cancellation for long-running tasks:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom example_interfaces.action import Fibonacci\nfrom geometry_msgs.action import NavigateToPose\nfrom control_msgs.action import FollowJointTrajectory\nimport threading\nimport time\nimport math\nfrom collections import deque\n\nclass AdvancedNavigationActionServer(Node):\n    def __init__(self):\n        super().__init__('advanced_navigation_action_server')\n\n        # Use reentrant callback group for concurrent access\n        callback_group = ReentrantCallbackGroup()\n\n        self._action_server = ActionServer(\n            self,\n            NavigateToPose,\n            'navigate_to_pose',\n            self.execute_callback,\n            goal_callback=self.goal_callback,\n            handle_accepted_callback=self.handle_accepted_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=callback_group\n        )\n\n        # State tracking\n        self.current_pose = {'x': 0.0, 'y': 0.0, 'theta': 0.0}\n        self.active_goals = {}\n        self.navigation_history = deque(maxlen=100)\n\n        # Publishers for navigation state\n        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)\n        self.pose_pub = self.create_publisher(PoseStamped, 'current_pose', 10)\n\n        # Timer for periodic state updates\n        self.state_timer = self.create_timer(0.1, self.update_navigation_state)\n\n    def goal_callback(self, goal_request):\n        \"\"\"Validate and accept/reject navigation goals.\"\"\"\n        target_pose = goal_request.pose.pose\n        current_pose = self.current_pose\n\n        # Calculate distance to goal\n        distance = math.sqrt(\n            (target_pose.position.x - current_pose['x'])**2 +\n            (target_pose.position.y - current_pose['y'])**2\n        )\n\n        # Validate goal\n        if distance > 100.0:  # Max navigation distance\n            self.get_logger().warn(f'Navigation goal too far: {distance:.2f}m')\n            return GoalResponse.REJECT\n        elif distance < 0.1:  # Already at goal\n            self.get_logger().info('Already at navigation goal')\n            return GoalResponse.REJECT\n        else:\n            self.get_logger().info(f'Accepting navigation goal, distance: {distance:.2f}m')\n            return GoalResponse.ACCEPT\n\n    def handle_accepted_callback(self, goal_handle):\n        \"\"\"Handle accepted goal by starting execution.\"\"\"\n        self.get_logger().info('Navigation goal accepted, starting execution')\n\n        # Store goal in active goals\n        goal_id = goal_handle.goal_id.uuid\n        self.active_goals[goal_id] = goal_handle\n\n        # Start execution in separate thread\n        thread = threading.Thread(target=self.execute_navigation, args=(goal_handle,))\n        thread.start()\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Handle cancel request.\"\"\"\n        self.get_logger().info('Navigation goal cancellation requested')\n        return CancelResponse.ACCEPT\n\n    def execute_navigation(self, goal_handle):\n        \"\"\"Execute navigation in separate thread.\"\"\"\n        self.get_logger().info('Starting navigation execution...')\n\n        # Extract goal pose\n        target_pose = goal_handle.request.pose.pose\n        target_x = target_pose.position.x\n        target_y = target_pose.position.y\n\n        # Navigation parameters\n        linear_speed = 0.5\n        angular_speed = 0.5\n        tolerance = 0.1  # Distance tolerance in meters\n\n        # Navigation loop\n        while rclpy.ok():\n            # Check for cancellation\n            if goal_handle.is_cancel_requested:\n                self.get_logger().info('Navigation goal cancelled')\n                goal_handle.canceled()\n\n                # Stop robot\n                stop_msg = Twist()\n                self.cmd_vel_pub.publish(stop_msg)\n\n                # Remove from active goals\n                goal_id = goal_handle.goal_id.uuid\n                if goal_id in self.active_goals:\n                    del self.active_goals[goal_id]\n                return\n\n            # Calculate distance to goal\n            distance = math.sqrt(\n                (target_x - self.current_pose['x'])**2 +\n                (target_y - self.current_pose['y'])**2\n            )\n\n            # Check if reached goal\n            if distance <= tolerance:\n                self.get_logger().info('Navigation goal reached')\n\n                # Stop robot\n                stop_msg = Twist()\n                self.cmd_vel_pub.publish(stop_msg)\n\n                # Create result\n                result = NavigateToPose.Result()\n                result.result_code = 1  # Success\n\n                goal_handle.succeed()\n                goal_handle.publish_result(result)\n\n                # Add to history\n                history_entry = {\n                    'start': (self.current_pose['x'], self.current_pose['y']),\n                    'goal': (target_x, target_y),\n                    'distance': distance,\n                    'time': time.time()\n                }\n                self.navigation_history.append(history_entry)\n\n                # Remove from active goals\n                goal_id = goal_handle.goal_id.uuid\n                if goal_id in self.active_goals:\n                    del self.active_goals[goal_id]\n                return\n\n            # Calculate control commands\n            cmd_vel = self.calculate_navigation_command(target_x, target_y, linear_speed, angular_speed)\n\n            # Publish command\n            self.cmd_vel_pub.publish(cmd_vel)\n\n            # Publish feedback\n            feedback = NavigateToPose.Feedback()\n            feedback.current_pose.pose.position.x = self.current_pose['x']\n            feedback.current_pose.pose.position.y = self.current_pose['y']\n            feedback.distance_remaining = distance\n            goal_handle.publish_feedback(feedback)\n\n            # Log progress\n            self.get_logger().info(f'Navigating: {distance:.2f}m remaining')\n\n            # Sleep to control loop rate\n            time.sleep(0.1)\n\n    def calculate_navigation_command(self, target_x, target_y, linear_speed, angular_speed):\n        \"\"\"Calculate navigation commands.\"\"\"\n        # Calculate desired angle\n        desired_angle = math.atan2(\n            target_y - self.current_pose['y'],\n            target_x - self.current_pose['x']\n        )\n\n        # Calculate angle difference\n        angle_diff = desired_angle - self.current_pose['theta']\n\n        # Normalize angle\n        while angle_diff > math.pi:\n            angle_diff -= 2 * math.pi\n        while angle_diff < -math.pi:\n            angle_diff += 2 * math.pi\n\n        # Create command message\n        cmd_vel = Twist()\n        cmd_vel.linear.x = min(linear_speed, linear_speed * (abs(angle_diff) < 0.1))\n        cmd_vel.angular.z = angular_speed * angle_diff\n\n        return cmd_vel\n\n    def update_navigation_state(self):\n        \"\"\"Update navigation state periodically.\"\"\"\n        # Simulate state updates (in real system, this would come from localization)\n        self.current_pose['x'] += 0.01  # Simulated movement\n        self.current_pose['y'] += 0.005  # Simulated movement\n\n        # Publish current pose\n        pose_msg = PoseStamped()\n        pose_msg.header.stamp = self.get_clock().now().to_msg()\n        pose_msg.header.frame_id = 'map'\n        pose_msg.pose.position.x = self.current_pose['x']\n        pose_msg.pose.position.y = self.current_pose['y']\n        pose_msg.pose.orientation.w = 1.0  # Simplified orientation\n\n        self.pose_pub.publish(pose_msg)\n\n    def execute_callback(self, goal_handle):\n        \"\"\"Execute callback (placeholder - actual execution in separate thread).\"\"\"\n        # This method is required by the action server interface\n        # Actual execution happens in execute_navigation in separate thread\n        pass\n"})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-action-client-with-comprehensive-features",children:"Advanced Action Client with Comprehensive Features"}),"\n",(0,t.jsx)(n.p,{children:"Action clients need to handle various scenarios including timeouts, feedback, and result processing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.action import ActionClient\nfrom geometry_msgs.action import NavigateToPose\nfrom control_msgs.action import FollowJointTrajectory\nimport time\n\nclass AdvancedNavigationActionClient(Node):\n    def __init__(self):\n        super().__init__('advanced_navigation_action_client')\n\n        # Create action client\n        self._action_client = ActionClient(\n            self, NavigateToPose, 'navigate_to_pose'\n        )\n\n        # Wait for action server\n        self.get_logger().info('Waiting for navigation action server...')\n        self._action_client.wait_for_server()\n        self.get_logger().info('Navigation action server available')\n\n        # Statistics tracking\n        self.navigation_stats = {\n            'completed': 0,\n            'cancelled': 0,\n            'failed': 0,\n            'avg_duration': 0.0\n        }\n\n    def send_navigation_goal(self, x, y, theta=0.0, timeout_sec=60.0):\n        \"\"\"Send navigation goal with comprehensive handling.\"\"\"\n        # Create goal message\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.pose.position.x = x\n        goal_msg.pose.pose.position.y = y\n        goal_msg.pose.pose.orientation.z = math.sin(theta / 2.0)\n        goal_msg.pose.pose.orientation.w = math.cos(theta / 2.0)\n\n        self.get_logger().info(f'Sending navigation goal to ({x}, {y}, {theta})')\n\n        # Send goal asynchronously\n        goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n\n        # Add goal response callback\n        goal_future.add_done_callback(\n            lambda future: self.goal_response_callback(future, timeout_sec)\n        )\n\n        return goal_future\n\n    def goal_response_callback(self, future, timeout_sec):\n        \"\"\"Handle goal response.\"\"\"\n        goal_handle = future.result()\n\n        if not goal_handle.accepted:\n            self.get_logger().info('Navigation goal rejected by server')\n            return\n\n        self.get_logger().info('Navigation goal accepted by server')\n\n        # Get result future\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(self.result_callback)\n\n        # Set up timeout monitoring\n        start_time = time.time()\n        self.monitor_navigation_timeout(goal_handle, start_time, timeout_sec)\n\n    def feedback_callback(self, feedback_msg):\n        \"\"\"Handle navigation feedback.\"\"\"\n        current_pos = feedback_msg.current_pose.pose.position\n        remaining = feedback_msg.distance_remaining\n\n        self.get_logger().info(\n            f'Navigation progress: position=({current_pos.x:.2f}, {current_pos.y:.2f}), '\n            f'distance remaining={remaining:.2f}m'\n        )\n\n    def result_callback(self, result_future):\n        \"\"\"Handle navigation result.\"\"\"\n        result = result_future.result().result\n        status = result_future.result().status\n\n        if status == GoalStatus.STATUS_SUCCEEDED:\n            self.get_logger().info('Navigation completed successfully')\n            self.navigation_stats['completed'] += 1\n        elif status == GoalStatus.STATUS_CANCELED:\n            self.get_logger().info('Navigation was cancelled')\n            self.navigation_stats['cancelled'] += 1\n        elif status == GoalStatus.STATUS_ABORTED:\n            self.get_logger().info('Navigation failed')\n            self.navigation_stats['failed'] += 1\n\n    def monitor_navigation_timeout(self, goal_handle, start_time, timeout_sec):\n        \"\"\"Monitor navigation for timeout.\"\"\"\n        if time.time() - start_time > timeout_sec:\n            self.get_logger().warn('Navigation timeout, cancelling goal...')\n            self.cancel_current_navigation(goal_handle)\n        else:\n            # Schedule next check\n            timer = self.create_timer(\n                1.0,\n                lambda: self.monitor_navigation_timeout(goal_handle, start_time, timeout_sec)\n            )\n\n    def cancel_current_navigation(self, goal_handle):\n        \"\"\"Cancel current navigation goal.\"\"\"\n        cancel_future = goal_handle.cancel_goal_async()\n        cancel_future.add_done_callback(self.cancel_response_callback)\n\n    def cancel_response_callback(self, future):\n        \"\"\"Handle cancellation response.\"\"\"\n        cancel_response = future.result()\n        if len(cancel_response.goals_canceling) > 0:\n            self.get_logger().info('Navigation goal successfully cancelled')\n        else:\n            self.get_logger().info('Navigation goal could not be cancelled')\n\n    def send_multiple_goals(self, waypoints):\n        \"\"\"Send multiple navigation goals in sequence.\"\"\"\n        for i, (x, y, theta) in enumerate(waypoints):\n            self.get_logger().info(f'Sending waypoint {i+1}: ({x}, {y}, {theta})')\n            self.send_navigation_goal(x, y, theta)\n\n            # Wait between goals (in a real implementation, this would be more sophisticated)\n            time.sleep(2)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"communication-pattern-integration",children:"Communication Pattern Integration"}),"\n",(0,t.jsx)(n.h3,{id:"comprehensive-multi-pattern-system",children:"Comprehensive Multi-Pattern System"}),"\n",(0,t.jsx)(n.p,{children:"Here's a complete example that demonstrates all three communication patterns working together in a sophisticated robotic system:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, qos_profile_sensor_data, qos_profile_services_default\nfrom std_msgs.msg import String, Float64, Bool\nfrom sensor_msgs.msg import LaserScan, Imu\nfrom geometry_msgs.msg import Twist, PoseStamped\nfrom nav_msgs.msg import Odometry\nfrom example_interfaces.srv import SetBool, AddTwoInts\nfrom example_interfaces.action import Fibonacci\nfrom rclpy.action import ActionClient, ActionServer, GoalResponse, CancelResponse\nimport threading\nimport time\nimport math\n\nclass IntegratedRobotSystemNode(Node):\n    def __init__(self):\n        super().__init__('integrated_robot_system')\n\n        # TOPIC: Publishers for system state\n        self.status_pub = self.create_publisher(String, 'system_status', 10)\n        self.odom_pub = self.create_publisher(Odometry, 'robot_odometry', 10)\n        self.cmd_vel_pub = self.create_publisher(Twist, 'robot_cmd_vel', 10)\n        self.sensor_fusion_pub = self.create_publisher(String, 'sensor_fusion_result', 10)\n\n        # TOPIC: Subscribers for sensor data and commands\n        self.laser_sub = self.create_subscription(\n            LaserScan, 'laser_scan', self.laser_callback,\n            qos_profile=qos_profile_sensor_data\n        )\n        self.imu_sub = self.create_subscription(\n            Imu, 'imu_data', self.imu_callback,\n            qos_profile=qos_profile_sensor_data\n        )\n        self.cmd_sub = self.create_subscription(\n            Twist, 'teleop_cmd', self.teleop_cmd_callback, 10\n        )\n\n        # SERVICE: Servers for immediate system control\n        self.emergency_stop_srv = self.create_service(\n            SetBool, 'emergency_stop', self.emergency_stop_callback\n        )\n        self.system_diag_srv = self.create_service(\n            SetBool, 'system_diagnostics', self.system_diagnostics_callback\n        )\n\n        # SERVICE: Clients for external services\n        self.navigation_client = self.create_client(\n            SetBool, 'navigation_service'\n        )\n        self.manipulation_client = self.create_client(\n            SetBool, 'manipulation_service'\n        )\n\n        # ACTION: Action server for complex missions\n        self.mission_action_server = ActionServer(\n            self, Fibonacci, 'mission_execution',\n            self.mission_execute_callback,\n            goal_callback=self.mission_goal_callback,\n            cancel_callback=self.mission_cancel_callback\n        )\n\n        # ACTION: Action client for external actions\n        self.external_action_client = ActionClient(\n            self, Fibonacci, 'external_task'\n        )\n\n        # System state\n        self.system_state = {\n            'is_active': True,\n            'is_emergency_stopped': False,\n            'safety_level': 'normal',\n            'current_mission': None,\n            'battery_level': 100.0,\n            'sensor_data': {}\n        }\n\n        # Timers for periodic updates\n        self.status_timer = self.create_timer(1.0, self.publish_system_status)\n        self.safety_timer = self.create_timer(0.1, self.check_safety_conditions)\n\n        # Statistics\n        self.stats = {\n            'messages_processed': 0,\n            'services_called': 0,\n            'actions_completed': 0\n        }\n\n    def laser_callback(self, msg):\n        \"\"\"Handle laser data via topic.\"\"\"\n        self.stats['messages_processed'] += 1\n\n        # Process laser data for obstacle detection\n        if msg.ranges:\n            min_range = min([r for r in msg.ranges if not math.isnan(r)], default=float('inf'))\n            self.system_state['sensor_data']['min_obstacle_dist'] = min_range\n\n            if min_range < 0.5 and self.system_state['is_active']:\n                self.get_logger().warn(f'Obstacle detected at {min_range:.2f}m')\n                if self.system_state['safety_level'] == 'normal':\n                    self.system_state['safety_level'] = 'caution'\n\n    def imu_callback(self, msg):\n        \"\"\"Handle IMU data via topic.\"\"\"\n        self.stats['messages_processed'] += 1\n\n        # Extract orientation and acceleration data\n        self.system_state['sensor_data']['orientation'] = {\n            'x': msg.orientation.x,\n            'y': msg.orientation.y,\n            'z': msg.orientation.z,\n            'w': msg.orientation.w\n        }\n        self.system_state['sensor_data']['linear_accel'] = {\n            'x': msg.linear_acceleration.x,\n            'y': msg.linear_acceleration.y,\n            'z': msg.linear_acceleration.z\n        }\n\n    def teleop_cmd_callback(self, msg):\n        \"\"\"Handle teleoperation commands via topic.\"\"\"\n        self.stats['messages_processed'] += 1\n\n        if not self.system_state['is_emergency_stopped']:\n            # Forward command to robot\n            self.cmd_vel_pub.publish(msg)\n        else:\n            self.get_logger().warn('Command ignored due to emergency stop')\n\n    def emergency_stop_callback(self, request, response):\n        \"\"\"Handle emergency stop via service.\"\"\"\n        self.stats['services_called'] += 1\n\n        if request.data:  # Activate emergency stop\n            self.system_state['is_emergency_stopped'] = True\n            self.system_state['is_active'] = False\n            self.system_state['safety_level'] = 'emergency'\n\n            # Stop all robot movement\n            stop_cmd = Twist()\n            self.cmd_vel_pub.publish(stop_cmd)\n\n            response.success = True\n            response.message = 'Emergency stop activated'\n            self.get_logger().error('EMERGENCY STOP ACTIVATED')\n        else:  # Release emergency stop\n            self.system_state['is_emergency_stopped'] = False\n            self.system_state['is_active'] = True\n            self.system_state['safety_level'] = 'normal'\n\n            response.success = True\n            response.message = 'Emergency stop released'\n            self.get_logger().info('Emergency stop released')\n\n        return response\n\n    def system_diagnostics_callback(self, request, response):\n        \"\"\"Handle system diagnostics via service.\"\"\"\n        self.stats['services_called'] += 1\n\n        # Perform system diagnostics\n        diagnostics = self.perform_system_diagnostics()\n\n        response.success = diagnostics['overall_status']\n        response.message = f\"System diagnostics: {diagnostics['summary']}\"\n\n        return response\n\n    def perform_system_diagnostics(self):\n        \"\"\"Perform comprehensive system diagnostics.\"\"\"\n        diagnostics = {\n            'overall_status': True,\n            'summary': '',\n            'components': {}\n        }\n\n        # Check sensor systems\n        if 'min_obstacle_dist' in self.system_state['sensor_data']:\n            diagnostics['components']['sensors'] = {\n                'status': True,\n                'details': f\"Laser: min obstacle {self.system_state['sensor_data']['min_obstacle_dist']:.2f}m\"\n            }\n        else:\n            diagnostics['components']['sensors'] = {\n                'status': False,\n                'details': \"No sensor data received\"\n            }\n            diagnostics['overall_status'] = False\n\n        # Check battery level\n        diagnostics['components']['power'] = {\n            'status': self.system_state['battery_level'] > 20.0,\n            'details': f\"Battery: {self.system_state['battery_level']:.1f}%\"\n        }\n        if not diagnostics['components']['power']['status']:\n            diagnostics['overall_status'] = False\n\n        # Compile summary\n        status_list = [name for name, comp in diagnostics['components'].items() if comp['status']]\n        diagnostics['summary'] = f\"OK: {', '.join(status_list)}\" if diagnostics['overall_status'] else \"Issues detected\"\n\n        return diagnostics\n\n    def mission_goal_callback(self, goal_request):\n        \"\"\"Handle mission goal requests.\"\"\"\n        self.get_logger().info(f'Received mission goal: order {goal_request.order}')\n\n        # Validate mission goal\n        if goal_request.order < 0 or goal_request.order > 50:\n            return GoalResponse.REJECT\n        else:\n            return GoalResponse.ACCEPT\n\n    def mission_cancel_callback(self, goal_handle):\n        \"\"\"Handle mission cancellation requests.\"\"\"\n        self.get_logger().info('Mission cancellation requested')\n        return CancelResponse.ACCEPT\n\n    def mission_execute_callback(self, goal_handle):\n        \"\"\"Execute complex mission.\"\"\"\n        self.stats['actions_completed'] += 1\n\n        self.get_logger().info('Starting mission execution...')\n        self.system_state['current_mission'] = goal_handle.goal_id.uuid\n\n        # Create feedback and result messages\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        result_msg = Fibonacci.Result()\n\n        try:\n            # Execute mission steps\n            for i in range(1, goal_handle.request.order):\n                # Check for cancellation\n                if goal_handle.is_cancel_requested:\n                    goal_handle.canceled()\n                    result_msg.sequence = feedback_msg.sequence\n                    self.system_state['current_mission'] = None\n                    return\n\n                # Simulate mission step (e.g., navigation, manipulation, etc.)\n                next_step = feedback_msg.sequence[i] + feedback_msg.sequence[i-1]\n                feedback_msg.sequence.append(next_step)\n\n                # Publish feedback\n                goal_handle.publish_feedback(feedback_msg)\n\n                # Log progress\n                self.get_logger().info(f'Mission step {i} completed')\n\n                # Simulate processing time\n                time.sleep(0.5)\n\n            # Complete mission successfully\n            goal_handle.succeed()\n            result_msg.sequence = feedback_msg.sequence\n\n        except Exception as e:\n            self.get_logger().error(f'Mission execution error: {e}')\n            goal_handle.abort()\n            result_msg.sequence = feedback_msg.sequence\n\n        finally:\n            self.system_state['current_mission'] = None\n            goal_handle.publish_result(result_msg)\n\n    def publish_system_status(self):\n        \"\"\"Publish system status via topic.\"\"\"\n        status_msg = String()\n        status_msg.data = (\n            f\"Status: {'ACTIVE' if self.system_state['is_active'] else 'INACTIVE'}, \"\n            f\"Safety: {self.system_state['safety_level']}, \"\n            f\"Battery: {self.system_state['battery_level']:.1f}%, \"\n            f\"Missions: {self.stats['actions_completed']}\"\n        )\n        self.status_pub.publish(status_msg)\n\n    def check_safety_conditions(self):\n        \"\"\"Check safety conditions and update state.\"\"\"\n        # Check for critical safety violations\n        if ('min_obstacle_dist' in self.system_state['sensor_data'] and\n            self.system_state['sensor_data']['min_obstacle_dist'] < 0.2):\n            self.get_logger().error('CRITICAL: Very close obstacle detected!')\n            if self.system_state['safety_level'] != 'emergency':\n                self.system_state['safety_level'] = 'critical'\n\n                # Emergency stop if needed\n                if self.system_state['safety_level'] == 'critical':\n                    stop_cmd = Twist()\n                    self.cmd_vel_pub.publish(stop_cmd)\n\n    def get_system_summary(self):\n        \"\"\"Get comprehensive system summary.\"\"\"\n        summary = {\n            'state': self.system_state,\n            'stats': self.stats,\n            'timestamp': self.get_clock().now().nanoseconds\n        }\n        return summary\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-optimization-and-best-practices",children:"Performance Optimization and Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"memory-and-resource-optimization",children:"Memory and Resource Optimization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class OptimizedCommunicationNode(Node):\n    def __init__(self):\n        super().__init__(\'optimized_communication\')\n\n        # Pre-allocate message objects to reduce allocation overhead\n        self._string_msg = String()\n        self._float_msg = Float64()\n        self._twist_msg = Twist()\n        self._pose_msg = PoseStamped()\n\n        # Publishers with optimized QoS\n        self.optimized_topic_pub = self.create_publisher(\n            String, \'optimized_topic\', 10\n        )\n\n        # Message pools for high-frequency operations\n        self.message_pool = []\n        self.pool_lock = threading.Lock()\n\n        # Optimized timer for high-frequency publishing\n        self.fast_timer = self.create_timer(0.001, self.optimized_publish)\n\n    def optimized_publish(self):\n        """Optimized publishing using pre-allocated messages."""\n        # Reuse message object\n        self._string_msg.data = f\'Optimized: {self.get_clock().now().nanoseconds}\'\n        self.optimized_topic_pub.publish(self._string_msg)\n\n    def get_message_from_pool(self, msg_type):\n        """Get message from pool or create new one."""\n        with self.pool_lock:\n            if self.message_pool and len(self.message_pool) > 0:\n                return self.message_pool.pop()\n            else:\n                return msg_type()\n\n    def return_message_to_pool(self, msg):\n        """Return message to pool for reuse."""\n        with self.pool_lock:\n            if len(self.message_pool) < 100:  # Limit pool size\n                self.message_pool.append(msg)\n\nclass CommunicationBridgeNode(Node):\n    def __init__(self):\n        super().__init__(\'communication_bridge\')\n\n        # Bridge between different message types and patterns\n        self.input_topic_sub = self.create_subscription(\n            String, \'input_topic\', self.topic_bridge_callback, 10\n        )\n\n        self.input_service = self.create_service(\n            SetBool, \'input_service\', self.service_bridge_callback\n        )\n\n        # Output interfaces\n        self.output_topic_pub = self.create_publisher(\n            Float64, \'output_topic\', 10\n        )\n\n        self.output_service_client = self.create_client(\n            SetBool, \'output_service\'\n        )\n\n    def topic_bridge_callback(self, msg):\n        """Bridge topic to other patterns."""\n        try:\n            # Convert string to number\n            value = float(msg.data)\n\n            # Publish to output topic\n            output_msg = Float64()\n            output_msg.data = value * 2  # Example transformation\n            self.output_topic_pub.publish(output_msg)\n\n            # Call output service (if needed)\n            if value > 10.0:\n                service_request = SetBool.Request()\n                service_request.data = True\n                self.output_service_client.call_async(service_request)\n\n        except ValueError:\n            self.get_logger().error(f\'Cannot convert {msg.data} to float\')\n\n    def service_bridge_callback(self, request, response):\n        """Bridge service to other patterns."""\n        # Forward service call to topic\n        topic_msg = String()\n        topic_msg.data = f\'Service called with: {request.data}\'\n        self.output_topic_pub.publish(topic_msg)\n\n        response.success = True\n        response.message = \'Service bridged to topic\'\n        return response\n'})}),"\n",(0,t.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,t.jsx)(n.p,{children:"This comprehensive section has explored the three fundamental communication patterns in ROS 2: topics, services, and actions. We've covered advanced implementation techniques, best practices, and practical examples that demonstrate how these patterns work together in sophisticated robotic applications."}),"\n",(0,t.jsx)(n.p,{children:"The key concepts covered include:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Topics"}),": Advanced publish/subscribe patterns with filtering, monitoring, and optimization techniques for continuous data streams."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Services"}),": Robust request/response implementations with error handling, chaining, and load balancing for immediate computations."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": Complex goal-oriented communication with feedback, cancellation, and state management for long-running tasks."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Integration"}),": How all three patterns work together in comprehensive robotic systems to provide seamless communication and coordination."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These communication patterns form the foundation for all complex robotic applications, enabling the coordination of multiple subsystems in sophisticated systems like humanoid robots where precise timing, reliability, and feedback are critical."}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implementation"}),": Create a ROS 2 node that implements a sensor fusion system using topics for individual sensor data, services for calibration requests, and actions for complex processing tasks that require feedback."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Analysis"}),": Design a communication architecture for a multi-robot coordination system. Identify which communication patterns would be most appropriate for robot-to-robot communication, task coordination, and shared state management."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Optimization"}),": Implement a message filtering and transformation node that receives high-frequency sensor data, applies various filtering techniques, and publishes the processed data with appropriate QoS settings."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["ROS 2 Documentation: Communication Patterns - ",(0,t.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Concepts/About-Topics-Services-Actions.html",children:"https://docs.ros.org/en/humble/Concepts/About-Topics-Services-Actions.html"})]}),"\n",(0,t.jsxs)(n.li,{children:["ROS 2 Design: Quality of Service - ",(0,t.jsx)(n.a,{href:"https://design.ros2.org/articles/qos.html",children:"https://design.ros2.org/articles/qos.html"})]}),"\n",(0,t.jsxs)(n.li,{children:["Real-time ROS 2: Communication Optimization - ",(0,t.jsx)(n.a,{href:"https://ros-realtime.github.io/",children:"https://ros-realtime.github.io/"})]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(_,{...e})}):_(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var t=s(6540);const a={},i=t.createContext(a);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);