"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[9021],{1948:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>t,contentTitle:()=>r,default:()=>f,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var n=s(4848),l=s(8453);const o={title:"Quality of Service (QoS) in ROS 2"},r="Quality of Service (QoS) in ROS 2",a={id:"ros2-advanced/quality-of-service",title:"Quality of Service (QoS) in ROS 2",description:"Introduction to Quality of Service",source:"@site/docs/physical-ai/ros2-advanced/quality-of-service.mdx",sourceDirName:"ros2-advanced",slug:"/ros2-advanced/quality-of-service",permalink:"/ros2-advanced/quality-of-service",draft:!1,unlisted:!1,editUrl:"https://github.com/MuhammadFuzail591/new-book-physical-ai/tree/main/docs/physical-ai/ros2-advanced/quality-of-service.mdx",tags:[],version:"current",frontMatter:{title:"Quality of Service (QoS) in ROS 2"},sidebar:"tutorialSidebar",previous:{title:"Dynamic Parameters in ROS 2",permalink:"/ros2-advanced/parameters"},next:{title:"Chapter 6 Summary - Advanced ROS 2 Concepts",permalink:"/ros2-advanced/chapter-summary"}},t={},c=[{value:"Introduction to Quality of Service",id:"introduction-to-quality-of-service",level:2},{value:"QoS Policy Overview",id:"qos-policy-overview",level:2},{value:"Core QoS Policies",id:"core-qos-policies",level:3},{value:"Predefined QoS Profiles",id:"predefined-qos-profiles",level:3},{value:"Reliability Policy",id:"reliability-policy",level:2},{value:"Best Effort vs Reliable Delivery",id:"best-effort-vs-reliable-delivery",level:3},{value:"Durability Policy",id:"durability-policy",level:2},{value:"Volatile vs Transient Local Durability",id:"volatile-vs-transient-local-durability",level:3},{value:"History Policy and Depth",id:"history-policy-and-depth",level:2},{value:"Managing Message History",id:"managing-message-history",level:3},{value:"Advanced QoS Configuration",id:"advanced-qos-configuration",level:2},{value:"Custom QoS Profiles for Specialized Requirements",id:"custom-qos-profiles-for-specialized-requirements",level:3},{value:"QoS Matching and Compatibility",id:"qos-matching-and-compatibility",level:2},{value:"Understanding QoS Compatibility",id:"understanding-qos-compatibility",level:3},{value:"Practical QoS Examples",id:"practical-qos-examples",level:2},{value:"Sensor Data Pipeline",id:"sensor-data-pipeline",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Optimizing QoS for Performance",id:"optimizing-qos-for-performance",level:3},{value:"Best Practices for QoS Configuration",id:"best-practices-for-qos-configuration",level:2},{value:"Guidelines for QoS Selection",id:"guidelines-for-qos-selection",level:3}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,l.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.h1,{id:"quality-of-service-qos-in-ros-2",children:"Quality of Service (QoS) in ROS 2"}),"\n",(0,n.jsx)(i.h2,{id:"introduction-to-quality-of-service",children:"Introduction to Quality of Service"}),"\n",(0,n.jsx)(i.p,{children:"Quality of Service (QoS) in ROS 2 provides fine-grained control over communication behavior between nodes. QoS policies determine how messages are delivered, stored, and handled in the face of network issues or system constraints. Proper QoS configuration is essential for ensuring reliable communication in robotic systems with diverse requirements."}),"\n",(0,n.jsx)(i.p,{children:"Unlike traditional communication systems where reliability is an all-or-nothing proposition, ROS 2's QoS system allows you to tune communication characteristics to match the specific needs of your robotic application. This is particularly important in robotics where different types of data have vastly different requirements - sensor data may be high-frequency but can tolerate some loss, while control commands must be delivered reliably."}),"\n",(0,n.jsx)(i.h2,{id:"qos-policy-overview",children:"QoS Policy Overview"}),"\n",(0,n.jsx)(i.h3,{id:"core-qos-policies",children:"Core QoS Policies"}),"\n",(0,n.jsx)(i.p,{children:"ROS 2's QoS system consists of several key policies that can be configured independently:"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Reliability Policy"}),": Controls whether messages are delivered reliably or on a best-effort basis"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Durability Policy"}),": Determines how messages persist for late-joining subscribers"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"History Policy"}),": Specifies how many messages to store and when to store them"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Deadline Policy"}),": Sets the maximum time between consecutive messages"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Lifespan Policy"}),": Defines how long messages remain valid after publication"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Liveliness Policy"}),": Ensures publishers and subscribers are active"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Depth Policy"}),": Controls the size of the message queue"]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"predefined-qos-profiles",children:"Predefined QoS Profiles"}),"\n",(0,n.jsx)(i.p,{children:"ROS 2 provides several predefined QoS profiles optimized for common use cases:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import (\n    QoSProfile,\n    QoSDurabilityPolicy,\n    QoSHistoryPolicy,\n    QoSReliabilityPolicy,\n    QoSLivelinessPolicy\n)\nfrom sensor_msgs.msg import LaserScan\nfrom std_msgs.msg import String\nfrom geometry_msgs.msg import Twist\n\nclass QoSProfileDemoNode(Node):\n    def __init__(self):\n        super().__init__('qos_profile_demo')\n\n        # Default QoS profile - balanced for general use\n        default_qos = rclpy.qos.qos_profile_default\n\n        # Sensor data QoS - optimized for high-frequency data\n        sensor_qos = rclpy.qos.qos_profile_sensor_data\n\n        # Services QoS - for reliable service calls\n        services_qos = rclpy.qos.qos_profile_services_default\n\n        # Parameters QoS - for reliable parameter updates\n        parameters_qos = rclpy.qos.qos_profile_parameters\n\n        # Create publishers with different QoS profiles\n        self.sensor_pub = self.create_publisher(LaserScan, 'laser_scan', sensor_qos)\n        self.cmd_pub = self.create_publisher(Twist, 'cmd_vel', default_qos)\n        self.status_pub = self.create_publisher(String, 'robot_status', parameters_qos)\n\n        # Create subscribers with matching QoS profiles\n        self.sensor_sub = self.create_subscription(\n            LaserScan, 'laser_scan', self.sensor_callback, sensor_qos\n        )\n        self.cmd_sub = self.create_subscription(\n            Twist, 'cmd_vel', self.cmd_callback, default_qos\n        )\n\n    def sensor_callback(self, msg):\n        \"\"\"Handle sensor data with best-effort delivery\"\"\"\n        self.get_logger().debug(f'Sensor data received: {len(msg.ranges)} ranges')\n\n    def cmd_callback(self, msg):\n        \"\"\"Handle command data with reliable delivery\"\"\"\n        self.get_logger().info(f'Command received: linear={msg.linear.x}, angular={msg.angular.z}')\n"})}),"\n",(0,n.jsx)(i.h2,{id:"reliability-policy",children:"Reliability Policy"}),"\n",(0,n.jsx)(i.h3,{id:"best-effort-vs-reliable-delivery",children:"Best Effort vs Reliable Delivery"}),"\n",(0,n.jsx)(i.p,{children:"The reliability policy determines whether ROS 2 should guarantee message delivery:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, QoSReliabilityPolicy\n\nclass ReliabilityDemoNode(Node):\n    def __init__(self):\n        super().__init__('reliability_demo')\n\n        # Best effort - no guarantee of delivery, maximum performance\n        best_effort_qos = QoSProfile(\n            reliability=QoSReliabilityPolicy.BEST_EFFORT,\n            history=rclpy.qos.QoSHistoryPolicy.KEEP_LAST,\n            depth=10\n        )\n\n        # Reliable - guaranteed delivery, may impact performance\n        reliable_qos = QoSProfile(\n            reliability=QoSReliabilityPolicy.RELIABLE,\n            history=rclpy.qos.QoSHistoryPolicy.KEEP_LAST,\n            depth=10\n        )\n\n        # High-frequency sensor data (e.g., LIDAR) - best effort\n        self.sensor_pub = self.create_publisher(LaserScan, 'sensor_data', best_effort_qos)\n        self.sensor_sub = self.create_subscription(\n            LaserScan, 'sensor_data', self.sensor_callback, best_effort_qos\n        )\n\n        # Critical control commands - reliable\n        self.control_pub = self.create_publisher(Twist, 'control_commands', reliable_qos)\n        self.control_sub = self.create_subscription(\n            Twist, 'control_commands', self.control_callback, reliable_qos\n        )\n\n        self.get_logger().info('Reliability demo node initialized')\n\n    def sensor_callback(self, msg):\n        \"\"\"Handle sensor data - occasional dropped messages are acceptable\"\"\"\n        self.get_logger().debug(f'Received sensor data, timestamp: {msg.header.stamp}')\n\n    def control_callback(self, msg):\n        \"\"\"Handle control commands - must be delivered reliably\"\"\"\n        self.get_logger().info(f'Received critical control command')\n"})}),"\n",(0,n.jsx)(i.h2,{id:"durability-policy",children:"Durability Policy"}),"\n",(0,n.jsx)(i.h3,{id:"volatile-vs-transient-local-durability",children:"Volatile vs Transient Local Durability"}),"\n",(0,n.jsx)(i.p,{children:"The durability policy controls how messages are stored for late-joining subscribers:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'from rclpy.qos import QoSProfile, QoSDurabilityPolicy\nfrom rclpy.duration import Duration\n\nclass DurabilityDemoNode(Node):\n    def __init__(self):\n        super().__init__(\'durability_demo\')\n\n        # Volatile - messages are not stored for late joiners\n        volatile_qos = QoSProfile(\n            durability=QoSDurabilityPolicy.VOLATILE,\n            history=rclpy.qos.QoSHistoryPolicy.KEEP_LAST,\n            depth=5\n        )\n\n        # Transient Local - messages are stored and delivered to late joiners\n        transient_qos = QoSProfile(\n            durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,\n            history=rclpy.qos.QoSHistoryPolicy.KEEP_LAST,\n            depth=1\n        )\n\n        # Sensor data - no need to store for late joiners\n        self.volatile_pub = self.create_publisher(String, \'sensor_updates\', volatile_qos)\n        self.volatile_sub = self.create_subscription(\n            String, \'sensor_updates\', self.volatile_callback, volatile_qos\n        )\n\n        # Configuration/status updates - should be available to late joiners\n        self.transient_pub = self.create_publisher(String, \'config_updates\', transient_qos)\n        self.transient_sub = self.create_subscription(\n            String, \'config_updates\', self.transient_callback, transient_qos\n        )\n\n        # Timer to periodically publish status updates\n        self.status_timer = self.create_timer(2.0, self.publish_status)\n        self.config_timer = self.create_timer(5.0, self.publish_config)\n\n        self.status_counter = 0\n        self.config_counter = 0\n\n    def publish_status(self):\n        """Publish status updates with volatile durability"""\n        msg = String()\n        msg.data = f\'Status update {self.status_counter}\'\n        self.volatile_pub.publish(msg)\n        self.status_counter += 1\n\n    def publish_config(self):\n        """Publish configuration updates with transient durability"""\n        msg = String()\n        msg.data = f\'Config update {self.config_counter}\'\n        self.transient_pub.publish(msg)\n        self.config_counter += 1\n\n    def volatile_callback(self, msg):\n        """Handle volatile messages"""\n        self.get_logger().debug(f\'Volatile message: {msg.data}\')\n\n    def transient_callback(self, msg):\n        """Handle transient messages - these will include old messages for late joiners"""\n        self.get_logger().info(f\'Transient message: {msg.data}\')\n'})}),"\n",(0,n.jsx)(i.h2,{id:"history-policy-and-depth",children:"History Policy and Depth"}),"\n",(0,n.jsx)(i.h3,{id:"managing-message-history",children:"Managing Message History"}),"\n",(0,n.jsx)(i.p,{children:"The history and depth policies control how many messages are stored and when:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'from rclpy.qos import QoSProfile, QoSHistoryPolicy\n\nclass HistoryDemoNode(Node):\n    def __init__(self):\n        super().__init__(\'history_demo\')\n\n        # Keep last N messages - maintains a fixed-size queue\n        keep_last_qos = QoSProfile(\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=10,  # Keep the 10 most recent messages\n            reliability=rclpy.qos.QoSReliabilityPolicy.BEST_EFFORT\n        )\n\n        # Keep all messages - stores all messages (use with caution!)\n        keep_all_qos = QoSProfile(\n            history=QoSHistoryPolicy.KEEP_ALL,\n            reliability=rclpy.qos.QoSReliabilityPolicy.RELIABLE\n        )\n\n        # For real-time sensor data - only keep recent values\n        self.sensor_pub = self.create_publisher(LaserScan, \'realtime_sensor\', keep_last_qos)\n\n        # For logging/analysis - keep all messages\n        self.log_pub = self.create_publisher(String, \'log_messages\', keep_all_qos)\n\n        # Timer to generate sensor data\n        self.sensor_timer = self.create_timer(0.1, self.publish_sensor_data)\n        self.log_timer = self.create_timer(1.0, self.publish_log_message)\n\n        self.scan_counter = 0\n        self.log_counter = 0\n\n    def publish_sensor_data(self):\n        """Publish high-frequency sensor data with limited history"""\n        msg = LaserScan()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = \'sensor_frame\'\n        msg.ranges = [1.0 + (self.scan_counter % 100) * 0.01] * 360  # Simulated data\n        self.sensor_pub.publish(msg)\n        self.scan_counter += 1\n\n    def publish_log_message(self):\n        """Publish log messages that should all be preserved"""\n        msg = String()\n        msg.data = f\'Log entry {self.log_counter}: System status normal at {self.get_clock().now().seconds_nanoseconds()}\'\n        self.log_pub.publish(msg)\n        self.log_counter += 1\n'})}),"\n",(0,n.jsx)(i.h2,{id:"advanced-qos-configuration",children:"Advanced QoS Configuration"}),"\n",(0,n.jsx)(i.h3,{id:"custom-qos-profiles-for-specialized-requirements",children:"Custom QoS Profiles for Specialized Requirements"}),"\n",(0,n.jsx)(i.p,{children:"For specialized applications, you can create custom QoS profiles that combine policies optimally:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'from rclpy.qos import QoSProfile, QoSLivelinessPolicy\nfrom rclpy.duration import Duration\n\nclass CustomQoSNode(Node):\n    def __init__(self):\n        super().__init__(\'custom_qos_node\')\n\n        # Safety-critical messages - must be delivered within deadline\n        safety_qos = QoSProfile(\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=5,\n            reliability=QoSReliabilityPolicy.RELIABLE,\n            durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,\n            deadline=Duration(seconds=1),  # Must be delivered within 1 second\n            lifespan=Duration(seconds=30),  # Keep for 30 seconds\n            liveliness=QoSLivelinessPolicy.AUTOMATIC,\n            liveliness_lease_duration=Duration(seconds=2)\n        )\n\n        # High-frequency data with strict timing requirements\n        high_freq_qos = QoSProfile(\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=1,  # Only keep the most recent message\n            reliability=QoSReliabilityPolicy.BEST_EFFORT,\n            durability=QoSDurabilityPolicy.VOLATILE,\n            deadline=Duration(nanoseconds=100000000),  # 100ms deadline\n            lifespan=Duration(nanoseconds=50000000)   # 50ms lifespan\n        )\n\n        # Diagnostic data - keep all with best effort\n        diagnostic_qos = QoSProfile(\n            history=QoSHistoryPolicy.KEEP_ALL,\n            reliability=QoSReliabilityPolicy.BEST_EFFORT,\n            durability=QoSDurabilityPolicy.VOLATILE,\n            lifespan=Duration(seconds=60)  # Keep diagnostics for 60 seconds\n        )\n\n        # Create publishers with custom QoS\n        self.safety_pub = self.create_publisher(String, \'safety_critical\', safety_qos)\n        self.high_freq_pub = self.create_publisher(String, \'high_frequency\', high_freq_qos)\n        self.diag_pub = self.create_publisher(String, \'diagnostics\', diagnostic_qos)\n\n        # Create subscribers with matching QoS\n        self.safety_sub = self.create_subscription(\n            String, \'safety_critical\', self.safety_callback, safety_qos\n        )\n        self.high_freq_sub = self.create_subscription(\n            String, \'high_frequency\', self.high_freq_callback, high_freq_qos\n        )\n        self.diag_sub = self.create_subscription(\n            String, \'diagnostics\', self.diag_callback, diagnostic_qos\n        )\n\n        # Timer for safety-critical messages\n        self.safety_timer = self.create_timer(0.5, self.publish_safety_message)\n        self.safety_counter = 0\n\n    def publish_safety_message(self):\n        """Publish safety-critical messages with strict QoS requirements"""\n        msg = String()\n        msg.data = f\'Safety check {self.safety_counter}: OK\'\n        self.safety_pub.publish(msg)\n        self.safety_counter += 1\n\n    def safety_callback(self, msg):\n        """Handle safety-critical messages - must arrive within deadline"""\n        self.get_logger().warn(f\'SAFETY: {msg.data}\')\n\n    def high_freq_callback(self, msg):\n        """Handle high-frequency messages - only process the most recent"""\n        self.get_logger().debug(f\'High freq: {msg.data}\')\n\n    def diag_callback(self, msg):\n        """Handle diagnostic messages - all should be preserved"""\n        self.get_logger().info(f\'Diagnostic: {msg.data}\')\n'})}),"\n",(0,n.jsx)(i.h2,{id:"qos-matching-and-compatibility",children:"QoS Matching and Compatibility"}),"\n",(0,n.jsx)(i.h3,{id:"understanding-qos-compatibility",children:"Understanding QoS Compatibility"}),"\n",(0,n.jsx)(i.p,{children:"When a publisher and subscriber have different QoS policies, ROS 2 attempts to find a compatible configuration:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'class QoSCompatibilityDemo(Node):\n    def __init__(self):\n        super().__init__(\'qos_compatibility_demo\')\n\n        # Publisher with specific QoS requirements\n        publisher_qos = QoSProfile(\n            reliability=QoSReliabilityPolicy.RELIABLE,\n            durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=5\n        )\n\n        # Subscriber with different (but compatible) QoS\n        subscriber_qos = QoSProfile(\n            reliability=QoSReliabilityPolicy.BEST_EFFORT,  # Less strict than publisher\n            durability=QoSDurabilityPolicy.VOLATILE,       # Less strict than publisher\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=10  # More generous than publisher\n        )\n\n        # The actual QoS used will be the "intersection" of requirements\n        # In this case: BEST_EFFORT reliability and VOLATILE durability\n        self.publisher = self.create_publisher(String, \'qos_test\', publisher_qos)\n        self.subscriber = self.create_subscription(\n            String, \'qos_test\', self.compatibility_callback, subscriber_qos\n        )\n\n        # Timer to send test messages\n        self.test_timer = self.create_timer(1.0, self.send_test_message)\n        self.message_counter = 0\n\n    def send_test_message(self):\n        """Send test message to demonstrate QoS compatibility"""\n        msg = String()\n        msg.data = f\'Test message {self.message_counter}\'\n        self.publisher.publish(msg)\n        self.message_counter += 1\n\n    def compatibility_callback(self, msg):\n        """Receive message with negotiated QoS"""\n        self.get_logger().info(f\'Received: {msg.data}\')\n\n        # Check the actual QoS being used\n        # Note: There\'s no direct API to query the negotiated QoS in current ROS 2 versions\n        # but you can infer it from behavior\n'})}),"\n",(0,n.jsx)(i.h2,{id:"practical-qos-examples",children:"Practical QoS Examples"}),"\n",(0,n.jsx)(i.h3,{id:"sensor-data-pipeline",children:"Sensor Data Pipeline"}),"\n",(0,n.jsx)(i.p,{children:"A practical example showing how to configure QoS for a sensor data pipeline:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image, LaserScan, Imu\nfrom std_msgs.msg import Header\nfrom rclpy.qos import QoSProfile, QoSHistoryPolicy, QoSReliabilityPolicy, QoSDurabilityPolicy\n\nclass SensorPipelineNode(Node):\n    def __init__(self):\n        super().__init__(\'sensor_pipeline\')\n\n        # Camera images - high frequency, can tolerate some loss\n        self.image_qos = QoSProfile(\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=1,  # Only keep most recent image to avoid lag\n            reliability=QoSReliabilityPolicy.BEST_EFFORT,\n            durability=QoSDurabilityPolicy.VOLATILE\n        )\n\n        # LIDAR scans - high frequency, can tolerate some loss\n        self.lidar_qos = QoSProfile(\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=5,  # Keep a few recent scans\n            reliability=QoSReliabilityPolicy.BEST_EFFORT,\n            durability=QoSDurabilityPolicy.VOLATILE\n        )\n\n        # IMU data - high frequency, can tolerate some loss\n        self.imu_qos = QoSProfile(\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=10,  # Keep more IMU data for filtering\n            reliability=QoSReliabilityPolicy.BEST_EFFORT,\n            durability=QoSDurabilityPolicy.VOLATILE\n        )\n\n        # Processed sensor fusion data - reliable delivery\n        self.fusion_qos = QoSProfile(\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=5,\n            reliability=QoSReliabilityPolicy.RELIABLE,\n            durability=QoSDurabilityPolicy.VOLATILE\n        )\n\n        # Create publishers and subscribers\n        self.image_pub = self.create_publisher(Image, \'camera/image_raw\', self.image_qos)\n        self.lidar_pub = self.create_publisher(LaserScan, \'lidar/scan\', self.lidar_qos)\n        self.imu_pub = self.create_publisher(Imu, \'imu/data\', self.imu_qos)\n        self.fusion_pub = self.create_publisher(String, \'sensor_fusion\', self.fusion_qos)\n\n        self.image_sub = self.create_subscription(\n            Image, \'camera/image_raw\', self.image_callback, self.image_qos\n        )\n        self.lidar_sub = self.create_subscription(\n            LaserScan, \'lidar/scan\', self.lidar_callback, self.lidar_qos\n        )\n        self.imu_sub = self.create_subscription(\n            Imu, \'imu/data\', self.imu_callback, self.imu_qos\n        )\n\n        # Timer to simulate sensor data\n        self.image_timer = self.create_timer(0.033, self.publish_image)  # ~30 FPS\n        self.lidar_timer = self.create_timer(0.1, self.publish_lidar)     # 10 Hz\n        self.imu_timer = self.create_timer(0.01, self.publish_imu)       # 100 Hz\n\n        self.image_counter = 0\n        self.lidar_counter = 0\n        self.imu_counter = 0\n\n    def publish_image(self):\n        """Publish camera image with appropriate QoS"""\n        msg = Image()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = \'camera_frame\'\n        msg.height = 480\n        msg.width = 640\n        msg.encoding = \'rgb8\'\n        msg.is_bigendian = False\n        msg.step = 640 * 3\n        msg.data = [0] * (640 * 480 * 3)  # Simulated data\n\n        self.image_pub.publish(msg)\n        self.image_counter += 1\n\n    def publish_lidar(self):\n        """Publish LIDAR scan with appropriate QoS"""\n        msg = LaserScan()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = \'lidar_frame\'\n        msg.angle_min = -3.14\n        msg.angle_max = 3.14\n        msg.angle_increment = 0.01\n        msg.time_increment = 0.0\n        msg.scan_time = 0.1\n        msg.range_min = 0.1\n        msg.range_max = 30.0\n        msg.ranges = [1.0 + (self.lidar_counter % 100) * 0.01] * 628  # Simulated data\n\n        self.lidar_pub.publish(msg)\n        self.lidar_counter += 1\n\n    def publish_imu(self):\n        """Publish IMU data with appropriate QoS"""\n        msg = Imu()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = \'imu_frame\'\n        # Simulated data\n        self.imu_pub.publish(msg)\n        self.imu_counter += 1\n\n    def image_callback(self, msg):\n        """Process camera image"""\n        self.get_logger().debug(f\'Processed image {self.image_counter}\')\n\n    def lidar_callback(self, msg):\n        """Process LIDAR scan"""\n        self.get_logger().debug(f\'Processed LIDAR scan {self.lidar_counter}\')\n\n    def imu_callback(self, msg):\n        """Process IMU data"""\n        self.get_logger().debug(f\'Processed IMU data {self.imu_counter}\')\n'})}),"\n",(0,n.jsx)(i.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,n.jsx)(i.h3,{id:"optimizing-qos-for-performance",children:"Optimizing QoS for Performance"}),"\n",(0,n.jsx)(i.p,{children:"Proper QoS configuration can significantly impact system performance:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'class QoSPerformanceNode(Node):\n    def __init__(self):\n        super().__init__(\'qos_performance\')\n\n        # For high-frequency data, minimize overhead\n        self.high_freq_qos = QoSProfile(\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=1,  # Minimal queue size\n            reliability=QoSReliabilityPolicy.BEST_EFFORT,  # No ACK overhead\n            durability=QoSDurabilityPolicy.VOLATILE,  # No storage overhead\n        )\n\n        # For critical data, optimize for reliability\n        self.critical_qos = QoSProfile(\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=10,  # Larger queue for burst handling\n            reliability=QoSReliabilityPolicy.RELIABLE,  # Guarantee delivery\n            durability=QoSDurabilityPolicy.VOLATILE,  # But don\'t store for late joiners\n        )\n\n        # Performance monitoring\n        self.create_timer(1.0, self.performance_report)\n        self.message_count = 0\n        self.start_time = self.get_clock().now()\n\n    def performance_report(self):\n        """Report QoS performance metrics"""\n        current_time = self.get_clock().now()\n        elapsed = (current_time - self.start_time).nanoseconds * 1e-9\n        rate = self.message_count / elapsed if elapsed > 0 else 0\n\n        self.get_logger().info(f\'Performance: {rate:.2f} msg/s, {self.message_count} total\')\n'})}),"\n",(0,n.jsx)(i.h2,{id:"best-practices-for-qos-configuration",children:"Best Practices for QoS Configuration"}),"\n",(0,n.jsx)(i.h3,{id:"guidelines-for-qos-selection",children:"Guidelines for QoS Selection"}),"\n",(0,n.jsx)(i.p,{children:"When selecting QoS policies, consider these guidelines:"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Sensor Data"}),": Use BEST_EFFORT reliability and VOLATILE durability"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Control Commands"}),": Use RELIABLE reliability and appropriate durability"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Configuration Parameters"}),": Use RELIABLE reliability and TRANSIENT_LOCAL durability"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Diagnostic Information"}),": Use BEST_EFFORT reliability and VOLATILE durability"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Safety-Critical Messages"}),": Use RELIABLE reliability with deadlines"]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Quality of Service policies in ROS 2 provide powerful control over communication behavior, allowing you to optimize your robotic applications for specific requirements regarding reliability, performance, and resource usage. Understanding and properly configuring QoS is essential for building robust and efficient robotic systems."})]})}function f(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>r,x:()=>a});var n=s(6540);const l={},o=n.createContext(l);function r(e){const i=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),n.createElement(o.Provider,{value:i},e.children)}}}]);