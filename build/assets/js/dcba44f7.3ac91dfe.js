"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[2606],{1483:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var s=i(4848),t=i(8453);const r={title:"Physics Engines in Gazebo - ODE, Bullet, and Simbody"},o="Physics Engines in Gazebo: ODE, Bullet, and Simbody",a={id:"physical-ai/gazebo-simulation/physics-engines",title:"Physics Engines in Gazebo - ODE, Bullet, and Simbody",description:"Introduction to Physics Simulation",source:"@site/docs/physical-ai/gazebo-simulation/physics-engines.mdx",sourceDirName:"physical-ai/gazebo-simulation",slug:"/physical-ai/gazebo-simulation/physics-engines",permalink:"/physical-ai-textbook/physical-ai/physical-ai/gazebo-simulation/physics-engines",draft:!1,unlisted:!1,editUrl:"https://github.com/your-username/physical-ai-textbook/tree/main/docs/physical-ai/gazebo-simulation/physics-engines.mdx",tags:[],version:"current",frontMatter:{title:"Physics Engines in Gazebo - ODE, Bullet, and Simbody"},sidebar:"tutorialSidebar",previous:{title:"Chapter 7 - Gazebo Simulation: Physics, Sensors & World Building",permalink:"/physical-ai-textbook/physical-ai/physical-ai/gazebo-simulation/"},next:{title:"World Building in Gazebo - Environments, Objects, and Scenarios",permalink:"/physical-ai-textbook/physical-ai/physical-ai/gazebo-simulation/world-building"}},c={},l=[{value:"Introduction to Physics Simulation",id:"introduction-to-physics-simulation",level:2},{value:"Overview of Available Physics Engines",id:"overview-of-available-physics-engines",level:2},{value:"1. Open Dynamics Engine (ODE)",id:"1-open-dynamics-engine-ode",level:3},{value:"2. Bullet Physics",id:"2-bullet-physics",level:3},{value:"3. Simbody",id:"3-simbody",level:3},{value:"Physics Engine Selection for Humanoid Robots",id:"physics-engine-selection-for-humanoid-robots",level:2},{value:"ODE for Humanoid Applications",id:"ode-for-humanoid-applications",level:3},{value:"Bullet for Complex Environments",id:"bullet-for-complex-environments",level:3},{value:"Simbody for Precise Motion",id:"simbody-for-precise-motion",level:3},{value:"Advanced Physics Configuration",id:"advanced-physics-configuration",level:2},{value:"Contact Properties",id:"contact-properties",level:3},{value:"Joint Physics Configuration",id:"joint-physics-configuration",level:3},{value:"Performance Optimization Strategies",id:"performance-optimization-strategies",level:2},{value:"Time Step Optimization",id:"time-step-optimization",level:3},{value:"Solver Parameter Tuning",id:"solver-parameter-tuning",level:3},{value:"Physics Engine Benchmarking",id:"physics-engine-benchmarking",level:2},{value:"Simple Benchmark Test",id:"simple-benchmark-test",level:3},{value:"Troubleshooting Common Physics Issues",id:"troubleshooting-common-physics-issues",level:2},{value:"1. Unstable Contact Simulation",id:"1-unstable-contact-simulation",level:3},{value:"2. Slow Performance",id:"2-slow-performance",level:3},{value:"3. Penetration Issues",id:"3-penetration-issues",level:3},{value:"Best Practices for Physics Configuration",id:"best-practices-for-physics-configuration",level:2},{value:"1. Start Conservative",id:"1-start-conservative",level:3},{value:"2. Match Real-World Properties",id:"2-match-real-world-properties",level:3},{value:"3. Validate with Simple Tests",id:"3-validate-with-simple-tests",level:3},{value:"4. Document Configuration Changes",id:"4-document-configuration-changes",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"physics-engines-in-gazebo-ode-bullet-and-simbody",children:"Physics Engines in Gazebo: ODE, Bullet, and Simbody"}),"\n",(0,s.jsx)(n.h2,{id:"introduction-to-physics-simulation",children:"Introduction to Physics Simulation"}),"\n",(0,s.jsx)(n.p,{children:"Physics simulation is the cornerstone of realistic robot simulation in Gazebo. The physics engine is responsible for computing the interactions between objects, including collisions, contact forces, friction, and other physical phenomena. For humanoid robotics applications, selecting and configuring the appropriate physics engine is crucial for achieving stable and realistic simulation results."}),"\n",(0,s.jsx)(n.h2,{id:"overview-of-available-physics-engines",children:"Overview of Available Physics Engines"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo provides three main physics engines, each with distinct characteristics and use cases:"}),"\n",(0,s.jsx)(n.h3,{id:"1-open-dynamics-engine-ode",children:"1. Open Dynamics Engine (ODE)"}),"\n",(0,s.jsx)(n.p,{children:"ODE is the default physics engine in Gazebo and is widely used in robotics research. It excels at handling contact simulation and is particularly well-suited for humanoid robots due to its stable contact handling capabilities."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Stable contact simulation with good handling of friction"}),"\n",(0,s.jsx)(n.li,{children:"Efficient collision detection for complex models"}),"\n",(0,s.jsx)(n.li,{children:"Well-tested and mature codebase"}),"\n",(0,s.jsx)(n.li,{children:"Good performance for humanoid robot applications"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics name="ode_physics" type="ode">\n  <gravity>0 0 -9.8</gravity>\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>1000</iters>\n      <sor>1.3</sor>\n    </solver>\n    <constraints>\n      <cfm>0.000001</cfm>\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>100</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>1000</real_time_update_rate>\n</physics>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-bullet-physics",children:"2. Bullet Physics"}),"\n",(0,s.jsx)(n.p,{children:"Bullet Physics is known for its superior performance in complex collision detection scenarios. It's particularly effective when simulating environments with many objects or complex geometries."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fast collision detection algorithms"}),"\n",(0,s.jsx)(n.li,{children:"Better performance with large numbers of objects"}),"\n",(0,s.jsx)(n.li,{children:"Good support for complex geometries"}),"\n",(0,s.jsx)(n.li,{children:"Suitable for dynamic environments"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics name="bullet_physics" type="bullet">\n  <gravity>0 0 -9.8</gravity>\n  <bullet>\n    <solver>\n      <type>sequential_impulse</type>\n      <iter>50</iter>\n      <sor>1.3</sor>\n    </solver>\n    <constraints>\n      <cfm>0.000001</cfm>\n      <erp>0.2</erp>\n    </constraints>\n  </bullet>\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>1000</real_time_update_rate>\n</physics>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-simbody",children:"3. Simbody"}),"\n",(0,s.jsx)(n.p,{children:"Simbody is designed for high-accuracy multibody dynamics and is excellent for complex kinematic chains. It's particularly suitable for precise humanoid motion simulation where accuracy is more important than raw performance."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"High-accuracy multibody dynamics"}),"\n",(0,s.jsx)(n.li,{children:"Excellent for complex kinematic chains"}),"\n",(0,s.jsx)(n.li,{children:"Suitable for precise motion simulation"}),"\n",(0,s.jsx)(n.li,{children:"Advanced constraint handling"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Configuration Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics name="simbody_physics" type="simbody">\n  <gravity>0 0 -9.8</gravity>\n  <simbody>\n    <min_step_size>0.0001</min_step_size>\n    <accuracy>0.001</accuracy>\n    <max_contacts>20</max_contacts>\n  </simbody>\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>1000</real_time_update_rate>\n</physics>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"physics-engine-selection-for-humanoid-robots",children:"Physics Engine Selection for Humanoid Robots"}),"\n",(0,s.jsx)(n.h3,{id:"ode-for-humanoid-applications",children:"ODE for Humanoid Applications"}),"\n",(0,s.jsx)(n.p,{children:"ODE is typically the best choice for humanoid robot simulation due to its stable contact handling. For humanoid robots that need to walk, balance, or interact with objects, ODE provides the most reliable contact simulation."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimal ODE Settings for Humanoid Robots:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics name="humanoid_ode" type="ode">\n  <ode>\n    <solver>\n      <type>quick</type>\n      \x3c!-- Higher iterations for more stable contacts --\x3e\n      <iters>2000</iters>\n      <sor>1.2</sor>\n    </solver>\n    <constraints>\n      \x3c!-- Low CFM for stiff constraints --\x3e\n      <cfm>1e-5</cfm>\n      \x3c!-- Higher ERP for faster error correction --\x3e\n      <erp>0.2</erp>\n      \x3c!-- Higher max correcting velocity for stable contacts --\x3e\n      <contact_max_correcting_vel>100</contact_max_correcting_vel>\n      \x3c!-- Small surface layer for accurate contacts --\x3e\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n  \x3c!-- Smaller time step for more accurate simulation --\x3e\n  <max_step_size>0.0005</max_step_size>\n  <real_time_factor>0.5</real_time_factor>\n  <real_time_update_rate>2000</real_time_update_rate>\n</physics>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"bullet-for-complex-environments",children:"Bullet for Complex Environments"}),"\n",(0,s.jsx)(n.p,{children:"Use Bullet when simulating humanoid robots in complex environments with many objects, or when performance is critical."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimal Bullet Settings for Complex Environments:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics name="bullet_complex_env" type="bullet">\n  <bullet>\n    <solver>\n      <type>sequential_impulse</type>\n      <iter>100</iter>\n      <sor>1.3</sor>\n    </solver>\n    <constraints>\n      <cfm>1e-6</cfm>\n      <erp>0.1</erp>\n    </constraints>\n    \x3c!-- Use continuous collision detection for fast-moving objects --\x3e\n    <use_ccd>true</use_ccd>\n  </bullet>\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n</physics>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"simbody-for-precise-motion",children:"Simbody for Precise Motion"}),"\n",(0,s.jsx)(n.p,{children:"Simbody is ideal when you need high accuracy in complex kinematic chains, such as for detailed analysis of humanoid joint movements."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Optimal Simbody Settings for Precise Motion:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics name="simbody_precise" type="simbody">\n  <simbody>\n    <min_step_size>1e-5</min_step_size>\n    <accuracy>1e-4</accuracy>\n    <max_contacts>50</max_contacts>\n  </simbody>\n  <max_step_size>0.0001</max_step_size>\n  <real_time_factor>0.1</real_time_factor>\n</physics>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-physics-configuration",children:"Advanced Physics Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"contact-properties",children:"Contact Properties"}),"\n",(0,s.jsx)(n.p,{children:"For humanoid robots, contact properties are crucial for stable walking and interaction:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<collision name="foot_collision">\n  <surface>\n    <friction>\n      <ode>\n        \x3c!-- High friction for stable walking --\x3e\n        <mu>1.0</mu>\n        <mu2>1.0</mu2>\n        \x3c!-- Direction of friction --\x3e\n        <fdir1>0 0 1</fdir1>\n      </ode>\n      <torsional>\n        \x3c!-- Torsional friction for preventing spinning --\x3e\n        <coefficient>1.0</coefficient>\n        <use_patch_radius>1</use_patch_radius>\n        <surface_radius>0.01</surface_radius>\n      </torsional>\n    </friction>\n    \x3c!-- Bounce properties --\x3e\n    <bounce>\n      <restitution_coefficient>0.01</restitution_coefficient>\n      <threshold>100000</threshold>\n    </bounce>\n    \x3c!-- Contact dynamics --\x3e\n    <contact>\n      <ode>\n        \x3c!-- Soft constraint force mixing --\x3e\n        <soft_cfm>0.0001</soft_cfm>\n        \x3c!-- Error reduction parameter --\x3e\n        <soft_erp>0.2</soft_erp>\n        \x3c!-- Spring stiffness --\x3e\n        <kp>1e+13</kp>\n        \x3c!-- Damping --\x3e\n        <kd>1</kd>\n        \x3c!-- Maximum velocity --\x3e\n        <max_vel>100.0</max_vel>\n        \x3c!-- Minimum depth --\x3e\n        <min_depth>0.001</min_depth>\n      </ode>\n    </contact>\n  </surface>\n</collision>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"joint-physics-configuration",children:"Joint Physics Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Proper joint physics configuration is essential for realistic humanoid movement:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<joint name="knee_joint" type="revolute">\n  <parent>thigh</parent>\n  <child>shin</child>\n  <axis>\n    <xyz>0 1 0</xyz>\n    <limit>\n      <lower>-0.1</lower>\n      <upper>2.3</upper>\n      <effort>300</effort>\n      <velocity>5.0</velocity>\n    </limit>\n    <dynamics>\n      \x3c!-- Damping to simulate joint friction --\x3e\n      <damping>10.0</damping>\n      \x3c!-- Friction for realistic joint behavior --\x3e\n      <friction>5.0</friction>\n      \x3c!-- Spring properties --\x3e\n      <spring_reference>0.0</spring_reference>\n      <spring_stiffness>0.0</spring_stiffness>\n    </dynamics>\n  </axis>\n  \x3c!-- Joint physics for more advanced properties --\x3e\n  <physics>\n    <ode>\n      <limit>\n        <cfm>0.0</cfm>\n        <erp>0.2</erp>\n      </limit>\n      <suspension>\n        <cfm>0.0</cfm>\n        <erp>0.2</erp>\n      </suspension>\n    </ode>\n  </physics>\n</joint>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization-strategies",children:"Performance Optimization Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"time-step-optimization",children:"Time Step Optimization"}),"\n",(0,s.jsx)(n.p,{children:"The time step significantly affects both accuracy and performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"\x3c!-- For real-time simulation --\x3e\n<max_step_size>0.001</max_step_size>\n<real_time_update_rate>1000</real_time_update_rate>\n\n\x3c!-- For more accurate simulation --\x3e\n<max_step_size>0.0001</max_step_size>\n<real_time_update_rate>10000</real_time_update_rate>\n\n\x3c!-- Balance between accuracy and performance --\x3e\n<max_step_size>0.0005</max_step_size>\n<real_time_update_rate>2000</real_time_update_rate>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"solver-parameter-tuning",children:"Solver Parameter Tuning"}),"\n",(0,s.jsx)(n.p,{children:"Adjust solver parameters based on your simulation requirements:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<ode>\n  <solver>\n    \x3c!-- More iterations = more stable but slower --\x3e\n    <iters>1000</iters>\n    \x3c!-- SOR over-relaxation parameter --\x3e\n    <sor>1.3</sor>\n  </solver>\n</ode>\n"})}),"\n",(0,s.jsx)(n.h2,{id:"physics-engine-benchmarking",children:"Physics Engine Benchmarking"}),"\n",(0,s.jsx)(n.p,{children:"To determine the best physics engine for your specific humanoid robot application, consider these benchmarking criteria:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stability"}),": How well does the robot maintain balance?"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Accuracy"}),": How closely does the simulation match expected physical behavior?"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": What is the real-time factor achieved?"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Contact Quality"}),": How realistic are the contact interactions?"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"simple-benchmark-test",children:"Simple Benchmark Test"}),"\n",(0,s.jsx)(n.p,{children:"Create a simple test to compare physics engines:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nSimple physics engine benchmark for humanoid robots\n\"\"\"\nimport time\nimport subprocess\nimport argparse\n\ndef benchmark_physics_engine(engine_type, world_file, duration=10):\n    \"\"\"Benchmark a specific physics engine\"\"\"\n    start_time = time.time()\n\n    # Launch Gazebo with specific physics engine\n    cmd = [\n        'gz', 'sim',\n        '-r',  # Run in headless mode\n        f'--physics-engine={engine_type}',\n        world_file\n    ]\n\n    print(f\"Benchmarking {engine_type} for {duration} seconds...\")\n\n    # In a real implementation, you would run the simulation\n    # and measure real-time factor and stability metrics\n    time.sleep(duration)  # Simulate running the simulation\n\n    end_time = time.time()\n    actual_duration = end_time - start_time\n\n    # Calculate real-time factor\n    real_time_factor = duration / actual_duration\n\n    print(f\"Physics Engine: {engine_type}\")\n    print(f\"Requested Duration: {duration}s\")\n    print(f\"Actual Duration: {actual_duration:.2f}s\")\n    print(f\"Real-time Factor: {real_time_factor:.2f}\")\n\n    return real_time_factor\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description='Physics Engine Benchmark')\n    parser.add_argument('--engine', type=str, required=True,\n                       choices=['ode', 'bullet', 'simbody'],\n                       help='Physics engine to benchmark')\n    parser.add_argument('--world', type=str, required=True,\n                       help='World file to use for benchmarking')\n    parser.add_argument('--duration', type=int, default=10,\n                       help='Duration of benchmark in seconds')\n\n    args = parser.parse_args()\n\n    benchmark_physics_engine(args.engine, args.world, args.duration)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting-common-physics-issues",children:"Troubleshooting Common Physics Issues"}),"\n",(0,s.jsx)(n.h3,{id:"1-unstable-contact-simulation",children:"1. Unstable Contact Simulation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Symptoms"}),": Robot jitters, falls through surfaces, or exhibits unrealistic bouncing."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Increase solver iterations"}),"\n",(0,s.jsx)(n.li,{children:"Decrease time step"}),"\n",(0,s.jsx)(n.li,{children:"Adjust ERP and CFM values"}),"\n",(0,s.jsx)(n.li,{children:"Check collision geometry for proper overlap"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-slow-performance",children:"2. Slow Performance"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Symptoms"}),": Low real-time factor, simulation lag."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Increase time step (trade accuracy for speed)"}),"\n",(0,s.jsx)(n.li,{children:"Reduce solver iterations"}),"\n",(0,s.jsx)(n.li,{children:"Simplify collision geometry"}),"\n",(0,s.jsx)(n.li,{children:"Use static models where possible"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-penetration-issues",children:"3. Penetration Issues"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Symptoms"}),": Objects pass through each other."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Decrease time step"}),"\n",(0,s.jsx)(n.li,{children:"Increase ERP"}),"\n",(0,s.jsx)(n.li,{children:"Improve collision geometry"}),"\n",(0,s.jsx)(n.li,{children:"Use continuous collision detection (for Bullet)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-physics-configuration",children:"Best Practices for Physics Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"1-start-conservative",children:"1. Start Conservative"}),"\n",(0,s.jsx)(n.p,{children:"Begin with conservative settings and gradually optimize for performance while maintaining stability."}),"\n",(0,s.jsx)(n.h3,{id:"2-match-real-world-properties",children:"2. Match Real-World Properties"}),"\n",(0,s.jsx)(n.p,{children:"Use physical properties that match your real robot as closely as possible."}),"\n",(0,s.jsx)(n.h3,{id:"3-validate-with-simple-tests",children:"3. Validate with Simple Tests"}),"\n",(0,s.jsx)(n.p,{children:"Test physics configurations with simple scenarios before complex humanoid behaviors."}),"\n",(0,s.jsx)(n.h3,{id:"4-document-configuration-changes",children:"4. Document Configuration Changes"}),"\n",(0,s.jsx)(n.p,{children:"Keep track of physics parameters that work well for your specific robot design."}),"\n",(0,s.jsx)(n.p,{children:"The choice of physics engine and its configuration significantly impacts the quality and realism of humanoid robot simulations. By understanding the strengths and characteristics of each engine, you can optimize your simulation for the specific requirements of your Physical AI applications."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);