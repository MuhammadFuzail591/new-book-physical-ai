"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[6790],{4094:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>o,toc:()=>l});var r=s(4848),i=s(8453);const t={title:"Services and Actions in ROS 2"},a="Services and Actions in ROS 2",o={id:"ros2-architecture/services-actions",title:"Services and Actions in ROS 2",description:"Introduction",source:"@site/docs/physical-ai/ros2-architecture/services-actions.mdx",sourceDirName:"ros2-architecture",slug:"/ros2-architecture/services-actions",permalink:"/ros2-architecture/services-actions",draft:!1,unlisted:!1,editUrl:"https://github.com/fuzailpalook/new-book/tree/main/docs/physical-ai/ros2-architecture/services-actions.mdx",tags:[],version:"current",frontMatter:{title:"Services and Actions in ROS 2"},sidebar:"tutorialSidebar",previous:{title:"Nodes and Topics in ROS 2",permalink:"/ros2-architecture/nodes-topics"},next:{title:"Chapter 3 - ROS 2 Architecture Chapter Summary",permalink:"/ros2-architecture/chapter-summary"}},c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Services in ROS 2",id:"services-in-ros-2",level:2},{value:"Service Communication Model",id:"service-communication-model",level:3},{value:"Service Architecture",id:"service-architecture",level:3},{value:"Service Interface Definition",id:"service-interface-definition",level:4},{value:"Service Implementation",id:"service-implementation",level:4},{value:"Service Server",id:"service-server",level:5},{value:"Service Client",id:"service-client",level:5},{value:"Service Patterns and Use Cases",id:"service-patterns-and-use-cases",level:3},{value:"Configuration Services",id:"configuration-services",level:4},{value:"Query Services",id:"query-services",level:4},{value:"Service Best Practices",id:"service-best-practices",level:3},{value:"Error Handling",id:"error-handling",level:4},{value:"Service Timeout Handling",id:"service-timeout-handling",level:4},{value:"Actions in ROS 2",id:"actions-in-ros-2",level:2},{value:"Action Communication Model",id:"action-communication-model",level:3},{value:"Action Architecture",id:"action-architecture",level:3},{value:"Action Interface Definition",id:"action-interface-definition",level:4},{value:"Action Implementation",id:"action-implementation",level:4},{value:"Action Server",id:"action-server",level:5},{value:"Action Client",id:"action-client",level:5},{value:"Action Patterns and Use Cases",id:"action-patterns-and-use-cases",level:3},{value:"Navigation Actions",id:"navigation-actions",level:4},{value:"Manipulation Actions",id:"manipulation-actions",level:4},{value:"Action Best Practices",id:"action-best-practices",level:3},{value:"Goal Validation",id:"goal-validation",level:4},{value:"Progress Tracking",id:"progress-tracking",level:4},{value:"Comparison of Communication Patterns",id:"comparison-of-communication-patterns",level:2},{value:"When to Use Each Pattern",id:"when-to-use-each-pattern",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Service Performance",id:"service-performance",level:4},{value:"Action Performance",id:"action-performance",level:4},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Service Composition",id:"service-composition",level:3},{value:"Action Coordination",id:"action-coordination",level:3},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:2},{value:"Service Error Handling",id:"service-error-handling",level:3},{value:"Action Error Handling",id:"action-error-handling",level:3},{value:"Integration with Physical AI Systems",id:"integration-with-physical-ai-systems",level:2},{value:"Service Applications in Robotics",id:"service-applications-in-robotics",level:3},{value:"Sensor Calibration Services",id:"sensor-calibration-services",level:4},{value:"Emergency Stop Services",id:"emergency-stop-services",level:4},{value:"Action Applications in Robotics",id:"action-applications-in-robotics",level:3},{value:"Complex Motion Planning",id:"complex-motion-planning",level:4},{value:"Command Line Tools",id:"command-line-tools",level:2},{value:"Service Tools",id:"service-tools",level:3},{value:"Service Inspection",id:"service-inspection",level:4},{value:"Action Tools",id:"action-tools",level:3},{value:"Action Inspection",id:"action-inspection",level:4},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Service Best Practices",id:"service-best-practices-1",level:3},{value:"Action Best Practices",id:"action-best-practices-1",level:3},{value:"Learning Outcomes",id:"learning-outcomes",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"services-and-actions-in-ros-2",children:"Services and Actions in ROS 2"}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(n.p,{children:"While topics provide asynchronous, decoupled communication through the publish/subscribe pattern, services and actions offer different communication paradigms that are essential for specific use cases in robotic systems. Services provide synchronous request/response communication, ideal for operations that require immediate results. Actions provide goal-based communication for long-running tasks with feedback, perfect for operations that take time and need status updates."}),"\n",(0,r.jsx)(n.h2,{id:"services-in-ros-2",children:"Services in ROS 2"}),"\n",(0,r.jsx)(n.h3,{id:"service-communication-model",children:"Service Communication Model"}),"\n",(0,r.jsx)(n.p,{children:"Services implement a synchronous request/response pattern where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Client"}),": Sends a request and waits for a response"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Server"}),": Receives the request, processes it, and sends back a response"]}),"\n",(0,r.jsx)(n.li,{children:"Communication is blocking - the client waits for the server to respond"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"service-architecture",children:"Service Architecture"}),"\n",(0,r.jsx)(n.h4,{id:"service-interface-definition",children:"Service Interface Definition"}),"\n",(0,r.jsxs)(n.p,{children:["Services are defined using ",(0,r.jsx)(n.code,{children:".srv"})," files that specify the request and response message types:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"# Example: AddTwoInts.srv\nint64 a\nint64 b\n---\nint64 sum\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The part before ",(0,r.jsx)(n.code,{children:"---"})," defines the request message, and the part after defines the response message."]}),"\n",(0,r.jsx)(n.h4,{id:"service-implementation",children:"Service Implementation"}),"\n",(0,r.jsx)(n.h5,{id:"service-server",children:"Service Server"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalServiceServer(Node):\n    def __init__(self):\n        super().__init__('minimal_service_server')\n\n        # Create service server\n        self.srv = self.create_service(\n            AddTwoInts,\n            'add_two_ints',\n            self.add_two_ints_callback\n        )\n\n    def add_two_ints_callback(self, request, response):\n        # Process the request\n        response.sum = request.a + request.b\n\n        # Log the operation\n        self.get_logger().info(\n            f'Returning {request.a} + {request.b} = {response.sum}'\n        )\n\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_service_server = MinimalServiceServer()\n\n    try:\n        rclpy.spin(minimal_service_server)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        minimal_service_server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h5,{id:"service-client",children:"Service Client"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalServiceClient(Node):\n    def __init__(self):\n        super().__init__('minimal_service_client')\n\n        # Create service client\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n\n        # Wait for service to be available\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n\n        self.request = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.request.a = a\n        self.request.b = b\n\n        # Send request asynchronously\n        self.future = self.cli.call_async(self.request)\n        return self.future\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_service_client = MinimalServiceClient()\n\n    # Send request\n    future = minimal_service_client.send_request(1, 2)\n\n    try:\n        # Wait for response\n        rclpy.spin_until_future_complete(minimal_service_client, future)\n\n        if future.result() is not None:\n            response = future.result()\n            minimal_service_client.get_logger().info(\n                f'Result of add_two_ints: {response.sum}'\n            )\n        else:\n            minimal_service_client.get_logger().error(\n                'Exception while calling service: %r' % future.exception()\n            )\n    except KeyboardInterrupt:\n        pass\n    finally:\n        minimal_service_client.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"service-patterns-and-use-cases",children:"Service Patterns and Use Cases"}),"\n",(0,r.jsx)(n.h4,{id:"configuration-services",children:"Configuration Services"}),"\n",(0,r.jsx)(n.p,{children:"Services are ideal for changing node parameters or configuration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from rclpy.node import Node\nfrom std_srvs.srv import SetBool\n\nclass ConfigurationNode(Node):\n    def __init__(self):\n        super().__init__('configuration_node')\n\n        # Service to enable/disable functionality\n        self.enable_service = self.create_service(\n            SetBool,\n            'enable_processing',\n            self.enable_callback\n        )\n\n        self.processing_enabled = False\n\n    def enable_callback(self, request, response):\n        self.processing_enabled = request.data\n        response.success = True\n        response.message = f'Processing {\"enabled\" if self.processing_enabled else \"disabled\"}'\n        return response\n"})}),"\n",(0,r.jsx)(n.h4,{id:"query-services",children:"Query Services"}),"\n",(0,r.jsx)(n.p,{children:"Services are perfect for querying node state or information:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from example_interfaces.srv import Trigger\nfrom std_msgs.msg import String\n\nclass StatusNode(Node):\n    def __init__(self):\n        super().__init__('status_node')\n\n        # Service to get current status\n        self.status_service = self.create_service(\n            Trigger,  # Generic service for simple operations\n            'get_status',\n            self.get_status_callback\n        )\n\n        self.status_publisher = self.create_publisher(String, 'current_status', 10)\n        self.current_status = \"Operational\"\n\n    def get_status_callback(self, request, response):\n        response.success = True\n        response.message = self.current_status\n        return response\n"})}),"\n",(0,r.jsx)(n.h3,{id:"service-best-practices",children:"Service Best Practices"}),"\n",(0,r.jsx)(n.h4,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def robust_service_callback(self, request, response):\n    try:\n        # Perform the service operation\n        result = self.perform_operation(request)\n        response.result = result\n        response.success = True\n        response.message = "Operation completed successfully"\n    except ValueError as e:\n        # Handle specific errors\n        response.success = False\n        response.message = f"Invalid input: {str(e)}"\n    except Exception as e:\n        # Handle general errors\n        response.success = False\n        response.message = f"Service error: {str(e)}"\n\n    return response\n'})}),"\n",(0,r.jsx)(n.h4,{id:"service-timeout-handling",children:"Service Timeout Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ServiceWithTimeout(Node):\n    def __init__(self):\n        super().__init__('service_with_timeout')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n\n    def call_with_timeout(self, a, b, timeout_sec=5.0):\n        # Wait for service with timeout\n        if not self.cli.wait_for_service(timeout_sec=timeout_sec):\n            self.get_logger().error('Service not available within timeout')\n            return None\n\n        request = AddTwoInts.Request()\n        request.a = a\n        request.b = b\n\n        future = self.cli.call_async(request)\n\n        # Wait for result with timeout\n        rclpy.spin_until_future_complete(\n            self, future, timeout_sec=timeout_sec\n        )\n\n        if future.result() is not None:\n            return future.result()\n        else:\n            self.get_logger().error('Service call timed out')\n            return None\n"})}),"\n",(0,r.jsx)(n.h2,{id:"actions-in-ros-2",children:"Actions in ROS 2"}),"\n",(0,r.jsx)(n.h3,{id:"action-communication-model",children:"Action Communication Model"}),"\n",(0,r.jsx)(n.p,{children:"Actions provide goal-based communication for long-running operations with:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Request to perform a long-running task"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Feedback"}),": Periodic updates on task progress"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Result"}),": Final outcome when task completes (success/failure)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"action-architecture",children:"Action Architecture"}),"\n",(0,r.jsx)(n.h4,{id:"action-interface-definition",children:"Action Interface Definition"}),"\n",(0,r.jsxs)(n.p,{children:["Actions are defined using ",(0,r.jsx)(n.code,{children:".action"})," files that specify goal, feedback, and result:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"# Example: Fibonacci.action\nint32 order\n---\nint32[] sequence\n---\nint32[] sequence\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"First section: Goal (request)"}),"\n",(0,r.jsx)(n.li,{children:"Second section: Feedback (intermediate updates)"}),"\n",(0,r.jsx)(n.li,{children:"Third section: Result (final outcome)"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"action-implementation",children:"Action Implementation"}),"\n",(0,r.jsx)(n.h5,{id:"action-server",children:"Action Server"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import time\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionServer(Node):\n    def __init__(self):\n        super().__init__(\'fibonacci_action_server\')\n\n        # Create action server\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            \'fibonacci\',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            handle_accepted_callback=self.handle_accepted_callback,\n            cancel_callback=self.cancel_callback\n        )\n\n    def goal_callback(self, goal_request):\n        """Accept or reject a goal."""\n        self.get_logger().info(\'Received goal request\')\n        return GoalResponse.ACCEPT\n\n    def handle_accepted_callback(self, goal_handle):\n        """Handle an accepted goal."""\n        self.get_logger().info(\'Goal accepted, starting execution...\')\n\n        # Start execution in a separate thread\n        goal_handle.execute()\n\n    def cancel_callback(self, goal_handle):\n        """Accept or reject a cancel request."""\n        self.get_logger().info(\'Received cancel request\')\n        return CancelResponse.ACCEPT\n\n    def execute_callback(self, goal_handle):\n        """Execute the goal."""\n        self.get_logger().info(\'Executing goal...\')\n\n        # Initialize feedback message\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        # Perform the action\n        for i in range(1, goal_handle.request.order):\n            # Check if cancel was requested\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info(\'Goal canceled\')\n                return Fibonacci.Result()\n\n            # Update feedback\n            feedback_msg.sequence.append(\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1]\n            )\n\n            # Publish feedback\n            goal_handle.publish_feedback(feedback_msg)\n            self.get_logger().info(f\'Publishing feedback: {feedback_msg.sequence}\')\n\n            # Simulate work\n            time.sleep(0.5)\n\n        # Complete successfully\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.sequence\n        self.get_logger().info(f\'Returning result: {result.sequence}\')\n\n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n    fibonacci_action_server = FibonacciActionServer()\n\n    try:\n        rclpy.spin(fibonacci_action_server)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        fibonacci_action_server.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,r.jsx)(n.h5,{id:"action-client",children:"Action Client"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import time\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionClient(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_client')\n\n        # Create action client\n        self._action_client = ActionClient(\n            self,\n            Fibonacci,\n            'fibonacci'\n        )\n\n    def send_goal(self, order):\n        # Wait for action server\n        self._action_client.wait_for_server()\n\n        # Create goal message\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        # Send goal and get future\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected')\n            return\n\n        self.get_logger().info('Goal accepted')\n\n        # Get result future\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def feedback_callback(self, feedback_msg):\n        self.get_logger().info(\n            f'Received feedback: {feedback_msg.feedback.sequence}'\n        )\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        self.get_logger().info(f'Result: {result.sequence}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    fibonacci_action_client = FibonacciActionClient()\n\n    # Send goal\n    fibonacci_action_client.send_goal(10)\n\n    try:\n        rclpy.spin(fibonacci_action_client)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        fibonacci_action_client.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"action-patterns-and-use-cases",children:"Action Patterns and Use Cases"}),"\n",(0,r.jsx)(n.h4,{id:"navigation-actions",children:"Navigation Actions"}),"\n",(0,r.jsx)(n.p,{children:"Actions are perfect for navigation tasks that take time:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom nav_msgs.action import NavigateToPose\n\nclass NavigationServer(Node):\n    def __init__(self):\n        super().__init__('navigation_server')\n\n        self._action_server = ActionServer(\n            self,\n            NavigateToPose,\n            'navigate_to_pose',\n            execute_callback=self.execute_navigate_callback\n        )\n\n    def execute_navigate_callback(self, goal_handle):\n        target_pose = goal_handle.request.pose\n        self.get_logger().info(f'Navigating to {target_pose}')\n\n        # Initialize feedback\n        feedback_msg = NavigateToPose.Feedback()\n\n        # Simulate navigation process\n        for step in range(100):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                return NavigateToPose.Result()\n\n            # Update feedback (distance to goal, progress, etc.)\n            feedback_msg.distance_remaining = 10.0 - (step * 0.1)\n            feedback_msg.current_pose = self.get_current_pose()\n            goal_handle.publish_feedback(feedback_msg)\n\n            time.sleep(0.1)  # Simulate navigation\n\n        # Success\n        goal_handle.succeed()\n        result = NavigateToPose.Result()\n        result.result = \"Navigation completed successfully\"\n        return result\n"})}),"\n",(0,r.jsx)(n.h4,{id:"manipulation-actions",children:"Manipulation Actions"}),"\n",(0,r.jsx)(n.p,{children:"Actions work well for robot manipulation tasks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom control_msgs.action import FollowJointTrajectory\n\nclass ManipulationServer(Node):\n    def __init__(self):\n        super().__init__('manipulation_server')\n\n        self._action_server = ActionServer(\n            self,\n            FollowJointTrajectory,\n            'joint_trajectory_controller/follow_joint_trajectory',\n            execute_callback=self.execute_trajectory_callback\n        )\n\n    def execute_trajectory_callback(self, goal_handle):\n        trajectory = goal_handle.request.trajectory\n        self.get_logger().info(f'Executing trajectory with {len(trajectory.points)} points')\n\n        feedback_msg = FollowJointTrajectory.Feedback()\n\n        # Execute each point in the trajectory\n        for i, point in enumerate(trajectory.points):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                return FollowJointTrajectory.Result()\n\n            # Move to joint position\n            self.move_to_position(point.positions)\n\n            # Update feedback\n            feedback_msg.joint_names = trajectory.joint_names\n            feedback_msg.desired = point\n            feedback_msg.actual = self.get_current_joint_state()\n            feedback_msg.error = self.calculate_error(point)\n\n            goal_handle.publish_feedback(feedback_msg)\n\n            # Wait for point completion\n            time.sleep(point.time_from_start.sec + point.time_from_start.nanosec / 1e9)\n\n        # Complete successfully\n        goal_handle.succeed()\n        result = FollowJointTrajectory.Result()\n        result.error_code = FollowJointTrajectory.Result.SUCCESSFUL\n        return result\n"})}),"\n",(0,r.jsx)(n.h3,{id:"action-best-practices",children:"Action Best Practices"}),"\n",(0,r.jsx)(n.h4,{id:"goal-validation",children:"Goal Validation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def goal_callback(self, goal_request):\n    # Validate the goal before accepting\n    if goal_request.order <= 0 or goal_request.order > 100:\n        self.get_logger().info('Rejected goal: order must be between 1-100')\n        return GoalResponse.REJECT\n\n    self.get_logger().info(f'Accepted goal with order: {goal_request.order}')\n    return GoalResponse.ACCEPT\n"})}),"\n",(0,r.jsx)(n.h4,{id:"progress-tracking",children:"Progress Tracking"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def execute_with_progress(self, goal_handle):\n    total_steps = goal_handle.request.total_work\n    completed_steps = 0\n\n    feedback_msg = MyAction.Feedback()\n\n    for step in range(total_steps):\n        if goal_handle.is_cancel_requested:\n            goal_handle.canceled()\n            return MyAction.Result()\n\n        # Do work\n        self.do_work_step(step)\n\n        # Update progress\n        completed_steps += 1\n        feedback_msg.progress = (completed_steps / total_steps) * 100.0\n        feedback_msg.current_step = step\n        feedback_msg.total_steps = total_steps\n\n        goal_handle.publish_feedback(feedback_msg)\n\n    goal_handle.succeed()\n    result = MyAction.Result()\n    result.completed = True\n    return result\n"})}),"\n",(0,r.jsx)(n.h2,{id:"comparison-of-communication-patterns",children:"Comparison of Communication Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-each-pattern",children:"When to Use Each Pattern"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Pattern"}),(0,r.jsx)(n.th,{children:"Use Case"}),(0,r.jsx)(n.th,{children:"Characteristics"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Topics"})}),(0,r.jsx)(n.td,{children:"Continuous data streams"}),(0,r.jsx)(n.td,{children:"Async, decoupled, many-to-many"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Services"})}),(0,r.jsx)(n.td,{children:"Request/response operations"}),(0,r.jsx)(n.td,{children:"Sync, blocking, immediate results"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Actions"})}),(0,r.jsx)(n.td,{children:"Long-running tasks"}),(0,r.jsx)(n.td,{children:"Async, with feedback, cancelable"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.h4,{id:"service-performance",children:"Service Performance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Services are synchronous and blocking"}),"\n",(0,r.jsx)(n.li,{children:"Should be used for quick operations (< 1 second)"}),"\n",(0,r.jsx)(n.li,{children:"For long operations, consider using actions instead"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"action-performance",children:"Action Performance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Actions are asynchronous and non-blocking"}),"\n",(0,r.jsx)(n.li,{children:"Perfect for operations that take seconds to minutes"}),"\n",(0,r.jsx)(n.li,{children:"Provide progress feedback during execution"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"service-composition",children:"Service Composition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class CompositeServiceNode(Node):\n    def __init__(self):\n        super().__init__('composite_service')\n\n        # Create clients for other services\n        self.service1_client = self.create_client(\n            SetBool, 'service1'\n        )\n        self.service2_client = self.create_client(\n            Trigger, 'service2'\n        )\n\n        # Create our own service that composes others\n        self.composite_service = self.create_service(\n            Trigger, 'composite_operation', self.composite_callback\n        )\n\n    async def composite_callback(self, request, response):\n        # Call first service\n        future1 = self.service1_client.call_async(SetBool.Request(data=True))\n        await future1\n\n        # Call second service\n        future2 = self.service2_client.call_async(Trigger.Request())\n        await future2\n\n        # Return composite result\n        response.success = future1.result().success and future2.result().success\n        response.message = \"Composite operation completed\"\n        return response\n"})}),"\n",(0,r.jsx)(n.h3,{id:"action-coordination",children:"Action Coordination"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ActionCoordinatorNode(Node):\n    def __init__(self):\n        super().__init__('action_coordinator')\n\n        # Multiple action clients\n        self.navigation_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\n        self.manipulation_client = ActionClient(self, FollowJointTrajectory, 'follow_joint_trajectory')\n\n    def execute_complex_task(self):\n        # Execute navigation first\n        nav_goal = NavigateToPose.Goal()\n        nav_goal.pose = self.get_navigation_target()\n\n        # When navigation completes, start manipulation\n        nav_future = self.navigation_client.send_goal_async(nav_goal)\n        nav_future.add_done_callback(self.navigation_complete_callback)\n\n    def navigation_complete_callback(self, future):\n        # After navigation, start manipulation\n        manipulation_goal = FollowJointTrajectory.Goal()\n        # ... setup manipulation goal\n        manipulation_future = self.manipulation_client.send_goal_async(manipulation_goal)\n        manipulation_future.add_done_callback(self.manipulation_complete_callback)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,r.jsx)(n.h3,{id:"service-error-handling",children:"Service Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def service_with_error_handling(self, request, response):\n    try:\n        # Validate input\n        if not self.validate_request(request):\n            response.success = False\n            response.message = "Invalid request parameters"\n            return response\n\n        # Check system state\n        if not self.system_ready():\n            response.success = False\n            response.message = "System not ready for operation"\n            return response\n\n        # Perform operation\n        result = self.perform_operation(request)\n        response.success = True\n        response.message = "Operation completed successfully"\n        response.result = result\n\n    except Exception as e:\n        self.get_logger().error(f\'Service error: {e}\')\n        response.success = False\n        response.message = f"Service error: {str(e)}"\n\n    return response\n'})}),"\n",(0,r.jsx)(n.h3,{id:"action-error-handling",children:"Action Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def execute_with_error_handling(self, goal_handle):\n    try:\n        # Validate goal\n        if not self.validate_goal(goal_handle.request):\n            goal_handle.abort()\n            result = MyAction.Result()\n            result.error_message = "Invalid goal parameters"\n            return result\n\n        # Execute with progress tracking\n        for step in range(goal_handle.request.steps):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                result = MyAction.Result()\n                result.error_message = "Goal canceled by user"\n                return result\n\n            try:\n                self.execute_step(step)\n            except StepError as e:\n                self.get_logger().error(f\'Step {step} failed: {e}\')\n                goal_handle.abort()\n                result = MyAction.Result()\n                result.error_message = f"Step failed: {str(e)}"\n                return result\n\n            # Publish feedback\n            feedback = MyAction.Feedback()\n            feedback.progress = (step + 1) / goal_handle.request.steps * 100\n            goal_handle.publish_feedback(feedback)\n\n        # Success\n        goal_handle.succeed()\n        result = MyAction.Result()\n        result.success = True\n        return result\n\n    except Exception as e:\n        self.get_logger().error(f\'Action execution error: {e}\')\n        goal_handle.abort()\n        result = MyAction.Result()\n        result.error_message = f"Execution error: {str(e)}"\n        return result\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-physical-ai-systems",children:"Integration with Physical AI Systems"}),"\n",(0,r.jsx)(n.h3,{id:"service-applications-in-robotics",children:"Service Applications in Robotics"}),"\n",(0,r.jsx)(n.h4,{id:"sensor-calibration-services",children:"Sensor Calibration Services"}),"\n",(0,r.jsx)(n.p,{children:"Services are ideal for calibrating sensors:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from std_srvs.srv import Trigger\nfrom sensor_msgs.msg import CameraInfo\n\nclass SensorCalibrationNode(Node):\n    def __init__(self):\n        super().__init__('sensor_calibration')\n\n        self.calibration_service = self.create_service(\n            Trigger, 'calibrate_sensors', self.calibrate_callback\n        )\n        self.camera_info_pub = self.create_publisher(CameraInfo, 'camera_info', 1)\n\n    def calibrate_callback(self, request, response):\n        try:\n            # Perform calibration procedure\n            self.perform_sensor_calibration()\n\n            # Update camera info\n            self.publish_updated_camera_info()\n\n            response.success = True\n            response.message = \"Calibration completed successfully\"\n        except Exception as e:\n            response.success = False\n            response.message = f\"Calibration failed: {str(e)}\"\n\n        return response\n"})}),"\n",(0,r.jsx)(n.h4,{id:"emergency-stop-services",children:"Emergency Stop Services"}),"\n",(0,r.jsx)(n.p,{children:"Critical safety services should be responsive:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from std_srvs.srv import Trigger\n\nclass SafetyNode(Node):\n    def __init__(self):\n        super().__init__('safety_node')\n\n        self.emergency_stop_service = self.create_service(\n            Trigger, 'emergency_stop', self.emergency_stop_callback\n        )\n        self.safety_pub = self.create_publisher(Bool, 'safety_status', 1)\n\n    def emergency_stop_callback(self, request, response):\n        self.get_logger().error(\"EMERGENCY STOP ACTIVATED!\")\n\n        # Stop all robot motion\n        self.stop_all_motors()\n\n        # Publish safety status\n        safety_msg = Bool()\n        safety_msg.data = True\n        self.safety_pub.publish(safety_msg)\n\n        response.success = True\n        response.message = \"Emergency stop executed\"\n        return response\n"})}),"\n",(0,r.jsx)(n.h3,{id:"action-applications-in-robotics",children:"Action Applications in Robotics"}),"\n",(0,r.jsx)(n.h4,{id:"complex-motion-planning",children:"Complex Motion Planning"}),"\n",(0,r.jsx)(n.p,{children:"Actions are perfect for planning and executing complex motions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from rclpy.action import ActionServer\nfrom moveit_msgs.action import MoveGroup\n\nclass MotionPlanningServer(Node):\n    def __init__(self):\n        super().__init__('motion_planning_server')\n\n        self._action_server = ActionServer(\n            self,\n            MoveGroup,\n            'move_group',\n            execute_callback=self.execute_move_group_callback\n        )\n\n    def execute_move_group_callback(self, goal_handle):\n        self.get_logger().info('Starting motion planning...')\n\n        feedback_msg = MoveGroup.Feedback()\n\n        try:\n            # Plan trajectory\n            plan = self.plan_trajectory(goal_handle.request)\n            feedback_msg.state = \"Trajectory planned\"\n            goal_handle.publish_feedback(feedback_msg)\n\n            # Validate plan\n            if not self.validate_plan(plan):\n                goal_handle.abort()\n                result = MoveGroup.Result()\n                result.error_code.val = MoveItErrorCodes.INVALID_MOTION_PLAN\n                return result\n\n            # Execute trajectory\n            feedback_msg.state = \"Executing trajectory\"\n            goal_handle.publish_feedback(feedback_msg)\n\n            success = self.execute_trajectory(plan)\n\n            if success:\n                goal_handle.succeed()\n                result = MoveGroup.Result()\n                result.error_code.val = MoveItErrorCodes.SUCCESS\n            else:\n                goal_handle.abort()\n                result = MoveGroup.Result()\n                result.error_code.val = MoveItErrorCodes.CONTROL_FAILED\n\n        except Exception as e:\n            goal_handle.abort()\n            result = MoveGroup.Result()\n            result.error_code.val = MoveItErrorCodes.FAILURE\n            self.get_logger().error(f'Motion planning error: {e}')\n\n        return result\n"})}),"\n",(0,r.jsx)(n.h2,{id:"command-line-tools",children:"Command Line Tools"}),"\n",(0,r.jsx)(n.h3,{id:"service-tools",children:"Service Tools"}),"\n",(0,r.jsx)(n.h4,{id:"service-inspection",children:"Service Inspection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# List all services\nros2 service list\n\n# Get information about a specific service\nros2 service info /service_name\n\n# Call a service directly from command line\nros2 service call /trigger_service std_srvs/srv/Trigger\n\n# Call with parameters\nros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{a: 1, b: 2}"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"action-tools",children:"Action Tools"}),"\n",(0,r.jsx)(n.h4,{id:"action-inspection",children:"Action Inspection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# List all actions\nros2 action list\n\n# Get information about a specific action\nros2 action info /action_name\n\n# Send a goal\nros2 action send_goal /fibonacci example_interfaces/action/Fibonacci "{order: 5}"\n\n# Send goal and stream feedback\nros2 action send_goal -f /fibonacci example_interfaces/action/Fibonacci "{order: 5}"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,r.jsx)(n.h3,{id:"service-best-practices-1",children:"Service Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use for Quick Operations"}),": Services should complete quickly (under 1 second)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Handling"}),": Always include proper error handling and meaningful error messages"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validation"}),": Validate input parameters before processing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State Independence"}),": Services should be stateless when possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Timeout Handling"}),": Implement appropriate timeouts for service calls"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"action-best-practices-1",children:"Action Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Long-Running Tasks"}),": Use for operations that take seconds to minutes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Progress Feedback"}),": Provide meaningful feedback during execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cancel Support"}),": Implement proper cancellation handling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Goal Validation"}),": Validate goals before accepting them"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource Management"}),": Clean up resources properly on cancellation"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this section, you should be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement ROS 2 services for synchronous request/response communication"}),"\n",(0,r.jsx)(n.li,{children:"Create ROS 2 actions for long-running tasks with feedback"}),"\n",(0,r.jsx)(n.li,{children:"Choose appropriate communication patterns for different use cases"}),"\n",(0,r.jsx)(n.li,{children:"Handle errors and cancellation in services and actions"}),"\n",(0,r.jsx)(n.li,{children:"Integrate services and actions into complex robotic systems"}),"\n",(0,r.jsx)(n.li,{children:"Use command-line tools to inspect and interact with services and actions"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);