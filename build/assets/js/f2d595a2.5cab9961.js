"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[7801],{2326:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>t,toc:()=>c});var s=i(4848),a=i(8453);const o={title:"Chapter 7 - Gazebo Simulation: Physics, Sensors & World Building"},r="Chapter 7: Gazebo Simulation: Physics, Sensors & World Building",t={id:"physical-ai/gazebo-simulation/index",title:"Chapter 7 - Gazebo Simulation: Physics, Sensors & World Building",description:"Chapter Overview",source:"@site/docs/physical-ai/gazebo-simulation/index.mdx",sourceDirName:"physical-ai/gazebo-simulation",slug:"/physical-ai/gazebo-simulation/",permalink:"/physical-ai-textbook/physical-ai/physical-ai/gazebo-simulation/",draft:!1,unlisted:!1,editUrl:"https://github.com/your-username/physical-ai-textbook/tree/main/docs/physical-ai/gazebo-simulation/index.mdx",tags:[],version:"current",frontMatter:{title:"Chapter 7 - Gazebo Simulation: Physics, Sensors & World Building"},sidebar:"tutorialSidebar",previous:{title:"chapter-summary",permalink:"/physical-ai-textbook/physical-ai/physical-ai/ros2-advanced/chapter-summary"},next:{title:"Physics Engines in Gazebo - ODE, Bullet, and Simbody",permalink:"/physical-ai-textbook/physical-ai/physical-ai/gazebo-simulation/physics-engines"}},l={},c=[{value:"Chapter Overview",id:"chapter-overview",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Introduction to Gazebo Simulation",id:"introduction-to-gazebo-simulation",level:2},{value:"Key Features of Gazebo",id:"key-features-of-gazebo",level:3},{value:"Gazebo Architecture",id:"gazebo-architecture",level:3},{value:"Physics Engine Fundamentals",id:"physics-engine-fundamentals",level:2},{value:"Available Physics Engines",id:"available-physics-engines",level:3},{value:"Physics Engine Configuration",id:"physics-engine-configuration",level:3},{value:"Key Physics Parameters",id:"key-physics-parameters",level:3},{value:"Sensor Simulation in Gazebo",id:"sensor-simulation-in-gazebo",level:2},{value:"Camera Sensors",id:"camera-sensors",level:3},{value:"LIDAR and Range Sensors",id:"lidar-and-range-sensors",level:3},{value:"IMU Sensors",id:"imu-sensors",level:3},{value:"World Building and Environment Design",id:"world-building-and-environment-design",level:2},{value:"Basic World Structure",id:"basic-world-structure",level:3},{value:"Advanced Environment Features",id:"advanced-environment-features",level:3},{value:"Heightmaps for Terrain",id:"heightmaps-for-terrain",level:4},{value:"Dynamic Objects",id:"dynamic-objects",level:4},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Simulation Optimization Strategies",id:"simulation-optimization-strategies",level:3},{value:"Multi-Model Optimization",id:"multi-model-optimization",level:3},{value:"Integration with ROS 2",id:"integration-with-ros-2",level:2},{value:"Gazebo-ROS 2 Bridge",id:"gazebo-ros-2-bridge",level:3},{value:"Launching Simulation with ROS 2",id:"launching-simulation-with-ros-2",level:3},{value:"Best Practices for Humanoid Robot Simulation",id:"best-practices-for-humanoid-robot-simulation",level:2},{value:"1. Stable Physics Configuration",id:"1-stable-physics-configuration",level:3},{value:"2. Realistic Sensor Models",id:"2-realistic-sensor-models",level:3},{value:"3. Gradual Complexity Increase",id:"3-gradual-complexity-increase",level:3},{value:"4. Simulation-to-Reality Transfer",id:"4-simulation-to-reality-transfer",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"chapter-7-gazebo-simulation-physics-sensors--world-building",children:"Chapter 7: Gazebo Simulation: Physics, Sensors & World Building"}),"\n",(0,s.jsx)(e.h2,{id:"chapter-overview",children:"Chapter Overview"}),"\n",(0,s.jsx)(e.p,{children:"This chapter provides a comprehensive exploration of Gazebo simulation - the premier physics simulation environment for robotics development. We'll examine the core physics engines, sensor simulation capabilities, and world building tools that enable realistic testing and development of humanoid robots. Gazebo serves as a critical bridge between theoretical robot design and real-world deployment, allowing for extensive testing in controlled virtual environments before hardware implementation."}),"\n",(0,s.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Configure and optimize Gazebo physics engines for different simulation scenarios"}),"\n",(0,s.jsx)(e.li,{children:"Implement realistic sensor models with appropriate noise characteristics"}),"\n",(0,s.jsx)(e.li,{children:"Design complex simulation environments for humanoid robot testing"}),"\n",(0,s.jsx)(e.li,{children:"Integrate Gazebo with ROS 2 for seamless simulation-to-reality workflows"}),"\n",(0,s.jsx)(e.li,{children:"Optimize simulation performance for large-scale humanoid robot systems"}),"\n",(0,s.jsx)(e.li,{children:"Validate robot behaviors in simulation before real-world deployment"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"introduction-to-gazebo-simulation",children:"Introduction to Gazebo Simulation"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo is a powerful open-source robotics simulator that provides realistic physics simulation, high-quality 3D graphics, and convenient programmatic interfaces. For Physical AI and humanoid robotics applications, Gazebo serves as an essential tool for developing, testing, and validating robot behaviors before deploying to real hardware."}),"\n",(0,s.jsx)(e.h3,{id:"key-features-of-gazebo",children:"Key Features of Gazebo"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Physics Simulation"}),": Multiple physics engines (ODE, Bullet, Simbody) for different simulation needs"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sensor Simulation"}),": Realistic models for cameras, LIDAR, IMU, force/torque sensors, and more"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"3D Visualization"}),": High-quality rendering with dynamic lighting and realistic materials"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ROS Integration"}),": Native support for ROS/ROS 2 communication patterns"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"World Building"}),": Tools for creating complex environments with static and dynamic objects"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Plugin Architecture"}),": Extensible system for custom sensors, controllers, and simulation components"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"gazebo-architecture",children:"Gazebo Architecture"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo follows a client-server architecture where:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Gazebo Server"}),": Runs the physics simulation and handles all simulation logic"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Gazebo Client"}),": Provides the graphical user interface and visualization"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Communication"}),": Uses transport protocols for inter-process communication between server and clients"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"physics-engine-fundamentals",children:"Physics Engine Fundamentals"}),"\n",(0,s.jsx)(e.p,{children:"The physics engine is the core of Gazebo simulation, responsible for computing realistic physical interactions between objects. Understanding physics engine configuration is crucial for creating stable and accurate simulations."}),"\n",(0,s.jsx)(e.h3,{id:"available-physics-engines",children:"Available Physics Engines"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo supports three main physics engines, each with different strengths:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"ODE (Open Dynamics Engine)"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Default engine with good performance for most applications"}),"\n",(0,s.jsx)(e.li,{children:"Excellent for contact simulation and stable for humanoid robots"}),"\n",(0,s.jsx)(e.li,{children:"Well-tested and widely used in robotics research"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Bullet Physics"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Faster for complex collision detection scenarios"}),"\n",(0,s.jsx)(e.li,{children:"Better performance with large numbers of objects"}),"\n",(0,s.jsx)(e.li,{children:"Good for dynamic environments with many moving parts"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Simbody"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"High-accuracy multibody dynamics"}),"\n",(0,s.jsx)(e.li,{children:"Excellent for complex kinematic chains"}),"\n",(0,s.jsx)(e.li,{children:"Suitable for precise humanoid motion simulation"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"physics-engine-configuration",children:"Physics Engine Configuration"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example physics configuration in SDF --\x3e\n<physics name="default_physics" type="ode">\n  <gravity>0 0 -9.8</gravity>\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>1000</iters>\n      <sor>1.3</sor>\n    </solver>\n    <constraints>\n      <cfm>0.000001</cfm>\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>100</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>1000</real_time_update_rate>\n</physics>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"key-physics-parameters",children:"Key Physics Parameters"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Gravity"}),": Sets the gravitational acceleration (typically 9.8 m/s\xb2 on Earth)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Max Step Size"}),": Time step for physics integration (smaller = more accurate but slower)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Real Time Factor"}),": Controls simulation speed relative to real time"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Solver Iterations"}),": Number of iterations for constraint solving (more = stable but slower)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"CFM (Constraint Force Mixing)"}),": Softness parameter for constraints"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ERP (Error Reduction Parameter)"}),": How quickly constraint errors are corrected"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"sensor-simulation-in-gazebo",children:"Sensor Simulation in Gazebo"}),"\n",(0,s.jsx)(e.p,{children:"Realistic sensor simulation is crucial for developing robust perception and control systems. Gazebo provides detailed models for various sensor types with realistic noise characteristics."}),"\n",(0,s.jsx)(e.h3,{id:"camera-sensors",children:"Camera Sensors"}),"\n",(0,s.jsx)(e.p,{children:"Camera sensors in Gazebo can simulate various types of cameras with realistic parameters:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<sensor name="camera" type="camera">\n  <always_on>1</always_on>\n  <update_rate>30</update_rate>\n  <pose>0.1 0 0.1 0 0 0</pose>\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov>\n    <image>\n      <width>640</width>\n      <height>480</height>\n      <format>R8G8B8</format>\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>100</far>\n    </clip>\n    <noise>\n      <type>gaussian</type>\n      <mean>0.0</mean>\n      <stddev>0.007</stddev>\n    </noise>\n  </camera>\n  <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n    <frame_name>camera_link</frame_name>\n    <topic_name>camera/image_raw</topic_name>\n  </plugin>\n</sensor>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"lidar-and-range-sensors",children:"LIDAR and Range Sensors"}),"\n",(0,s.jsx)(e.p,{children:"LIDAR sensors are essential for navigation and environment perception:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<sensor name="laser" type="ray">\n  <always_on>1</always_on>\n  <update_rate>40</update_rate>\n  <pose>0.1 0 0.1 0 0 0</pose>\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>720</samples>\n        <resolution>1</resolution>\n        <min_angle>-1.570796</min_angle>\n        <max_angle>1.570796</max_angle>\n      </horizontal>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>30.0</max>\n      <resolution>0.01</resolution>\n    </range>\n    <noise>\n      <type>gaussian</type>\n      <mean>0.0</mean>\n      <stddev>0.01</stddev>\n    </noise>\n  </ray>\n  <plugin name="laser_controller" filename="libgazebo_ros_laser.so">\n    <topicName>scan</topicName>\n    <frameName>laser_link</frameName>\n  </plugin>\n</sensor>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"imu-sensors",children:"IMU Sensors"}),"\n",(0,s.jsx)(e.p,{children:"IMU sensors are critical for humanoid robot balance and orientation:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<sensor name="imu_sensor" type="imu">\n  <always_on>1</always_on>\n  <update_rate>100</update_rate>\n  <pose>0 0 0 0 0 0</pose>\n  <topic>imu/data</topic>\n  <imu>\n    <angular_velocity>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n          <bias_mean>0.0000075</bias_mean>\n          <bias_stddev>0.0000008</bias_stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n          <bias_mean>0.0000075</bias_mean>\n          <bias_stddev>0.0000008</bias_stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n          <bias_mean>0.0000075</bias_mean>\n          <bias_stddev>0.0000008</bias_stddev>\n        </noise>\n      </z>\n    </angular_velocity>\n    <linear_acceleration>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n          <bias_mean>0.017</bias_mean>\n          <bias_stddev>0.0017</bias_stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n          <bias_mean>0.017</bias_mean>\n          <bias_stddev>0.0017</bias_stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n          <bias_mean>0.017</bias_mean>\n          <bias_stddev>0.0017</bias_stddev>\n        </noise>\n      </z>\n    </linear_acceleration>\n  </imu>\n</sensor>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"world-building-and-environment-design",children:"World Building and Environment Design"}),"\n",(0,s.jsx)(e.p,{children:"Creating realistic environments is essential for testing humanoid robots in scenarios that closely match real-world conditions."}),"\n",(0,s.jsx)(e.h3,{id:"basic-world-structure",children:"Basic World Structure"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="humanoid_test_world">\n    \x3c!-- Physics configuration --\x3e\n    <physics name="default_physics" type="ode">\n      <gravity>0 0 -9.8</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>1000</iters>\n          <sor>1.3</sor>\n        </solver>\n        <constraints>\n          <cfm>0.000001</cfm>\n          <erp>0.2</erp>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Environment lighting --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>-0.3 0.3 -1</direction>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <model name="ground_plane" static="true">\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>1.0</mu>\n                <mu2>1.0</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.7 0.7 0.7 1</ambient>\n            <diffuse>0.7 0.7 0.7 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Add robot --\x3e\n    <include>\n      <uri>model://humanoid_robot</uri>\n      <pose>0 0 1.0 0 0 0</pose>\n    </include>\n\n    \x3c!-- Add obstacles and objects --\x3e\n    <model name="table">\n      <static>true</static>\n      <link name="table_link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1.0 0.8 0.8</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1.0 0.8 0.8</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.6 0.4 1</ambient>\n            <diffuse>0.8 0.6 0.4 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"advanced-environment-features",children:"Advanced Environment Features"}),"\n",(0,s.jsx)(e.h4,{id:"heightmaps-for-terrain",children:"Heightmaps for Terrain"}),"\n",(0,s.jsx)(e.p,{children:"For outdoor environments with complex terrain:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<model name="terrain" static="true">\n  <link name="link">\n    <collision name="collision">\n      <geometry>\n        <heightmap>\n          <uri>file://terrain_heightmap.png</uri>\n          <size>100 100 20</size>\n          <pos>0 0 0</pos>\n        </heightmap>\n      </geometry>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <heightmap>\n          <uri>file://terrain_texture.png</uri>\n          <size>100 100 20</size>\n          <pos>0 0 0</pos>\n        </heightmap>\n      </geometry>\n    </visual>\n  </link>\n</model>\n'})}),"\n",(0,s.jsx)(e.h4,{id:"dynamic-objects",children:"Dynamic Objects"}),"\n",(0,s.jsx)(e.p,{children:"For objects that move or change during simulation:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<model name="moving_object" static="false">\n  <link name="link">\n    <inertial>\n      <mass>1.0</mass>\n      <inertia>\n        <ixx>0.1</ixx>\n        <ixy>0</ixy>\n        <ixz>0</ixz>\n        <iyy>0.1</iyy>\n        <iyz>0</iyz>\n        <izz>0.1</izz>\n      </inertia>\n    </inertial>\n    <visual name="visual">\n      <geometry>\n        <sphere>\n          <radius>0.1</radius>\n        </sphere>\n      </geometry>\n    </visual>\n    <collision name="collision">\n      <geometry>\n        <sphere>\n          <radius>0.1</radius>\n        </sphere>\n      </geometry>\n    </collision>\n  </link>\n</model>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(e.p,{children:"Large-scale humanoid robot simulations require careful performance optimization to maintain real-time execution."}),"\n",(0,s.jsx)(e.h3,{id:"simulation-optimization-strategies",children:"Simulation Optimization Strategies"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Reduce Update Rates"}),": Lower sensor update rates when possible"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Simplify Collision Geometry"}),": Use simpler shapes for collision detection"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Adjust Physics Parameters"}),": Optimize time steps and solver iterations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Limit Model Complexity"}),": Reduce polygon count in visual meshes"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use Static Models"}),": Mark non-moving objects as static"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"multi-model-optimization",children:"Multi-Model Optimization"}),"\n",(0,s.jsx)(e.p,{children:"For complex humanoid robots with many degrees of freedom:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Optimize physics for humanoid joints --\x3e\n<joint name="knee_joint" type="revolute">\n  <axis>\n    <limit>\n      <lower>-0.5</lower>\n      <upper>2.0</upper>\n      <effort>200</effort>\n      <velocity>1.0</velocity>\n    </limit>\n    <dynamics>\n      <damping>1.0</damping>\n      <friction>0.5</friction>\n    </dynamics>\n  </axis>\n</joint>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"integration-with-ros-2",children:"Integration with ROS 2"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo integrates seamlessly with ROS 2 through plugins that enable communication between simulation and ROS 2 nodes."}),"\n",(0,s.jsx)(e.h3,{id:"gazebo-ros-2-bridge",children:"Gazebo-ROS 2 Bridge"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Gazebo plugin for ROS 2 control --\x3e\n<gazebo>\n  <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">\n    <robotNamespace>/humanoid_robot</robotNamespace>\n    <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"launching-simulation-with-ros-2",children:"Launching Simulation with ROS 2"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"# launch/humanoid_simulation.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Launch arguments\n    declare_world_file = DeclareLaunchArgument(\n        'world',\n        default_value='humanoid_test_world.sdf',\n        description='Choose one of the world files from `/my_robot_gazebo/worlds`'\n    )\n\n    # Gazebo launch\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': PathJoinSubstitution([\n                FindPackageShare('my_robot_gazebo'),\n                'worlds',\n                LaunchConfiguration('world')\n            ])\n        }.items()\n    )\n\n    # Robot state publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        parameters=[{\n            'use_sim_time': True,\n            'robot_description': open('/path/to/robot.urdf', 'r').read()\n        }]\n    )\n\n    # Spawn robot in Gazebo\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', 'humanoid_robot',\n            '-x', '0', '-y', '0', '-z', '1.0'\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        declare_world_file,\n        gazebo,\n        robot_state_publisher,\n        spawn_entity,\n    ])\n"})}),"\n",(0,s.jsx)(e.h2,{id:"best-practices-for-humanoid-robot-simulation",children:"Best Practices for Humanoid Robot Simulation"}),"\n",(0,s.jsx)(e.h3,{id:"1-stable-physics-configuration",children:"1. Stable Physics Configuration"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Use appropriate friction coefficients for humanoid feet to prevent sliding"}),"\n",(0,s.jsx)(e.li,{children:"Configure joint damping to match real-world behavior"}),"\n",(0,s.jsx)(e.li,{children:"Set realistic contact properties for stable walking"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"2-realistic-sensor-models",children:"2. Realistic Sensor Models"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Include appropriate noise models that match real sensors"}),"\n",(0,s.jsx)(e.li,{children:"Configure update rates that reflect actual hardware capabilities"}),"\n",(0,s.jsx)(e.li,{children:"Test sensor fusion algorithms with realistic data"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"3-gradual-complexity-increase",children:"3. Gradual Complexity Increase"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Start with simple environments and basic behaviors"}),"\n",(0,s.jsx)(e.li,{children:"Gradually increase complexity as stability improves"}),"\n",(0,s.jsx)(e.li,{children:"Validate each component before adding complexity"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"4-simulation-to-reality-transfer",children:"4. Simulation-to-Reality Transfer"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Document differences between simulation and real hardware"}),"\n",(0,s.jsx)(e.li,{children:"Implement system identification to tune simulation parameters"}),"\n",(0,s.jsx)(e.li,{children:"Use domain randomization techniques to improve transferability"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(e.p,{children:"Gazebo simulation provides the essential infrastructure for developing and testing humanoid robots in controlled virtual environments. By mastering physics configuration, sensor simulation, and world building, you can create realistic simulation environments that enable effective development and validation of Physical AI systems before real-world deployment."}),"\n",(0,s.jsx)(e.p,{children:"The integration between Gazebo and ROS 2 creates a powerful platform for simulation-to-reality workflows, allowing for seamless testing of complex humanoid behaviors in virtual environments that closely match real-world conditions."})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>t});var s=i(6540);const a={},o=s.createContext(a);function r(n){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),s.createElement(o.Provider,{value:e},n.children)}}}]);