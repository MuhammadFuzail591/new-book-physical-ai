"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[6163],{8048:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>t,toc:()=>c});var i=s(4848),r=s(8453);const l={title:"Nodes and Topics in ROS 2"},o="Nodes and Topics in ROS 2",t={id:"ros2-architecture/nodes-topics",title:"Nodes and Topics in ROS 2",description:"Introduction",source:"@site/docs/physical-ai/ros2-architecture/nodes-topics.mdx",sourceDirName:"ros2-architecture",slug:"/ros2-architecture/nodes-topics",permalink:"/ros2-architecture/nodes-topics",draft:!1,unlisted:!1,editUrl:"https://github.com/MuhammadFuzail591/new-book-physical-ai/tree/main/docs/physical-ai/ros2-architecture/nodes-topics.mdx",tags:[],version:"current",frontMatter:{title:"Nodes and Topics in ROS 2"},sidebar:"tutorialSidebar",previous:{title:"Chapter 3 - Understanding the Robotic Nervous System: ROS 2 Architecture",permalink:"/ros2-architecture/"},next:{title:"Services and Actions in ROS 2",permalink:"/ros2-architecture/services-actions"}},a={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Understanding Nodes",id:"understanding-nodes",level:2},{value:"What is a Node?",id:"what-is-a-node",level:3},{value:"Node Lifecycle",id:"node-lifecycle",level:3},{value:"Lifecycle States",id:"lifecycle-states",level:4},{value:"Lifecycle Transitions",id:"lifecycle-transitions",level:4},{value:"Node Implementation Patterns",id:"node-implementation-patterns",level:3},{value:"Simple Node Pattern",id:"simple-node-pattern",level:4},{value:"Sensor Node Pattern",id:"sensor-node-pattern",level:4},{value:"Node Best Practices",id:"node-best-practices",level:3},{value:"Proper Resource Management",id:"proper-resource-management",level:4},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:4},{value:"Understanding Topics",id:"understanding-topics",level:2},{value:"Topic Communication Model",id:"topic-communication-model",level:3},{value:"Topic Architecture",id:"topic-architecture",level:3},{value:"Publisher-Subscriber Relationship",id:"publisher-subscriber-relationship",level:4},{value:"Message Flow",id:"message-flow",level:4},{value:"Topic Implementation",id:"topic-implementation",level:3},{value:"Publisher Implementation",id:"publisher-implementation",level:4},{value:"Subscriber Implementation",id:"subscriber-implementation",level:4},{value:"Quality of Service (QoS) in Topics",id:"quality-of-service-qos-in-topics",level:2},{value:"QoS Policies for Topics",id:"qos-policies-for-topics",level:3},{value:"Reliability Policy",id:"reliability-policy",level:4},{value:"Durability Policy",id:"durability-policy",level:4},{value:"History Policy",id:"history-policy",level:4},{value:"Practical QoS Examples",id:"practical-qos-examples",level:3},{value:"Sensor Data QoS",id:"sensor-data-qos",level:4},{value:"Control Command QoS",id:"control-command-qos",level:4},{value:"Advanced Topic Patterns",id:"advanced-topic-patterns",level:2},{value:"Multiple Publishers/Single Subscriber Pattern",id:"multiple-publisherssingle-subscriber-pattern",level:3},{value:"Single Publisher/Multiple Subscribers Pattern",id:"single-publishermultiple-subscribers-pattern",level:3},{value:"Topic Monitoring and Debugging",id:"topic-monitoring-and-debugging",level:2},{value:"Command Line Tools",id:"command-line-tools",level:3},{value:"Topic Inspection",id:"topic-inspection",level:4},{value:"Topic Manipulation",id:"topic-manipulation",level:4},{value:"Programmatic Monitoring",id:"programmatic-monitoring",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Message Optimization",id:"message-optimization",level:3},{value:"Message Size",id:"message-size",level:4},{value:"Message Frequency",id:"message-frequency",level:4},{value:"Memory Management",id:"memory-management",level:3},{value:"Network Considerations",id:"network-considerations",level:3},{value:"Bandwidth Management",id:"bandwidth-management",level:4},{value:"Latency Optimization",id:"latency-optimization",level:4},{value:"Integration with Physical AI Systems",id:"integration-with-physical-ai-systems",level:2},{value:"Sensor Integration Patterns",id:"sensor-integration-patterns",level:3},{value:"Multi-Sensor Data Flow",id:"multi-sensor-data-flow",level:4},{value:"Real-time Considerations",id:"real-time-considerations",level:3},{value:"Real-time Scheduling for Nodes",id:"real-time-scheduling-for-nodes",level:4},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Node Design",id:"node-design",level:3},{value:"Topic Design",id:"topic-design",level:3},{value:"Performance",id:"performance",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"nodes-and-topics-in-ros-2",children:"Nodes and Topics in ROS 2"}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Nodes and topics form the fundamental communication infrastructure of ROS 2, enabling asynchronous, decoupled communication between different components of a robotic system. This publish/subscribe pattern allows for flexible, scalable architectures where components can be developed, tested, and deployed independently while maintaining seamless communication."}),"\n",(0,i.jsx)(n.h2,{id:"understanding-nodes",children:"Understanding Nodes"}),"\n",(0,i.jsx)(n.h3,{id:"what-is-a-node",children:"What is a Node?"}),"\n",(0,i.jsx)(n.p,{children:"A node in ROS 2 is an executable process that performs computation. Nodes are the basic building blocks of a ROS 2 system, and they can:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Publish messages to topics"}),"\n",(0,i.jsx)(n.li,{children:"Subscribe to topics to receive messages"}),"\n",(0,i.jsx)(n.li,{children:"Provide services"}),"\n",(0,i.jsx)(n.li,{children:"Call services"}),"\n",(0,i.jsx)(n.li,{children:"Execute actions"}),"\n",(0,i.jsx)(n.li,{children:"Declare and use parameters"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 nodes follow a well-defined lifecycle that enables better system management:"}),"\n",(0,i.jsx)(n.h4,{id:"lifecycle-states",children:"Lifecycle States"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unconfigured"}),": Node created but not yet configured"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Inactive"}),": Node configured but not active"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Active"}),": Node running and performing its function"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Finalized"}),": Node has been shut down"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"lifecycle-transitions",children:"Lifecycle Transitions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from rclpy.lifecycle import LifecycleNode\nfrom rclpy.lifecycle import TransitionCallbackReturn\n\nclass LifecycleExampleNode(LifecycleNode):\n    def on_configure(self, state):\n        """Called when transitioning to INACTIVE state."""\n        self.get_logger().info(\'Configuring node...\')\n        # Setup resources, initialize variables\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_activate(self, state):\n        """Called when transitioning to ACTIVE state."""\n        self.get_logger().info(\'Activating node...\')\n        # Start timers, enable publishers/subscribers\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_deactivate(self, state):\n        """Called when transitioning from ACTIVE state."""\n        self.get_logger().info(\'Deactivating node...\')\n        # Stop timers, disable publishers/subscribers\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_cleanup(self, state):\n        """Called when transitioning from INACTIVE to UNCONFIGURED."""\n        self.get_logger().info(\'Cleaning up node...\')\n        # Release resources\n        return TransitionCallbackReturn.SUCCESS\n'})}),"\n",(0,i.jsx)(n.h3,{id:"node-implementation-patterns",children:"Node Implementation Patterns"}),"\n",(0,i.jsx)(n.h4,{id:"simple-node-pattern",children:"Simple Node Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass SimpleNode(Node):\n    def __init__(self):\n        super().__init__('simple_node')\n        self.get_logger().info('Simple node initialized')\n\n        # Create a timer for periodic execution\n        self.timer = self.create_timer(1.0, self.timer_callback)\n        self.counter = 0\n\n    def timer_callback(self):\n        self.get_logger().info(f'Counter: {self.counter}')\n        self.counter += 1\n"})}),"\n",(0,i.jsx)(n.h4,{id:"sensor-node-pattern",children:"Sensor Node Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nimport random\n\nclass SensorNode(Node):\n    def __init__(self):\n        super().__init__('sensor_node')\n\n        # Create publisher for sensor data\n        self.publisher = self.create_publisher(\n            LaserScan,\n            'laser_scan',\n            10\n        )\n\n        # Simulate sensor readings\n        self.timer = self.create_timer(0.1, self.publish_sensor_data)\n\n    def publish_sensor_data(self):\n        msg = LaserScan()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'laser_frame'\n\n        # Simulate 360 degree scan with random values\n        msg.ranges = [random.uniform(0.1, 10.0) for _ in range(360)]\n\n        self.publisher.publish(msg)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"node-best-practices",children:"Node Best Practices"}),"\n",(0,i.jsx)(n.h4,{id:"proper-resource-management",children:"Proper Resource Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Initialize resources in constructor"}),"\n",(0,i.jsx)(n.li,{children:"Clean up resources in destructor or lifecycle callbacks"}),"\n",(0,i.jsx)(n.li,{children:"Use try/finally blocks for critical resource management"}),"\n",(0,i.jsx)(n.li,{children:"Implement proper error handling"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def robust_timer_callback(self):\n    try:\n        # Perform critical operation\n        result = self.perform_operation()\n        self.publish_result(result)\n    except Exception as e:\n        self.get_logger().error(f'Error in timer callback: {e}')\n        # Implement recovery strategy\n        self.handle_error(e)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"understanding-topics",children:"Understanding Topics"}),"\n",(0,i.jsx)(n.h3,{id:"topic-communication-model",children:"Topic Communication Model"}),"\n",(0,i.jsx)(n.p,{children:"Topics implement the publish/subscribe communication pattern where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Publishers"})," send messages to topics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Subscribers"})," receive messages from topics"]}),"\n",(0,i.jsx)(n.li,{children:"Communication is asynchronous and decoupled"}),"\n",(0,i.jsx)(n.li,{children:"Multiple publishers and subscribers can exist for the same topic"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"topic-architecture",children:"Topic Architecture"}),"\n",(0,i.jsx)(n.h4,{id:"publisher-subscriber-relationship",children:"Publisher-Subscriber Relationship"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[Publisher Node] ----\x3e [Topic] <---- [Subscriber Node]\n      |                     |\n      |                     |\n      V                     V\n   Send Data            Receive Data\n"})}),"\n",(0,i.jsx)(n.h4,{id:"message-flow",children:"Message Flow"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Publisher creates a message object"}),"\n",(0,i.jsx)(n.li,{children:"Publisher fills the message with data"}),"\n",(0,i.jsx)(n.li,{children:"Publisher calls publish() method"}),"\n",(0,i.jsx)(n.li,{children:"ROS 2 middleware handles message delivery"}),"\n",(0,i.jsx)(n.li,{children:"Subscribers receive the message through callbacks"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"topic-implementation",children:"Topic Implementation"}),"\n",(0,i.jsx)(n.h4,{id:"publisher-implementation",children:"Publisher Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Int32\nfrom geometry_msgs.msg import Twist\n\nclass PublisherNode(Node):\n    def __init__(self):\n        super().__init__('publisher_node')\n\n        # Create multiple publishers for different topics\n        self.string_publisher = self.create_publisher(\n            String,\n            'chatter',\n            10  # QoS history depth\n        )\n\n        self.cmd_vel_publisher = self.create_publisher(\n            Twist,\n            'cmd_vel',\n            10\n        )\n\n        # Timer to periodically publish messages\n        self.timer = self.create_timer(0.5, self.publish_messages)\n        self.counter = 0\n\n    def publish_messages(self):\n        # Publish string message\n        string_msg = String()\n        string_msg.data = f'Hello World: {self.counter}'\n        self.string_publisher.publish(string_msg)\n\n        # Publish velocity command\n        cmd_msg = Twist()\n        cmd_msg.linear.x = 0.5  # Move forward at 0.5 m/s\n        cmd_msg.angular.z = 0.2  # Rotate at 0.2 rad/s\n        self.cmd_vel_publisher.publish(cmd_msg)\n\n        self.counter += 1\n"})}),"\n",(0,i.jsx)(n.h4,{id:"subscriber-implementation",children:"Subscriber Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom geometry_msgs.msg import Twist\n\nclass SubscriberNode(Node):\n    def __init__(self):\n        super().__init__('subscriber_node')\n\n        # Create subscribers for different topics\n        self.string_subscriber = self.create_subscription(\n            String,\n            'chatter',\n            self.string_callback,\n            10  # QoS history depth\n        )\n\n        self.cmd_vel_subscriber = self.create_subscription(\n            Twist,\n            'cmd_vel',\n            self.cmd_vel_callback,\n            10\n        )\n\n    def string_callback(self, msg):\n        self.get_logger().info(f'Received string: {msg.data}')\n\n    def cmd_vel_callback(self, msg):\n        self.get_logger().info(\n            f'Received velocity command: '\n            f'linear.x={msg.linear.x}, angular.z={msg.angular.z}'\n        )\n"})}),"\n",(0,i.jsx)(n.h2,{id:"quality-of-service-qos-in-topics",children:"Quality of Service (QoS) in Topics"}),"\n",(0,i.jsx)(n.h3,{id:"qos-policies-for-topics",children:"QoS Policies for Topics"}),"\n",(0,i.jsx)(n.p,{children:"QoS policies determine how messages are handled by the DDS middleware:"}),"\n",(0,i.jsx)(n.h4,{id:"reliability-policy",children:"Reliability Policy"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy\n\n# For critical data where delivery is essential\ncritical_qos = QoSProfile(\n    reliability=ReliabilityPolicy.RELIABLE,\n    history=QoSHistoryPolicy.KEEP_LAST,\n    depth=10\n)\n\n# For high-frequency data where some loss is acceptable\nhigh_freq_qos = QoSProfile(\n    reliability=ReliabilityPolicy.BEST_EFFORT,\n    history=QoSHistoryPolicy.KEEP_LAST,\n    depth=1\n)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"durability-policy",children:"Durability Policy"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import DurabilityPolicy\n\n# For configuration data that should be available to late-joining subscribers\ntransient_qos = QoSProfile(\n    durability=DurabilityPolicy.TRANSIENT_LOCAL,\n    history=QoSHistoryPolicy.KEEP_ALL\n)\n\n# For regular data where only future messages matter\nvolatile_qos = QoSProfile(\n    durability=DurabilityPolicy.VOLATILE,\n    history=QoSHistoryPolicy.KEEP_LAST,\n    depth=10\n)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"history-policy",children:"History Policy"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import HistoryPolicy\n\n# Keep only the most recent messages\nlast_5_qos = QoSProfile(\n    history=HistoryPolicy.KEEP_LAST,\n    depth=5\n)\n\n# Keep all messages (be careful with memory usage)\nall_qos = QoSProfile(\n    history=HistoryPolicy.KEEP_ALL\n)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"practical-qos-examples",children:"Practical QoS Examples"}),"\n",(0,i.jsx)(n.h4,{id:"sensor-data-qos",children:"Sensor Data QoS"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# High-frequency sensor data (e.g., IMU, camera)\nsensor_qos = QoSProfile(\n    reliability=ReliabilityPolicy.BEST_EFFORT,\n    durability=DurabilityPolicy.VOLATILE,\n    history=QoSHistoryPolicy.KEEP_LAST,\n    depth=1  # Only keep the most recent message\n)\n\n# Critical sensor data (e.g., emergency stop)\ncritical_sensor_qos = QoSProfile(\n    reliability=ReliabilityPolicy.RELIABLE,\n    durability=DurabilityPolicy.VOLATILE,\n    history=QoSHistoryPolicy.KEEP_LAST,\n    depth=10\n)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"control-command-qos",children:"Control Command QoS"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Robot control commands (velocity, joint positions)\ncontrol_qos = QoSProfile(\n    reliability=ReliabilityPolicy.RELIABLE,\n    durability=DurabilityPolicy.VOLATILE,\n    history=QoSHistoryPolicy.KEEP_LAST,\n    depth=1  # Only use the most recent command\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-topic-patterns",children:"Advanced Topic Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"multiple-publisherssingle-subscriber-pattern",children:"Multiple Publishers/Single Subscriber Pattern"}),"\n",(0,i.jsx)(n.p,{children:"This pattern is common in sensor fusion applications:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan, Imu, Image\nfrom std_msgs.msg import Header\n\nclass SensorFusionNode(Node):\n    def __init__(self):\n        super().__init__('sensor_fusion_node')\n\n        # Subscribe to multiple sensor streams\n        self.laser_sub = self.create_subscription(\n            LaserScan, 'laser_scan', self.laser_callback, 10\n        )\n        self.imu_sub = self.create_subscription(\n            Imu, 'imu_data', self.imu_callback, 10\n        )\n        self.camera_sub = self.create_subscription(\n            Image, 'camera/image_raw', self.camera_callback, 10\n        )\n\n        # Publish fused data\n        self.fused_publisher = self.create_publisher(\n            String, 'fused_sensor_data', 10\n        )\n\n        # Store sensor data for fusion\n        self.laser_data = None\n        self.imu_data = None\n        self.camera_data = None\n\n    def laser_callback(self, msg):\n        self.laser_data = msg\n        self.fuse_if_complete()\n\n    def imu_callback(self, msg):\n        self.imu_data = msg\n        self.fuse_if_complete()\n\n    def camera_callback(self, msg):\n        self.camera_data = msg\n        self.fuse_if_complete()\n\n    def fuse_if_complete(self):\n        if self.laser_data and self.imu_data and self.camera_data:\n            # Perform sensor fusion logic\n            fused_msg = String()\n            fused_msg.data = f\"Fused data at {self.get_clock().now()}\"\n            self.fused_publisher.publish(fused_msg)\n\n            # Reset for next fusion cycle\n            self.laser_data = None\n            self.imu_data = None\n            self.camera_data = None\n"})}),"\n",(0,i.jsx)(n.h3,{id:"single-publishermultiple-subscribers-pattern",children:"Single Publisher/Multiple Subscribers Pattern"}),"\n",(0,i.jsx)(n.p,{children:"This pattern is common for sharing processed data:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped\nimport time\n\nclass DataSharingNode(Node):\n    def __init__(self):\n        super().__init__('data_sharing_node')\n\n        # Single publisher for processed data\n        self.pose_publisher = self.create_publisher(\n            PoseStamped, 'robot_pose', 10\n        )\n\n        # Timer to periodically publish data\n        self.timer = self.create_timer(0.1, self.publish_pose)\n\n    def publish_pose(self):\n        msg = PoseStamped()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'map'\n\n        # Simulate robot pose (in real application, this would come from localization)\n        msg.pose.position.x = 1.0\n        msg.pose.position.y = 2.0\n        msg.pose.position.z = 0.0\n\n        self.pose_publisher.publish(msg)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"topic-monitoring-and-debugging",children:"Topic Monitoring and Debugging"}),"\n",(0,i.jsx)(n.h3,{id:"command-line-tools",children:"Command Line Tools"}),"\n",(0,i.jsx)(n.h4,{id:"topic-inspection",children:"Topic Inspection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# List all topics\nros2 topic list\n\n# Get information about a specific topic\nros2 topic info /topic_name\n\n# Echo topic messages\nros2 topic echo /topic_name MessageType\n\n# Show message statistics\nros2 topic hz /topic_name\n\n# Show message delay\nros2 topic delay /topic_name\n"})}),"\n",(0,i.jsx)(n.h4,{id:"topic-manipulation",children:"Topic Manipulation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Publish a single message\nros2 topic pub /topic_name MessageType "field: value"\n\n# Publish messages at a rate\nros2 topic pub -r 1 /topic_name MessageType "field: value"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"programmatic-monitoring",children:"Programmatic Monitoring"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import qos_profile_sensor_data\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass TopicMonitorNode(Node):\n    def __init__(self):\n        super().__init__('topic_monitor')\n\n        # Subscribe with monitoring\n        self.subscriber = self.create_subscription(\n            String,\n            'monitored_topic',\n            self.monitored_callback,\n            qos_profile=qos_profile_sensor_data\n        )\n\n        # Statistics\n        self.message_count = 0\n        self.start_time = self.get_clock().now()\n\n    def monitored_callback(self, msg):\n        self.message_count += 1\n        current_time = self.get_clock().now()\n\n        # Log statistics every 100 messages\n        if self.message_count % 100 == 0:\n            elapsed = (current_time - self.start_time).nanoseconds / 1e9\n            rate = self.message_count / elapsed if elapsed > 0 else 0\n            self.get_logger().info(\n                f'Messages: {self.message_count}, Rate: {rate:.2f} Hz'\n            )\n\n        # Process the message\n        self.process_message(msg)\n\n    def process_message(self, msg):\n        # Implement message processing logic\n        pass\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"message-optimization",children:"Message Optimization"}),"\n",(0,i.jsx)(n.h4,{id:"message-size",children:"Message Size"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keep messages small to reduce bandwidth and latency"}),"\n",(0,i.jsx)(n.li,{children:"Use efficient data types (float32 instead of float64 when precision allows)"}),"\n",(0,i.jsx)(n.li,{children:"Consider compression for large data like images"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"message-frequency",children:"Message Frequency"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Balance between responsiveness and system load"}),"\n",(0,i.jsx)(n.li,{children:"Use appropriate QoS settings for different frequencies"}),"\n",(0,i.jsx)(n.li,{children:"Consider message throttling for high-frequency data"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Reuse message objects to reduce allocation overhead\nclass OptimizedPublisherNode(Node):\n    def __init__(self):\n        super().__init__('optimized_publisher')\n        self.publisher = self.create_publisher(String, 'optimized_topic', 10)\n\n        # Pre-allocate message object\n        self.msg = String()\n        self.timer = self.create_timer(0.01, self.optimized_publish)\n\n    def optimized_publish(self):\n        # Reuse the same message object\n        self.msg.data = f'Optimized message {self.get_clock().now().nanoseconds}'\n        self.publisher.publish(self.msg)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"network-considerations",children:"Network Considerations"}),"\n",(0,i.jsx)(n.h4,{id:"bandwidth-management",children:"Bandwidth Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Monitor network usage for multi-robot systems"}),"\n",(0,i.jsx)(n.li,{children:"Use appropriate QoS for network-constrained environments"}),"\n",(0,i.jsx)(n.li,{children:"Consider data filtering and preprocessing"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"latency-optimization",children:"Latency Optimization"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use reliable QoS for critical control data"}),"\n",(0,i.jsx)(n.li,{children:"Use best effort for non-critical high-frequency data"}),"\n",(0,i.jsx)(n.li,{children:"Consider local processing to reduce network dependencies"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-physical-ai-systems",children:"Integration with Physical AI Systems"}),"\n",(0,i.jsx)(n.h3,{id:"sensor-integration-patterns",children:"Sensor Integration Patterns"}),"\n",(0,i.jsx)(n.h4,{id:"multi-sensor-data-flow",children:"Multi-Sensor Data Flow"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class MultiSensorNode(Node):\n    def __init__(self):\n        super().__init__('multi_sensor_node')\n\n        # High-frequency sensors (best effort)\n        self.imu_sub = self.create_subscription(\n            Imu, 'imu/data', self.imu_callback,\n            qos_profile=qos_profile_sensor_data\n        )\n\n        # Critical sensors (reliable)\n        self.emergency_sub = self.create_subscription(\n            Bool, 'emergency_stop', self.emergency_callback,\n            qos_profile=qos_profile_services_default\n        )\n\n        # Control commands (reliable, small history)\n        self.cmd_pub = self.create_publisher(\n            Twist, 'cmd_vel',\n            qos_profile=qos_profile_services_default\n        )\n\n    def imu_callback(self, msg):\n        # Process high-frequency IMU data\n        self.process_imu_data(msg)\n\n    def emergency_callback(self, msg):\n        # Handle critical emergency signals\n        if msg.data:\n            self.emergency_stop()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"real-time-considerations",children:"Real-time Considerations"}),"\n",(0,i.jsx)(n.h4,{id:"real-time-scheduling-for-nodes",children:"Real-time Scheduling for Nodes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import os\nimport mmap\nfrom rclpy.qos import QoSProfile\n\nclass RealTimeNode(Node):\n    def __init__(self):\n        super().__init__('real_time_node')\n\n        # Lock memory to prevent page faults\n        self.lock_memory()\n\n        # Set up real-time publisher\n        self.rt_publisher = self.create_publisher(\n            String, 'real_time_topic',\n            QoSProfile(\n                reliability=ReliabilityPolicy.RELIABLE,\n                history=QoSHistoryPolicy.KEEP_LAST,\n                depth=1\n            )\n        )\n\n        # Use real-time timer\n        self.rt_timer = self.create_timer(\n            0.001,  # 1ms period\n            self.real_time_callback,\n            clock=Clock(clock_type=ClockType.STEADY_TIME)\n        )\n\n    def lock_memory(self):\n        # Lock current process memory to prevent page faults\n        try:\n            mmap.mmap(-1, os.sysconf('SC_PAGE_SIZE'), flags=mmap.MAP_ANONYMOUS | mmap.MAP_LOCKED)\n        except Exception as e:\n            self.get_logger().warn(f'Could not lock memory: {e}')\n\n    def real_time_callback(self):\n        # Real-time critical operation\n        msg = String()\n        msg.data = f'Real-time: {self.get_clock().now()}'\n        self.rt_publisher.publish(msg)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,i.jsx)(n.h3,{id:"node-design",children:"Node Design"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Responsibility"}),": Each node should have one clear purpose"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Proper Lifecycle"}),": Implement lifecycle management for complex nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Include robust error handling and recovery"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Management"}),": Properly initialize and clean up resources"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"topic-design",children:"Topic Design"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Appropriate QoS"}),": Choose QoS policies based on data requirements"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Optimization"}),": Keep messages efficient and appropriately sized"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Naming Conventions"}),": Use clear, consistent topic naming"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Documentation"}),": Document topic purposes and message formats"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitor Usage"}),": Track message rates and system load"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optimize Frequency"}),": Balance between performance and system load"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Management"}),": Reuse objects and manage memory efficiently"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Network Awareness"}),": Consider network constraints in multi-robot systems"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,i.jsx)(n.p,{children:"Nodes and topics form the backbone of ROS 2's communication architecture, providing the asynchronous, decoupled communication necessary for complex robotic systems. Understanding proper node implementation, topic usage, and Quality of Service policies is essential for building robust, efficient robotic applications."}),"\n",(0,i.jsx)(n.p,{children:"The publish/subscribe pattern enables flexible system architectures where components can be developed independently while maintaining seamless communication. Proper QoS selection ensures that different types of data (critical vs. high-frequency) are handled appropriately."}),"\n",(0,i.jsx)(n.p,{children:"These concepts are fundamental to coordinating the complex sensor and actuator systems required in Physical AI applications, particularly in humanoid robots where multiple subsystems must communicate effectively to achieve coordinated behavior."}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Implementation"}),": Create a ROS 2 node that publishes sensor data with appropriate QoS settings and another node that subscribes to this data and performs basic processing."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Analysis"}),": Design a multi-sensor fusion system using nodes and topics. Identify which sensors would use reliable vs. best-effort QoS and justify your choices."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Optimization"}),": Implement a message optimization strategy where message objects are reused to reduce allocation overhead. Measure the performance improvement."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["ROS 2 Documentation: Quality of Service (QoS) - ",(0,i.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html",children:"https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html"})]}),"\n",(0,i.jsxs)(n.li,{children:["ROS 2 Design: Nodes and Topics - ",(0,i.jsx)(n.a,{href:"https://design.ros2.org/articles/topic_and_service_names.html",children:"https://design.ros2.org/articles/topic_and_service_names.html"})]}),"\n",(0,i.jsxs)(n.li,{children:["DDS Specification: Quality of Service - ",(0,i.jsx)(n.a,{href:"https://www.omg.org/spec/DDS/",children:"https://www.omg.org/spec/DDS/"})]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>t});var i=s(6540);const r={},l=i.createContext(r);function o(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);