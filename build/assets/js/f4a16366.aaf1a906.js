"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[4290],{5729:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>m,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>o});var n=r(4848),t=r(8453);const s={title:"Dynamic Parameters in ROS 2"},l="Dynamic Parameters in ROS 2",i={id:"ros2-advanced/parameters",title:"Dynamic Parameters in ROS 2",description:"Introduction to Dynamic Parameters",source:"@site/docs/physical-ai/ros2-advanced/parameters.mdx",sourceDirName:"ros2-advanced",slug:"/ros2-advanced/parameters",permalink:"/ros2-advanced/parameters",draft:!1,unlisted:!1,editUrl:"https://github.com/MuhammadFuzail591/new-book-physical-ai/tree/main/docs/physical-ai/ros2-advanced/parameters.mdx",tags:[],version:"current",frontMatter:{title:"Dynamic Parameters in ROS 2"},sidebar:"tutorialSidebar",previous:{title:"Chapter 6 - Advanced ROS 2 Concepts",permalink:"/ros2-advanced/"},next:{title:"Quality of Service (QoS) in ROS 2",permalink:"/ros2-advanced/quality-of-service"}},m={},o=[{value:"Introduction to Dynamic Parameters",id:"introduction-to-dynamic-parameters",level:2},{value:"Parameter Declaration and Management",id:"parameter-declaration-and-management",level:2},{value:"Declaring Parameters",id:"declaring-parameters",level:3},{value:"Parameter Types and Validation",id:"parameter-types-and-validation",level:3},{value:"Parameter Callbacks and Runtime Changes",id:"parameter-callbacks-and-runtime-changes",level:2},{value:"Setting Up Parameter Callbacks",id:"setting-up-parameter-callbacks",level:3},{value:"Advanced Parameter Management",id:"advanced-parameter-management",level:2},{value:"Hierarchical Parameter Organization",id:"hierarchical-parameter-organization",level:3},{value:"Parameter Services and Command-Line Tools",id:"parameter-services-and-command-line-tools",level:2},{value:"Using Parameter Services",id:"using-parameter-services",level:3},{value:"Best Practices for Parameter Management",id:"best-practices-for-parameter-management",level:2},{value:"Parameter Naming Conventions",id:"parameter-naming-conventions",level:3},{value:"Parameter Validation and Error Handling",id:"parameter-validation-and-error-handling",level:3},{value:"Launch File Integration",id:"launch-file-integration",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2}];function c(e){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.h1,{id:"dynamic-parameters-in-ros-2",children:"Dynamic Parameters in ROS 2"}),"\n",(0,n.jsx)(a.h2,{id:"introduction-to-dynamic-parameters",children:"Introduction to Dynamic Parameters"}),"\n",(0,n.jsx)(a.p,{children:"Dynamic parameters in ROS 2 represent a powerful feature that allows nodes to change their configuration at runtime without requiring a system restart. This capability is essential for robotic systems that need to adapt to changing environments, operational conditions, or user preferences without interrupting the robot's operation. Unlike static parameters that are set at launch time, dynamic parameters can be modified through various interfaces while the node is running."}),"\n",(0,n.jsx)(a.p,{children:"Dynamic parameters enable:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"Runtime adjustment of robot behavior"}),"\n",(0,n.jsx)(a.li,{children:"Adaptive control strategies based on environmental conditions"}),"\n",(0,n.jsx)(a.li,{children:"Remote configuration of robotic systems"}),"\n",(0,n.jsx)(a.li,{children:"A/B testing of different parameter values"}),"\n",(0,n.jsx)(a.li,{children:"Fine-tuning of algorithms without service interruption"}),"\n"]}),"\n",(0,n.jsx)(a.h2,{id:"parameter-declaration-and-management",children:"Parameter Declaration and Management"}),"\n",(0,n.jsx)(a.h3,{id:"declaring-parameters",children:"Declaring Parameters"}),"\n",(0,n.jsx)(a.p,{children:"In ROS 2, parameters must be declared before they can be used. This declaration process allows the node to specify default values, types, and constraints:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\nfrom rcl_interfaces.msg import ParameterDescriptor, FloatingPointRange, IntegerRange\n\nclass ParameterDeclarationNode(Node):\n    def __init__(self):\n        super().__init__('parameter_declaration_node')\n\n        # Declare a simple parameter with default value\n        self.declare_parameter('simple_value', 42)\n\n        # Declare parameter with descriptor for validation\n        self.declare_parameter(\n            'validated_speed',\n            0.5,\n            ParameterDescriptor(\n                description='Robot speed in m/s',\n                floating_point_range=[FloatingPointRange(from_value=0.0, to_value=5.0, step=0.1)]\n            )\n        )\n\n        # Declare parameter with integer constraints\n        self.declare_parameter(\n            'max_retries',\n            3,\n            ParameterDescriptor(\n                description='Maximum number of retry attempts',\n                integer_range=[IntegerRange(from_value=1, to_value=10, step=1)]\n            )\n        )\n\n        # Declare parameter that can only be set at launch\n        self.declare_parameter(\n            'robot_name',\n            'default_robot',\n            ParameterDescriptor(\n                description='Unique identifier for the robot',\n                read_only=True  # This parameter cannot be changed at runtime\n            )\n        )\n\n    def get_parameter_values(self):\n        \"\"\"Retrieve current parameter values\"\"\"\n        simple_value = self.get_parameter('simple_value').value\n        speed = self.get_parameter('validated_speed').value\n        retries = self.get_parameter('max_retries').value\n        name = self.get_parameter('robot_name').value\n\n        return {\n            'simple_value': simple_value,\n            'speed': speed,\n            'retries': retries,\n            'name': name\n        }\n"})}),"\n",(0,n.jsx)(a.h3,{id:"parameter-types-and-validation",children:"Parameter Types and Validation"}),"\n",(0,n.jsx)(a.p,{children:"ROS 2 supports various parameter types with built-in validation capabilities:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:"from rcl_interfaces.msg import ParameterType\n\nclass ParameterTypesNode(Node):\n    def __init__(self):\n        super().__init__('parameter_types_node')\n\n        # String parameter with allowed values\n        self.declare_parameter(\n            'control_mode',\n            'velocity',\n            ParameterDescriptor(\n                description='Control mode: velocity, position, or effort',\n                additional_constraints='Must be one of: velocity, position, effort'\n            )\n        )\n\n        # Boolean parameter\n        self.declare_parameter('debug_mode', False)\n\n        # Array parameters\n        self.declare_parameter('sensor_offsets', [0.0, 0.0, 0.0])\n\n        # Parameter with multiple type constraints\n        self.declare_parameter(\n            'threshold_values',\n            [0.1, 0.5, 0.9],\n            ParameterDescriptor(\n                description='List of threshold values for sensor fusion'\n            )\n        )\n\n    def validate_control_mode(self):\n        \"\"\"Validate and respond to control mode changes\"\"\"\n        control_mode = self.get_parameter('control_mode').value\n\n        valid_modes = ['velocity', 'position', 'effort']\n        if control_mode not in valid_modes:\n            self.get_logger().error(f'Invalid control mode: {control_mode}')\n            # Revert to a safe default\n            self.set_parameters([Parameter('control_mode', Parameter.Type.STRING, 'velocity')])\n            return False\n\n        self.get_logger().info(f'Control mode set to: {control_mode}')\n        return True\n"})}),"\n",(0,n.jsx)(a.h2,{id:"parameter-callbacks-and-runtime-changes",children:"Parameter Callbacks and Runtime Changes"}),"\n",(0,n.jsx)(a.h3,{id:"setting-up-parameter-callbacks",children:"Setting Up Parameter Callbacks"}),"\n",(0,n.jsx)(a.p,{children:"Parameter callbacks allow nodes to react to parameter changes in real-time:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:"from rclpy.parameter import Parameter\nfrom rcl_interfaces.msg import SetParametersResult\n\nclass ParameterCallbackNode(Node):\n    def __init__(self):\n        super().__init__('parameter_callback_node')\n\n        # Declare parameters\n        self.declare_parameter('linear_velocity_limit', 1.0)\n        self.declare_parameter('angular_velocity_limit', 1.0)\n        self.declare_parameter('safety_distance', 0.5)\n        self.declare_parameter('control_frequency', 50)\n\n        # Set up parameter callback\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n        # Initialize local variables\n        self.linear_limit = self.get_parameter('linear_velocity_limit').value\n        self.angular_limit = self.get_parameter('angular_velocity_limit').value\n        self.safety_dist = self.get_parameter('safety_distance').value\n        self.ctrl_freq = self.get_parameter('control_frequency').value\n\n        # Timer for periodic parameter checking\n        self.timer = self.create_timer(1.0, self.param_check_callback)\n\n    def parameter_callback(self, params):\n        \"\"\"Callback function for parameter changes\"\"\"\n        result = SetParametersResult()\n        result.successful = True\n\n        for param in params:\n            if param.name == 'linear_velocity_limit':\n                if param.value <= 0 or param.value > 5.0:\n                    result.successful = False\n                    result.reason = 'Linear velocity limit must be between 0 and 5.0'\n                    self.get_logger().error(result.reason)\n                    break\n                else:\n                    self.linear_limit = param.value\n                    self.get_logger().info(f'Linear velocity limit updated to: {param.value}')\n\n            elif param.name == 'angular_velocity_limit':\n                if param.value <= 0 or param.value > 3.0:\n                    result.successful = False\n                    result.reason = 'Angular velocity limit must be between 0 and 3.0'\n                    self.get_logger().error(result.reason)\n                    break\n                else:\n                    self.angular_limit = param.value\n                    self.get_logger().info(f'Angular velocity limit updated to: {param.value}')\n\n            elif param.name == 'safety_distance':\n                if param.value <= 0.05 or param.value > 2.0:\n                    result.successful = False\n                    result.reason = 'Safety distance must be between 0.05 and 2.0 meters'\n                    self.get_logger().error(result.reason)\n                    break\n                else:\n                    self.safety_dist = param.value\n                    self.get_logger().info(f'Safety distance updated to: {param.value}')\n\n            elif param.name == 'control_frequency':\n                if param.value < 10 or param.value > 200:\n                    result.successful = False\n                    result.reason = 'Control frequency must be between 10 and 200 Hz'\n                    self.get_logger().error(result.reason)\n                    break\n                else:\n                    self.ctrl_freq = param.value\n                    # Adjust timer period based on new frequency\n                    self.timer.timer_period_ns = int(1e9 / param.value)\n                    self.get_logger().info(f'Control frequency updated to: {param.value} Hz')\n\n        return result\n\n    def param_check_callback(self):\n        \"\"\"Periodically check and log parameter values\"\"\"\n        self.get_logger().debug(\n            f'Current params - Lin: {self.linear_limit}, '\n            f'Ang: {self.angular_limit}, '\n            f'Safe: {self.safety_dist}, '\n            f'Freq: {self.ctrl_freq}'\n        )\n"})}),"\n",(0,n.jsx)(a.h2,{id:"advanced-parameter-management",children:"Advanced Parameter Management"}),"\n",(0,n.jsx)(a.h3,{id:"hierarchical-parameter-organization",children:"Hierarchical Parameter Organization"}),"\n",(0,n.jsx)(a.p,{children:"For complex robotic systems, parameters can be organized hierarchically to improve maintainability:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:"class HierarchicalParameterNode(Node):\n    def __init__(self):\n        super().__init__('hierarchical_param_node')\n\n        # Navigation parameters\n        self.declare_parameter('navigation.linear_speed_max', 0.8)\n        self.declare_parameter('navigation.angular_speed_max', 1.0)\n        self.declare_parameter('navigation.min_obstacle_distance', 0.5)\n        self.declare_parameter('navigation.path_timeout', 5.0)\n\n        # Sensor parameters\n        self.declare_parameter('sensors.lidar.range_min', 0.1)\n        self.declare_parameter('sensors.lidar.range_max', 30.0)\n        self.declare_parameter('sensors.camera.focal_length', 500.0)\n        self.declare_parameter('sensors.imu.acceleration_scale', 1.0)\n\n        # Actuator parameters\n        self.declare_parameter('actuators.arm.max_torque', 50.0)\n        self.declare_parameter('actuators.gripper.force_limit', 100.0)\n        self.declare_parameter('actuators.wheel.max_rpm', 300)\n\n        # Initialize parameter groups\n        self._init_navigation_params()\n        self._init_sensor_params()\n        self._init_actuator_params()\n\n        # Set up comprehensive parameter callback\n        self.add_on_set_parameters_callback(self._comprehensive_param_callback)\n\n    def _init_navigation_params(self):\n        \"\"\"Initialize navigation parameter group\"\"\"\n        self.nav_params = {\n            'linear_speed_max': self.get_parameter('navigation.linear_speed_max').value,\n            'angular_speed_max': self.get_parameter('navigation.angular_speed_max').value,\n            'min_obstacle_distance': self.get_parameter('navigation.min_obstacle_distance').value,\n            'path_timeout': self.get_parameter('navigation.path_timeout').value\n        }\n\n    def _init_sensor_params(self):\n        \"\"\"Initialize sensor parameter group\"\"\"\n        self.sensor_params = {\n            'lidar_range_min': self.get_parameter('sensors.lidar.range_min').value,\n            'lidar_range_max': self.get_parameter('sensors.lidar.range_max').value,\n            'camera_focal_length': self.get_parameter('sensors.camera.focal_length').value,\n            'imu_accel_scale': self.get_parameter('sensors.imu.acceleration_scale').value\n        }\n\n    def _init_actuator_params(self):\n        \"\"\"Initialize actuator parameter group\"\"\"\n        self.actuator_params = {\n            'arm_max_torque': self.get_parameter('actuators.arm.max_torque').value,\n            'gripper_force_limit': self.get_parameter('actuators.gripper.force_limit').value,\n            'wheel_max_rpm': self.get_parameter('actuators.wheel.max_rpm').value\n        }\n\n    def _comprehensive_param_callback(self, params):\n        \"\"\"Handle parameter changes across all groups\"\"\"\n        result = SetParametersResult()\n        result.successful = True\n\n        for param in params:\n            # Handle navigation parameters\n            if param.name.startswith('navigation.'):\n                self._handle_navigation_param(param, result)\n            # Handle sensor parameters\n            elif param.name.startswith('sensors.'):\n                self._handle_sensor_param(param, result)\n            # Handle actuator parameters\n            elif param.name.startswith('actuators.'):\n                self._handle_actuator_param(param, result)\n\n            if not result.successful:\n                break\n\n        return result\n\n    def _handle_navigation_param(self, param, result):\n        \"\"\"Handle navigation-specific parameter changes\"\"\"\n        param_name = param.name.split('.')[-1]  # Get the specific parameter name\n\n        if param_name == 'linear_speed_max':\n            if param.value <= 0 or param.value > 5.0:\n                result.successful = False\n                result.reason = 'Linear speed must be between 0 and 5.0 m/s'\n                return\n            self.nav_params['linear_speed_max'] = param.value\n\n        elif param_name == 'angular_speed_max':\n            if param.value <= 0 or param.value > 5.0:\n                result.successful = False\n                result.reason = 'Angular speed must be between 0 and 5.0 rad/s'\n                return\n            self.nav_params['angular_speed_max'] = param.value\n\n        elif param_name == 'min_obstacle_distance':\n            if param.value <= 0.05 or param.value > 5.0:\n                result.successful = False\n                result.reason = 'Min obstacle distance must be between 0.05 and 5.0 m'\n                return\n            self.nav_params['min_obstacle_distance'] = param.value\n\n        elif param_name == 'path_timeout':\n            if param.value <= 0:\n                result.successful = False\n                result.reason = 'Path timeout must be positive'\n                return\n            self.nav_params['path_timeout'] = param.value\n\n        self.get_logger().info(f'Navigation parameter updated: {param.name} = {param.value}')\n\n    def _handle_sensor_param(self, param, result):\n        \"\"\"Handle sensor-specific parameter changes\"\"\"\n        param_name = param.name.split('.')[-1]\n\n        if param_name == 'lidar_range_min':\n            if param.value <= 0 or param.value >= self.sensor_params['lidar_range_max']:\n                result.successful = False\n                result.reason = 'LIDAR min range must be positive and less than max range'\n                return\n            self.sensor_params['lidar_range_min'] = param.value\n\n        elif param_name == 'lidar_range_max':\n            if param.value <= self.sensor_params['lidar_range_min']:\n                result.successful = False\n                result.reason = 'LIDAR max range must be greater than min range'\n                return\n            self.sensor_params['lidar_range_max'] = param.value\n\n        self.get_logger().info(f'Sensor parameter updated: {param.name} = {param.value}')\n\n    def _handle_actuator_param(self, param, result):\n        \"\"\"Handle actuator-specific parameter changes\"\"\"\n        param_name = param.name.split('.')[-1]\n\n        if param_name == 'max_torque':\n            if param.value <= 0:\n                result.successful = False\n                result.reason = 'Max torque must be positive'\n                return\n            self.actuator_params['arm_max_torque'] = param.value\n\n        self.get_logger().info(f'Actuator parameter updated: {param.name} = {param.value}')\n"})}),"\n",(0,n.jsx)(a.h2,{id:"parameter-services-and-command-line-tools",children:"Parameter Services and Command-Line Tools"}),"\n",(0,n.jsx)(a.h3,{id:"using-parameter-services",children:"Using Parameter Services"}),"\n",(0,n.jsx)(a.p,{children:"ROS 2 provides built-in services for parameter management that can be called programmatically:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:"from rclpy.callback_groups import ReentrantCallbackGroup\nfrom rcl_interfaces.srv import SetParameters, GetParameters, ListParameters\n\nclass ParameterServiceNode(Node):\n    def __init__(self):\n        super().__init__('parameter_service_node')\n\n        # Declare some parameters\n        self.declare_parameter('demo_param1', 100)\n        self.declare_parameter('demo_param2', 'hello')\n        self.declare_parameter('demo_param3', True)\n\n        # Create client for parameter services (for external access)\n        self.callback_group = ReentrantCallbackGroup()\n\n        # Service clients for parameter operations\n        self.set_param_cli = self.create_client(\n            SetParameters,\n            'set_parameters',\n            callback_group=self.callback_group\n        )\n        self.get_param_cli = self.create_client(\n            GetParameters,\n            'get_parameters',\n            callback_group=self.callback_group\n        )\n        self.list_param_cli = self.create_client(\n            ListParameters,\n            'list_parameters',\n            callback_group=self.callback_group\n        )\n\n        # Timer to demonstrate parameter services\n        self.demo_timer = self.create_timer(5.0, self.demo_parameter_services)\n\n    def demo_parameter_services(self):\n        \"\"\"Demonstrate parameter service usage\"\"\"\n        # This would typically be used to interact with other nodes' parameters\n        self.get_logger().info('Parameter services demo - ready to interact with other nodes')\n"})}),"\n",(0,n.jsx)(a.h2,{id:"best-practices-for-parameter-management",children:"Best Practices for Parameter Management"}),"\n",(0,n.jsx)(a.h3,{id:"parameter-naming-conventions",children:"Parameter Naming Conventions"}),"\n",(0,n.jsx)(a.p,{children:"Following consistent naming conventions improves maintainability and reduces errors:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:"class ParameterNamingBestPractices(Node):\n    def __init__(self):\n        super().__init__('parameter_naming_demo')\n\n        # Use snake_case for parameter names\n        self.declare_parameter('robot_speed_limit', 1.0)\n        self.declare_parameter('sensor_range_minimum', 0.1)\n        self.declare_parameter('control_loop_frequency', 50)\n\n        # Use descriptive names that indicate units where applicable\n        self.declare_parameter('timeout_seconds', 5.0)\n        self.declare_parameter('distance_threshold_meters', 0.5)\n        self.declare_parameter('angle_tolerance_radians', 0.1)\n\n        # Group related parameters with prefixes\n        self.declare_parameter('navigation.linear_velocity_max', 0.8)\n        self.declare_parameter('navigation.angular_velocity_max', 1.0)\n        self.declare_parameter('navigation.rotation_threshold', 0.1)\n\n        # Use positive names rather than negative ones\n        self.declare_parameter('enable_safety_checks', True)  # NOT disable_safety_checks\n        self.declare_parameter('use_sensor_fusion', True)     # NOT skip_sensor_fusion\n"})}),"\n",(0,n.jsx)(a.h3,{id:"parameter-validation-and-error-handling",children:"Parameter Validation and Error Handling"}),"\n",(0,n.jsx)(a.p,{children:"Implementing robust validation prevents runtime errors:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:"class RobustParameterNode(Node):\n    def __init__(self):\n        super().__init__('robust_parameter_node')\n\n        # Declare parameters with comprehensive validation\n        self.declare_parameter('validated_param', 1.0)\n\n        # Set up parameter callback with comprehensive validation\n        self.add_on_set_parameters_callback(self._validated_callback)\n\n    def _validated_callback(self, params):\n        \"\"\"Comprehensive parameter validation with detailed error reporting\"\"\"\n        result = SetParametersResult()\n        result.successful = True\n\n        for param in params:\n            if param.name == 'validated_param':\n                # Type checking\n                if param.type_ != Parameter.Type.DOUBLE:\n                    result.successful = False\n                    result.reason = f'Parameter {param.name} must be of type double, got {param.type_}'\n                    break\n\n                # Range validation\n                if param.value <= 0 or param.value > 10.0:\n                    result.successful = False\n                    result.reason = f'Parameter {param.name} must be between 0 and 10, got {param.value}'\n                    break\n\n                # Special value validation (e.g., avoid problematic values)\n                if param.value == 3.14159:  # Example: avoid specific problematic values\n                    result.successful = False\n                    result.reason = f'Parameter {param.name} cannot be set to {param.value} (special value)'\n                    break\n\n                # Log successful validation\n                self.get_logger().info(f'Parameter {param.name} validated successfully: {param.value}')\n\n        return result\n\n    def safe_parameter_access(self, param_name, default_value=None):\n        \"\"\"Safely access parameters with fallback to default\"\"\"\n        try:\n            if self.has_parameter(param_name):\n                return self.get_parameter(param_name).value\n            else:\n                self.get_logger().warn(f'Parameter {param_name} not found, using default: {default_value}')\n                return default_value\n        except Exception as e:\n            self.get_logger().error(f'Error accessing parameter {param_name}: {e}')\n            return default_value\n"})}),"\n",(0,n.jsx)(a.h2,{id:"launch-file-integration",children:"Launch File Integration"}),"\n",(0,n.jsx)(a.p,{children:"Parameters can also be configured through launch files, which integrates with the dynamic parameter system:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:"# launch/parameter_demo_launch.py\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\n\ndef generate_launch_description():\n    # Declare launch arguments that can become parameters\n    robot_namespace = DeclareLaunchArgument(\n        'robot_namespace',\n        default_value='robot1',\n        description='Namespace for the robot'\n    )\n\n    linear_speed = DeclareLaunchArgument(\n        'linear_speed',\n        default_value='0.5',\n        description='Linear speed for the robot'\n    )\n\n    return LaunchDescription([\n        robot_namespace,\n        linear_speed,\n\n        Node(\n            package='ros2_advanced_examples',\n            executable='parameter_demo_node',\n            name='parameter_demo',\n            namespace=LaunchConfiguration('robot_namespace'),\n            parameters=[\n                {\n                    'linear_velocity_limit': LaunchConfiguration('linear_speed'),\n                    'angular_velocity_limit': 1.0,\n                    'safety_distance': 0.5,\n                    'robot_namespace': LaunchConfiguration('robot_namespace')\n                }\n            ],\n            # Additional configurations...\n        )\n    ])\n"})}),"\n",(0,n.jsx)(a.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,n.jsx)(a.p,{children:"When using dynamic parameters, consider the performance implications:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-python",children:"class EfficientParameterNode(Node):\n    def __init__(self):\n        super().__init__('efficient_parameter_node')\n\n        # Declare parameters that affect performance\n        self.declare_parameter('param_update_frequency', 10)  # Hz\n        self.declare_parameter('use_parameter_caching', True)\n\n        # Cache frequently accessed parameters\n        self._param_cache = {}\n        self._last_param_update = self.get_clock().now()\n\n        # Timer for parameter-dependent operations\n        self.param_update_timer = self.create_timer(\n            1.0 / self.get_parameter('param_update_frequency').value,\n            self._optimized_param_check\n        )\n\n    def _optimized_param_check(self):\n        \"\"\"Optimized parameter checking with caching\"\"\"\n        current_time = self.get_clock().now()\n        cache_duration = 0.1  # Cache for 100ms\n\n        # Only update cache periodically if caching is enabled\n        if (self.get_parameter('use_parameter_caching').value and\n            (current_time - self._last_param_update).nanoseconds * 1e-9 > cache_duration):\n\n            # Update cache with current parameter values\n            self._param_cache['param_freq'] = self.get_parameter('param_update_frequency').value\n            self._param_cache['use_caching'] = self.get_parameter('use_parameter_caching').value\n\n            self._last_param_update = current_time\n\n        # Use cached values for performance-critical operations\n        freq = self._param_cache.get('param_freq', 10)\n        caching = self._param_cache.get('use_caching', True)\n\n        # Perform parameter-dependent operations\n        self.get_logger().debug(f'Using cached params - freq: {freq}, caching: {caching}')\n"})}),"\n",(0,n.jsx)(a.p,{children:"Dynamic parameters in ROS 2 provide a powerful mechanism for runtime configuration of robotic systems. By properly implementing parameter validation, callbacks, and hierarchical organization, you can create flexible and maintainable robotic applications that can adapt to changing conditions without requiring system restarts."})]})}function p(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,a,r)=>{r.d(a,{R:()=>l,x:()=>i});var n=r(6540);const t={},s=n.createContext(t);function l(e){const a=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),n.createElement(s.Provider,{value:a},e.children)}}}]);