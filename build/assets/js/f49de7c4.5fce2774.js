"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[6939],{7957:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>f,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var t=s(4848),a=s(8453);const i={title:"Chapter 4 - Nodes, Topics, Services & Actions in ROS 2"},r="Chapter 4: Nodes, Topics, Services & Actions in ROS 2",o={id:"ros2-communication/index",title:"Chapter 4 - Nodes, Topics, Services & Actions in ROS 2",description:"Chapter Overview",source:"@site/docs/physical-ai/ros2-communication/index.mdx",sourceDirName:"ros2-communication",slug:"/ros2-communication/",permalink:"/ros2-communication/",draft:!1,unlisted:!1,editUrl:"https://github.com/MuhammadFuzail591/new-book-physical-ai/tree/main/docs/physical-ai/ros2-communication/index.mdx",tags:[],version:"current",frontMatter:{title:"Chapter 4 - Nodes, Topics, Services & Actions in ROS 2"}},l={},c=[{value:"Chapter Overview",id:"chapter-overview",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Deep Dive into Nodes",id:"deep-dive-into-nodes",level:2},{value:"Node Architecture and Lifecycle Management",id:"node-architecture-and-lifecycle-management",level:3},{value:"Node Composition and Management",id:"node-composition-and-management",level:3},{value:"Advanced Topic Patterns",id:"advanced-topic-patterns",level:2},{value:"Topic Monitoring and Statistics",id:"topic-monitoring-and-statistics",level:3},{value:"Topic Filtering and Transformation",id:"topic-filtering-and-transformation",level:3},{value:"Service Implementation Patterns",id:"service-implementation-patterns",level:2},{value:"Asynchronous Service Handling",id:"asynchronous-service-handling",level:3},{value:"Service with Timeout and Error Handling",id:"service-with-timeout-and-error-handling",level:3},{value:"Action Implementation Patterns",id:"action-implementation-patterns",level:2},{value:"Complex Action Server with Feedback",id:"complex-action-server-with-feedback",level:3},{value:"Action Client with Advanced Features",id:"action-client-with-advanced-features",level:3},{value:"Communication Pattern Selection Guide",id:"communication-pattern-selection-guide",level:2},{value:"When to Use Each Pattern",id:"when-to-use-each-pattern",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Multi-Pattern Robot Controller",id:"multi-pattern-robot-controller",level:3},{value:"Best Practices and Performance Considerations",id:"best-practices-and-performance-considerations",level:2},{value:"Memory Management and Optimization",id:"memory-management-and-optimization",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"chapter-4-nodes-topics-services--actions-in-ros-2",children:"Chapter 4: Nodes, Topics, Services & Actions in ROS 2"}),"\n",(0,t.jsx)(n.h2,{id:"chapter-overview",children:"Chapter Overview"}),"\n",(0,t.jsx)(n.p,{children:"This chapter provides an in-depth exploration of the fundamental communication patterns in ROS 2: nodes, topics, services, and actions. These communication primitives form the backbone of all robotic applications, enabling components to interact and coordinate effectively. We'll examine each pattern in detail, understand when to use each one, and implement practical examples that demonstrate their usage in real-world robotic applications."}),"\n",(0,t.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Implement and manage ROS 2 nodes with proper lifecycle management"}),"\n",(0,t.jsx)(n.li,{children:"Design and implement topic-based publish/subscribe communication patterns"}),"\n",(0,t.jsx)(n.li,{children:"Create and use service-based request/response communication"}),"\n",(0,t.jsx)(n.li,{children:"Implement action-based goal-oriented communication for long-running tasks"}),"\n",(0,t.jsx)(n.li,{children:"Choose appropriate communication patterns for different robotic applications"}),"\n",(0,t.jsx)(n.li,{children:"Apply advanced QoS settings for different communication needs"}),"\n",(0,t.jsx)(n.li,{children:"Debug and monitor ROS 2 communication patterns effectively"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"deep-dive-into-nodes",children:"Deep Dive into Nodes"}),"\n",(0,t.jsx)(n.h3,{id:"node-architecture-and-lifecycle-management",children:"Node Architecture and Lifecycle Management"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 nodes provide the basic execution environment for robotic applications. Understanding proper node architecture is crucial for building robust robotic systems:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom rclpy.lifecycle import LifecycleNode, TransitionCallbackReturn\nfrom rclpy.executors import MultiThreadedExecutor\nimport threading\nfrom std_msgs.msg import String\nfrom sensor_msgs.msg import JointState\nimport time\n\nclass AdvancedLifecycleNode(LifecycleNode):\n    def __init__(self, node_name):\n        super().__init__(node_name)\n        self.declare_parameter(\'robot_name\', \'default_robot\')\n        self.declare_parameter(\'max_velocity\', 1.0)\n        self.declare_parameter(\'safety_enabled\', True)\n\n        # Initialize resources that will be managed by lifecycle\n        self._resources_initialized = False\n        self._communication_enabled = False\n        self._timer = None\n\n    def on_configure(self, state):\n        """Called when transitioning to INACTIVE state."""\n        self.get_logger().info(f\'Configuring {self.get_name()} node...\')\n\n        # Initialize resources\n        self._initialize_resources()\n\n        # Create publishers and subscribers (but don\'t enable them yet)\n        self._create_communication_interfaces()\n\n        self._resources_initialized = True\n        self.get_logger().info(f\'{self.get_name()} node configured successfully\')\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_activate(self, state):\n        """Called when transitioning to ACTIVE state."""\n        self.get_logger().info(f\'Activating {self.get_name()} node...\')\n\n        # Enable communication interfaces\n        if self._resources_initialized:\n            self._enable_communication()\n            self._communication_enabled = True\n            self.get_logger().info(f\'{self.get_name()} node activated successfully\')\n        else:\n            self.get_logger().error(\'Cannot activate: node not configured\')\n            return TransitionCallbackReturn.FAILURE\n\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_deactivate(self, state):\n        """Called when transitioning from ACTIVE state."""\n        self.get_logger().info(f\'Deactivating {self.get_name()} node...\')\n\n        # Disable communication interfaces\n        self._disable_communication()\n        self._communication_enabled = False\n\n        self.get_logger().info(f\'{self.get_name()} node deactivated successfully\')\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_cleanup(self, state):\n        """Called when transitioning from INACTIVE to UNCONFIGURED."""\n        self.get_logger().info(f\'Cleaning up {self.get_name()} node...\')\n\n        # Clean up resources\n        self._cleanup_resources()\n        self._resources_initialized = False\n\n        self.get_logger().info(f\'{self.get_name()} node cleaned up successfully\')\n        return TransitionCallbackReturn.SUCCESS\n\n    def _initialize_resources(self):\n        """Initialize node resources."""\n        # Example: Initialize hardware interfaces, allocate memory, etc.\n        self.get_logger().info(\'Initializing node resources...\')\n\n    def _create_communication_interfaces(self):\n        """Create publishers and subscribers (but don\'t enable them)."""\n        # Publishers\n        self.status_pub = self.create_publisher(String, \'robot_status\', 10)\n\n        # Subscribers\n        self.command_sub = self.create_subscription(\n            String, \'robot_commands\', self.command_callback, 10\n        )\n\n    def _enable_communication(self):\n        """Enable communication interfaces."""\n        self.get_logger().info(\'Enabling communication interfaces...\')\n\n    def _disable_communication(self):\n        """Disable communication interfaces."""\n        self.get_logger().info(\'Disabling communication interfaces...\')\n\n    def _cleanup_resources(self):\n        """Clean up node resources."""\n        self.get_logger().info(\'Cleaning up resources...\')\n\n    def command_callback(self, msg):\n        """Handle incoming commands."""\n        if self._communication_enabled:\n            self.get_logger().info(f\'Received command: {msg.data}\')\n        else:\n            self.get_logger().warn(\'Received command but node is not active\')\n'})}),"\n",(0,t.jsx)(n.h3,{id:"node-composition-and-management",children:"Node Composition and Management"}),"\n",(0,t.jsx)(n.p,{children:"Advanced ROS 2 applications often require managing multiple nodes within a single process:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from rclpy.node import Node\nfrom rclpy.executors import MultiThreadedExecutor\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup, ReentrantCallbackGroup\n\nclass NodeManager:\n    def __init__(self):\n        self.nodes = []\n        self.executor = MultiThreadedExecutor()\n\n    def add_node(self, node):\n        """Add a node to the manager and executor."""\n        self.nodes.append(node)\n        self.executor.add_node(node)\n\n    def spin_all(self):\n        """Spin all managed nodes."""\n        try:\n            self.executor.spin()\n        except KeyboardInterrupt:\n            self.shutdown()\n\n    def shutdown(self):\n        """Shutdown all managed nodes."""\n        for node in self.nodes:\n            node.destroy_node()\n        self.executor.shutdown()\n\nclass SensorNode(Node):\n    def __init__(self):\n        super().__init__(\'sensor_node\')\n        self.publisher = self.create_publisher(String, \'sensor_data\', 10)\n        self.timer = self.create_timer(0.1, self.publish_sensor_data)\n\n    def publish_sensor_data(self):\n        msg = String()\n        msg.data = f\'Sensor reading: {self.get_clock().now()}\'\n        self.publisher.publish(msg)\n\nclass ControllerNode(Node):\n    def __init__(self):\n        super().__init__(\'controller_node\')\n\n        # Use reentrant callback group for multiple subscriptions\n        self.callback_group = ReentrantCallbackGroup()\n\n        self.sensor_sub = self.create_subscription(\n            String, \'sensor_data\', self.sensor_callback, 10,\n            callback_group=self.callback_group\n        )\n\n        self.command_pub = self.create_publisher(String, \'motor_commands\', 10)\n\n    def sensor_callback(self, msg):\n        # Process sensor data and generate commands\n        command = f\'Control action based on: {msg.data}\'\n        cmd_msg = String()\n        cmd_msg.data = command\n        self.command_pub.publish(cmd_msg)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-topic-patterns",children:"Advanced Topic Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"topic-monitoring-and-statistics",children:"Topic Monitoring and Statistics"}),"\n",(0,t.jsx)(n.p,{children:"Understanding topic performance and behavior is crucial for robust robotic systems:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, qos_profile_sensor_data\nimport time\nfrom collections import deque\nimport statistics\n\nclass TopicMonitorNode(Node):\n    def __init__(self):\n        super().__init__('topic_monitor')\n\n        # Subscribe to topic with monitoring\n        self.subscriber = self.create_subscription(\n            String, 'monitored_topic', self.monitored_callback,\n            qos_profile=qos_profile_sensor_data\n        )\n\n        # Statistics tracking\n        self.message_count = 0\n        self.message_times = deque(maxlen=100)  # Keep last 100 timestamps\n        self.message_sizes = deque(maxlen=100)  # Keep last 100 sizes\n        self.start_time = self.get_clock().now()\n\n        # Diagnostic publisher\n        self.diag_pub = self.create_publisher(String, 'diagnostics', 10)\n\n        # Statistics timer\n        self.stats_timer = self.create_timer(5.0, self.publish_statistics)\n\n    def monitored_callback(self, msg):\n        current_time = self.get_clock().now()\n        self.message_count += 1\n        self.message_times.append(current_time.nanoseconds)\n        self.message_sizes.append(len(msg.data.encode('utf-8')))\n\n        # Process the message\n        self.process_message(msg)\n\n    def process_message(self, msg):\n        # Implement message processing logic\n        self.get_logger().info(f'Processed: {msg.data}')\n\n    def publish_statistics(self):\n        if len(self.message_times) < 2:\n            return\n\n        # Calculate statistics\n        elapsed_time = (self.get_clock().now() - self.start_time).nanoseconds / 1e9\n        message_rate = self.message_count / elapsed_time if elapsed_time > 0 else 0\n\n        # Calculate inter-message intervals\n        intervals = [\n            (self.message_times[i] - self.message_times[i-1]) / 1e9\n            for i in range(1, len(self.message_times))\n        ]\n\n        avg_interval = statistics.mean(intervals) if intervals else 0\n        std_interval = statistics.stdev(intervals) if len(intervals) > 1 else 0\n\n        # Calculate message size statistics\n        avg_size = statistics.mean(self.message_sizes) if self.message_sizes else 0\n\n        # Create diagnostic message\n        diag_msg = String()\n        diag_msg.data = (\n            f\"Topic Statistics:\\n\"\n            f\"  Message Count: {self.message_count}\\n\"\n            f\"  Message Rate: {message_rate:.2f} Hz\\n\"\n            f\"  Avg Interval: {avg_interval:.4f}s\\n\"\n            f\"  Interval Std Dev: {std_interval:.4f}s\\n\"\n            f\"  Avg Size: {avg_size:.2f} bytes\\n\"\n        )\n\n        self.diag_pub.publish(diag_msg)\n        self.get_logger().info(f'Statistics: {diag_msg.data}')\n"})}),"\n",(0,t.jsx)(n.h3,{id:"topic-filtering-and-transformation",children:"Topic Filtering and Transformation"}),"\n",(0,t.jsx)(n.p,{children:"Advanced topic handling often requires filtering and transforming data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from sensor_msgs.msg import LaserScan\nimport numpy as np\n\nclass TopicFilterNode(Node):\n    def __init__(self):\n        super().__init__('topic_filter')\n\n        # Subscribe to raw sensor data\n        self.raw_sub = self.create_subscription(\n            LaserScan, 'raw_laser_scan', self.raw_scan_callback, 10\n        )\n\n        # Publish filtered data\n        self.filtered_pub = self.create_publisher(LaserScan, 'filtered_laser_scan', 10)\n\n        # Parameters for filtering\n        self.declare_parameter('min_range', 0.1)\n        self.declare_parameter('max_range', 10.0)\n        self.declare_parameter('range_threshold', 5.0)\n\n    def raw_scan_callback(self, msg):\n        # Filter the laser scan data\n        filtered_msg = self.filter_laser_scan(msg)\n        self.filtered_pub.publish(filtered_msg)\n\n    def filter_laser_scan(self, scan_msg):\n        \"\"\"Filter laser scan data based on various criteria.\"\"\"\n        filtered_msg = LaserScan()\n\n        # Copy header and metadata\n        filtered_msg.header = scan_msg.header\n        filtered_msg.angle_min = scan_msg.angle_min\n        filtered_msg.angle_max = scan_msg.angle_max\n        filtered_msg.angle_increment = scan_msg.angle_increment\n        filtered_msg.time_increment = scan_msg.time_increment\n        filtered_msg.scan_time = scan_msg.scan_time\n        filtered_msg.range_min = scan_msg.range_min\n        filtered_msg.range_max = scan_msg.range_max\n\n        # Apply range filtering\n        min_range = self.get_parameter('min_range').value\n        max_range = self.get_parameter('max_range').value\n        range_threshold = self.get_parameter('range_threshold').value\n\n        # Filter ranges based on thresholds\n        filtered_ranges = []\n        for range_val in scan_msg.ranges:\n            if np.isnan(range_val) or range_val < min_range or range_val > max_range:\n                # Use infinity for invalid readings\n                filtered_ranges.append(float('inf'))\n            elif range_val > range_threshold:\n                # Use threshold value for very distant readings\n                filtered_ranges.append(range_threshold)\n            else:\n                filtered_ranges.append(range_val)\n\n        filtered_msg.ranges = filtered_ranges\n        return filtered_msg\n"})}),"\n",(0,t.jsx)(n.h2,{id:"service-implementation-patterns",children:"Service Implementation Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"asynchronous-service-handling",children:"Asynchronous Service Handling"}),"\n",(0,t.jsx)(n.p,{children:"For high-performance applications, asynchronous service handling is essential:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile\nfrom example_interfaces.srv import AddTwoInts\nimport asyncio\nfrom rclpy.task import Future\n\nclass AsyncServiceNode(Node):\n    def __init__(self):\n        super().__init__('async_service_node')\n\n        # Create service server\n        self.service = self.create_service(\n            AddTwoInts,\n            'async_add_two_ints',\n            self.async_add_two_ints_callback\n        )\n\n        # Create service client for testing\n        self.client = self.create_client(AddTwoInts, 'async_add_two_ints')\n\n    def async_add_two_ints_callback(self, request, response):\n        \"\"\"Handle service request asynchronously.\"\"\"\n        # For CPU-intensive operations, use threading\n        import threading\n        thread = threading.Thread(\n            target=self.process_request,\n            args=(request, response)\n        )\n        thread.start()\n        # Note: For ROS 2 services, the callback must return the response\n        # This is a simplified example; real async services may need more complex patterns\n        return self.synchronous_process(request, response)\n\n    def synchronous_process(self, request, response):\n        \"\"\"Synchronous processing for demonstration.\"\"\"\n        # Simulate some processing time\n        time.sleep(0.1)\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Calculated {request.a} + {request.b} = {response.sum}')\n        return response\n\nclass ServiceChainNode(Node):\n    def __init__(self):\n        super().__init__('service_chain_node')\n\n        # Create service that chains to other services\n        self.main_service = self.create_service(\n            AddTwoInts, 'main_calculation', self.main_calculation_callback\n        )\n\n        # Create clients for dependent services\n        self.add_client = self.create_client(AddTwoInts, 'async_add_two_ints')\n        self.multiply_client = self.create_client(AddTwoInts, 'multiply_two_ints')\n\n        # Wait for services to be available\n        while not self.add_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Add service not available, waiting...')\n\n    def main_calculation_callback(self, request, response):\n        \"\"\"Complex calculation that chains multiple services.\"\"\"\n        # First, add the numbers\n        add_future = self.add_client.call_async(\n            AddTwoInts.Request(a=request.a, b=request.b)\n        )\n\n        # Wait for the result (in a real implementation, this would be handled asynchronously)\n        rclpy.spin_until_future_complete(self, add_future)\n        add_result = add_future.result()\n\n        # Then multiply by a factor (simplified example)\n        response.sum = add_result.sum * 2  # Simplified multiplication\n        return response\n"})}),"\n",(0,t.jsx)(n.h3,{id:"service-with-timeout-and-error-handling",children:"Service with Timeout and Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"Robust service implementations must handle timeouts and errors gracefully:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile\nfrom example_interfaces.srv import AddTwoInts\nimport time\n\nclass RobustServiceNode(Node):\n    def __init__(self):\n        super().__init__('robust_service_node')\n\n        # Create service with error handling\n        self.service = self.create_service(\n            AddTwoInts,\n            'robust_add_two_ints',\n            self.robust_add_callback,\n            qos_profile=QoSProfile(depth=10)\n        )\n\n        # Statistics for monitoring\n        self.request_count = 0\n        self.error_count = 0\n        self.total_processing_time = 0.0\n\n    def robust_add_callback(self, request, response):\n        \"\"\"Service callback with comprehensive error handling.\"\"\"\n        start_time = time.time()\n        self.request_count += 1\n\n        try:\n            # Validate inputs\n            if not self.validate_inputs(request):\n                self.get_logger().error('Invalid inputs received')\n                response.sum = 0\n                self.error_count += 1\n                return response\n\n            # Perform calculation with error handling\n            result = self.safe_calculation(request.a, request.b)\n            response.sum = result\n\n            # Log successful processing\n            processing_time = time.time() - start_time\n            self.total_processing_time += processing_time\n            self.get_logger().info(\n                f'Successfully processed request: {request.a} + {request.b} = {result} '\n                f'(time: {processing_time:.4f}s)'\n            )\n\n        except Exception as e:\n            self.get_logger().error(f'Error processing request: {e}')\n            response.sum = 0\n            self.error_count += 1\n\n        return response\n\n    def validate_inputs(self, request):\n        \"\"\"Validate service request inputs.\"\"\"\n        # Check for valid numeric types\n        if not isinstance(request.a, (int, float)) or not isinstance(request.b, (int, float)):\n            return False\n\n        # Check for reasonable range (optional)\n        if abs(request.a) > 1e10 or abs(request.b) > 1e10:\n            self.get_logger().warn('Very large numbers detected')\n\n        return True\n\n    def safe_calculation(self, a, b):\n        \"\"\"Perform calculation with overflow protection.\"\"\"\n        try:\n            result = a + b\n            # Check for overflow/underflow\n            if not np.isfinite(result):\n                raise ValueError('Calculation resulted in non-finite value')\n            return result\n        except OverflowError:\n            self.get_logger().error('Calculation overflow')\n            raise\n        except Exception as e:\n            self.get_logger().error(f'Calculation error: {e}')\n            raise\n\n    def get_statistics(self):\n        \"\"\"Get service usage statistics.\"\"\"\n        avg_time = self.total_processing_time / self.request_count if self.request_count > 0 else 0\n        error_rate = self.error_count / self.request_count if self.request_count > 0 else 0\n\n        stats = {\n            'request_count': self.request_count,\n            'error_count': self.error_count,\n            'error_rate': error_rate,\n            'average_processing_time': avg_time\n        }\n        return stats\n"})}),"\n",(0,t.jsx)(n.h2,{id:"action-implementation-patterns",children:"Action Implementation Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"complex-action-server-with-feedback",children:"Complex Action Server with Feedback"}),"\n",(0,t.jsx)(n.p,{children:"Actions are essential for long-running tasks that require feedback and cancellation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom example_interfaces.action import Fibonacci\nimport threading\nimport time\n\nclass AdvancedFibonacciActionServer(Node):\n    def __init__(self):\n        super().__init__('advanced_fibonacci_action_server')\n\n        # Use reentrant callback group to allow concurrent callbacks\n        callback_group = ReentrantCallbackGroup()\n\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'advanced_fibonacci',\n            self.execute_callback,\n            goal_callback=self.goal_callback,\n            handle_accepted_callback=self.handle_accepted_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=callback_group\n        )\n\n        # Statistics tracking\n        self.active_goals = 0\n        self.completed_goals = 0\n        self.cancelled_goals = 0\n\n    def goal_callback(self, goal_request):\n        \"\"\"Accept or reject goal requests.\"\"\"\n        self.get_logger().info(f'Received goal request with order: {goal_request.order}')\n\n        # Validate the goal request\n        if goal_request.order < 0:\n            self.get_logger().warn('Negative order requested, rejecting goal')\n            return GoalResponse.REJECT\n        elif goal_request.order > 100:  # Reasonable limit\n            self.get_logger().warn('Large order requested, rejecting goal')\n            return GoalResponse.REJECT\n        else:\n            self.get_logger().info('Accepting goal request')\n            return GoalResponse.ACCEPT\n\n    def handle_accepted_callback(self, goal_handle):\n        \"\"\"Handle accepted goal by starting execution in a separate thread.\"\"\"\n        self.active_goals += 1\n        self.get_logger().info(f'Goal accepted, active goals: {self.active_goals}')\n\n        # Start execution in a separate thread to avoid blocking\n        thread = threading.Thread(target=self.execute_goal, args=(goal_handle,))\n        thread.start()\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Accept or reject cancel requests.\"\"\"\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    def execute_goal(self, goal_handle):\n        \"\"\"Execute the goal in a separate thread.\"\"\"\n        self.get_logger().info('Executing goal...')\n\n        # Create feedback and result messages\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        result_msg = Fibonacci.Result()\n\n        try:\n            # Generate Fibonacci sequence\n            for i in range(1, goal_handle.request.order):\n                # Check if goal has been cancelled\n                if goal_handle.is_cancel_requested:\n                    self.get_logger().info('Goal cancelled')\n                    goal_handle.canceled()\n                    result_msg.sequence = feedback_msg.sequence\n                    self.cancelled_goals += 1\n                    self.active_goals -= 1\n                    return\n\n                # Simulate processing time\n                time.sleep(0.1)\n\n                # Calculate next Fibonacci number\n                next_fib = feedback_msg.sequence[i] + feedback_msg.sequence[i-1]\n                feedback_msg.sequence.append(next_fib)\n\n                # Publish feedback\n                goal_handle.publish_feedback(feedback_msg)\n\n                self.get_logger().info(f'Published feedback: {feedback_msg.sequence}')\n\n            # Complete the goal successfully\n            goal_handle.succeed()\n            result_msg.sequence = feedback_msg.sequence\n            self.get_logger().info(f'Goal succeeded with result: {result_msg.sequence}')\n            self.completed_goals += 1\n\n        except Exception as e:\n            self.get_logger().error(f'Error during goal execution: {e}')\n            goal_handle.abort()\n            result_msg.sequence = feedback_msg.sequence\n            self.active_goals -= 1\n            return\n\n        finally:\n            self.active_goals -= 1\n            # Publish final result\n            goal_handle.publish_result(result_msg)\n\n    def get_statistics(self):\n        \"\"\"Get action server statistics.\"\"\"\n        stats = {\n            'active_goals': self.active_goals,\n            'completed_goals': self.completed_goals,\n            'cancelled_goals': self.cancelled_goals\n        }\n        return stats\n"})}),"\n",(0,t.jsx)(n.h3,{id:"action-client-with-advanced-features",children:"Action Client with Advanced Features"}),"\n",(0,t.jsx)(n.p,{children:"Action clients need to handle various scenarios including timeouts, cancellations, and feedback processing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from rclpy.action import ActionClient\nfrom rclpy.qos import QoSProfile\nfrom example_interfaces.action import Fibonacci\nimport time\n\nclass AdvancedFibonacciActionClient(Node):\n    def __init__(self):\n        super().__init__(\'advanced_fibonacci_action_client\')\n\n        # Create action client\n        self._action_client = ActionClient(\n            self, Fibonacci, \'advanced_fibonacci\'\n        )\n\n        # Wait for action server\n        self.get_logger().info(\'Waiting for action server...\')\n        self._action_client.wait_for_server()\n        self.get_logger().info(\'Action server available\')\n\n        # Statistics\n        self.request_count = 0\n        self.success_count = 0\n        self.cancel_count = 0\n\n    def send_goal_async(self, order, timeout_sec=30.0):\n        """Send goal asynchronously with timeout handling."""\n        self.request_count += 1\n\n        # Create goal request\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        # Send goal asynchronously\n        self.get_logger().info(f\'Sending goal with order: {order}\')\n        future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n\n        # Add done callback to handle result\n        future.add_done_callback(\n            lambda future: self.goal_response_callback(future, timeout_sec)\n        )\n\n        return future\n\n    def goal_response_callback(self, future, timeout_sec):\n        """Handle goal response."""\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\'Goal rejected by server\')\n            return\n\n        self.get_logger().info(\'Goal accepted by server, waiting for result...\')\n\n        # Get result future\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(\n            lambda result_future: self.result_callback(result_future, goal_handle)\n        )\n\n        # Set up timeout handling\n        timeout_timer = self.create_timer(\n            timeout_sec,\n            lambda: self.check_timeout(goal_handle)\n        )\n\n    def feedback_callback(self, feedback_msg):\n        """Handle feedback from action server."""\n        self.get_logger().info(\n            f\'Received feedback: {feedback_msg.feedback.sequence[-3:]}...\'\n        )\n\n    def result_callback(self, result_future, goal_handle):\n        """Handle action result."""\n        result = result_future.result().result\n        self.get_logger().info(f\'Result: {result.sequence}\')\n        self.success_count += 1\n\n    def check_timeout(self, goal_handle):\n        """Check if goal has timed out."""\n        # In a real implementation, you would cancel the goal here\n        self.get_logger().warn(\'Goal may have timed out\')\n\n    def send_goal_with_cancellation(self, order):\n        """Send goal and demonstrate cancellation."""\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        self.get_logger().info(f\'Sending cancellable goal: {order}\')\n\n        future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n\n        # Add response callback\n        future.add_done_callback(\n            lambda f: self.handle_cancellable_goal(f, order)\n        )\n\n    def handle_cancellable_goal(self, future, order):\n        """Handle cancellable goal with potential cancellation."""\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            return\n\n        self.get_logger().info(\'Goal accepted, will cancel after 2 seconds\')\n\n        # Schedule cancellation after 2 seconds\n        timer = self.create_timer(2.0, lambda: self.cancel_goal(goal_handle))\n\n    def cancel_goal(self, goal_handle):\n        """Cancel a goal."""\n        self.get_logger().info(\'Cancelling goal...\')\n        cancel_future = goal_handle.cancel_goal_async()\n        cancel_future.add_done_callback(self.cancel_response_callback)\n\n    def cancel_response_callback(self, future):\n        """Handle cancel response."""\n        cancel_response = future.result()\n        if len(cancel_response.goals_canceling) > 0:\n            self.get_logger().info(\'Goal successfully cancelled\')\n            self.cancel_count += 1\n        else:\n            self.get_logger().info(\'Goal could not be cancelled\')\n'})}),"\n",(0,t.jsx)(n.h2,{id:"communication-pattern-selection-guide",children:"Communication Pattern Selection Guide"}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-each-pattern",children:"When to Use Each Pattern"}),"\n",(0,t.jsx)(n.p,{children:"Understanding when to use topics, services, or actions is crucial for proper ROS 2 design:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Decision matrix for communication patterns\n\n\"\"\"\nCommunication Pattern Selection Guide:\n\nTOPICS (Publish/Subscribe):\n- Use for: Continuous data streams, sensor data, status updates\n- Characteristics: Asynchronous, many-to-many, fire-and-forget\n- Examples:\n  - Sensor readings (camera, LIDAR, IMU)\n  - Robot state (position, velocity, battery)\n  - Status information (health, diagnostics)\n\nSERVICES (Request/Response):\n- Use for: One-time computations, immediate responses\n- Characteristics: Synchronous, one-to-one, blocking\n- Examples:\n  - Transform lookup (tf2)\n  - Map queries\n  - Configuration changes\n  - Simple calculations\n\nACTIONS (Goal-Based):\n- Use for: Long-running tasks with feedback\n- Characteristics: Asynchronous, with progress tracking and cancellation\n- Examples:\n  - Navigation to goal\n  - Object manipulation\n  - Data processing tasks\n  - Calibration procedures\n\"\"\"\n\nclass CommunicationPatternSelector:\n    @staticmethod\n    def select_pattern(data_type, duration, feedback_needed, criticality):\n        \"\"\"\n        Select the appropriate communication pattern based on requirements.\n\n        Args:\n            data_type: Type of data (sensor, command, status, etc.)\n            duration: Expected duration (instant, short, long)\n            feedback_needed: Whether feedback is required (bool)\n            criticality: How critical the communication is (low, medium, high)\n        \"\"\"\n        if duration == 'continuous':\n            return 'topic'\n        elif duration == 'instant' and not feedback_needed:\n            return 'service'\n        elif duration == 'long' and feedback_needed:\n            return 'action'\n        elif duration == 'short' and not feedback_needed:\n            return 'service'\n        else:\n            return 'topic'  # Default to topic for continuous monitoring\n\n    @staticmethod\n    def get_qos_recommendations(pattern, data_type, criticality):\n        \"\"\"Get recommended QoS settings for different patterns.\"\"\"\n        from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\n\n        if pattern == 'topic':\n            if data_type in ['critical_sensor', 'command', 'emergency']:\n                return QoSProfile(\n                    reliability=ReliabilityPolicy.RELIABLE,\n                    history=HistoryPolicy.KEEP_LAST,\n                    depth=10\n                )\n            elif data_type in ['high_frequency', 'diagnostic', 'status']:\n                return QoSProfile(\n                    reliability=ReliabilityPolicy.BEST_EFFORT,\n                    history=HistoryPolicy.KEEP_LAST,\n                    depth=1\n                )\n        elif pattern == 'service':\n            return QoSProfile(\n                reliability=ReliabilityPolicy.RELIABLE,\n                history=HistoryPolicy.KEEP_LAST,\n                depth=10\n            )\n        elif pattern == 'action':\n            return QoSProfile(\n                reliability=ReliabilityPolicy.RELIABLE,\n                history=HistoryPolicy.KEEP_ALL,\n                depth=1\n            )\n"})}),"\n",(0,t.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,t.jsx)(n.h3,{id:"multi-pattern-robot-controller",children:"Multi-Pattern Robot Controller"}),"\n",(0,t.jsx)(n.p,{children:"Here's a comprehensive example that demonstrates all three communication patterns working together:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, qos_profile_sensor_data\nfrom std_msgs.msg import String, Float64\nfrom example_interfaces.srv import SetBool\nfrom example_interfaces.action import Fibonacci\nfrom rclpy.action import ActionClient\nimport threading\n\nclass IntegratedRobotController(Node):\n    def __init__(self):\n        super().__init__('integrated_robot_controller')\n\n        # TOPIC: Publishers for robot state\n        self.position_pub = self.create_publisher(Float64, 'robot_position', 10)\n        self.status_pub = self.create_publisher(String, 'robot_status', 10)\n\n        # TOPIC: Subscribers for commands and sensor data\n        self.command_sub = self.create_subscription(\n            String, 'robot_commands', self.command_callback, 10\n        )\n        self.sensor_sub = self.create_subscription(\n            Float64, 'sensor_data', self.sensor_callback, qos_profile_sensor_data\n        )\n\n        # SERVICE: Server for immediate commands\n        self.emergency_service = self.create_service(\n            SetBool, 'emergency_stop', self.emergency_stop_callback\n        )\n\n        # SERVICE: Client for external services\n        self.navigation_client = self.create_client(\n            SetBool, 'navigation_service'\n        )\n\n        # ACTION: Client for long-running tasks\n        self.movement_action_client = ActionClient(\n            self, Fibonacci, 'movement_sequence'\n        )\n\n        # Robot state\n        self.current_position = 0.0\n        self.is_emergency_stopped = False\n        self.is_moving = False\n\n        # Timer for periodic updates\n        self.update_timer = self.create_timer(0.1, self.update_robot_state)\n\n    def command_callback(self, msg):\n        \"\"\"Handle incoming commands via topic.\"\"\"\n        command = msg.data\n        self.get_logger().info(f'Received command: {command}')\n\n        if command == 'move_forward' and not self.is_emergency_stopped:\n            self.move_robot(1.0)\n        elif command == 'move_backward' and not self.is_emergency_stopped:\n            self.move_robot(-1.0)\n        elif command == 'stop':\n            self.stop_robot()\n\n    def sensor_callback(self, msg):\n        \"\"\"Handle sensor data via topic.\"\"\"\n        sensor_value = msg.data\n        self.get_logger().info(f'Sensor reading: {sensor_value}')\n\n        # Check for obstacles\n        if sensor_value < 0.5 and not self.is_emergency_stopped:\n            self.get_logger().warn('Obstacle detected, stopping robot')\n            self.emergency_stop()\n\n    def emergency_stop_callback(self, request, response):\n        \"\"\"Handle emergency stop via service.\"\"\"\n        if request.data:\n            self.emergency_stop()\n            response.success = True\n            response.message = 'Emergency stop activated'\n        else:\n            self.emergency_stop_release()\n            response.success = True\n            response.message = 'Emergency stop released'\n\n        return response\n\n    def move_robot(self, distance):\n        \"\"\"Move robot by specified distance.\"\"\"\n        if self.is_emergency_stopped:\n            return\n\n        self.is_moving = True\n        self.current_position += distance\n        self.get_logger().info(f'Moving robot to position: {self.current_position}')\n\n    def stop_robot(self):\n        \"\"\"Stop robot movement.\"\"\"\n        self.is_moving = False\n        self.get_logger().info('Robot stopped')\n\n    def emergency_stop(self):\n        \"\"\"Emergency stop the robot.\"\"\"\n        self.is_emergency_stopped = True\n        self.is_moving = False\n        self.get_logger().warn('EMERGENCY STOP ACTIVATED')\n\n        # Publish emergency status\n        status_msg = String()\n        status_msg.data = 'EMERGENCY_STOP'\n        self.status_pub.publish(status_msg)\n\n    def emergency_stop_release(self):\n        \"\"\"Release emergency stop.\"\"\"\n        self.is_emergency_stopped = False\n        self.get_logger().info('Emergency stop released')\n\n    def update_robot_state(self):\n        \"\"\"Periodically update robot state.\"\"\"\n        # Publish current position\n        pos_msg = Float64()\n        pos_msg.data = self.current_position\n        self.position_pub.publish(pos_msg)\n\n        # Publish status\n        status_msg = String()\n        if self.is_emergency_stopped:\n            status_msg.data = 'EMERGENCY_STOP'\n        elif self.is_moving:\n            status_msg.data = 'MOVING'\n        else:\n            status_msg.data = 'IDLE'\n        self.status_pub.publish(status_msg)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices-and-performance-considerations",children:"Best Practices and Performance Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"memory-management-and-optimization",children:"Memory Management and Optimization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class OptimizedCommunicationNode(Node):\n    def __init__(self):\n        super().__init__('optimized_communication')\n\n        # Pre-allocate message objects to reduce allocation overhead\n        self._string_msg = String()\n        self._float_msg = Float64()\n\n        # Publishers with optimized QoS\n        self.optimized_pub = self.create_publisher(\n            String, 'optimized_topic',\n            qos_profile=qos_profile_sensor_data\n        )\n\n        # Timer for optimized publishing\n        self.timer = self.create_timer(0.01, self.optimized_publish)\n\n    def optimized_publish(self):\n        \"\"\"Optimized publishing using pre-allocated messages.\"\"\"\n        # Reuse message object instead of creating new ones\n        self._string_msg.data = f'Optimized message at {self.get_clock().now().nanoseconds}'\n        self.optimized_pub.publish(self._string_msg)\n\n        # Clear message data if needed for next use\n        # self._string_msg.data = ''  # Only if needed\n\nclass TopicBridgingNode(Node):\n    def __init__(self):\n        super().__init__('topic_bridge')\n\n        # Bridge between different message types\n        self.input_sub = self.create_subscription(\n            String, 'input_topic', self.input_callback, 10\n        )\n\n        self.output_pub = self.create_publisher(\n            Float64, 'output_topic', 10\n        )\n\n    def input_callback(self, msg):\n        \"\"\"Bridge input to output with transformation.\"\"\"\n        try:\n            # Convert string to number (with error handling)\n            value = float(msg.data)\n\n            # Create output message\n            output_msg = Float64()\n            output_msg.data = value * 2  # Example transformation\n\n            self.output_pub.publish(output_msg)\n\n        except ValueError:\n            self.get_logger().error(f'Cannot convert {msg.data} to float')\n"})}),"\n",(0,t.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,t.jsx)(n.p,{children:"This chapter has provided a comprehensive exploration of the fundamental communication patterns in ROS 2: nodes, topics, services, and actions. We've covered advanced implementation techniques, best practices, and practical examples that demonstrate how these patterns work together in real robotic applications."}),"\n",(0,t.jsx)(n.p,{children:"The key takeaways include:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Nodes"}),": Proper lifecycle management, resource handling, and composition patterns are essential for robust robotic applications."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Topics"}),": Asynchronous publish/subscribe communication is ideal for continuous data streams and status updates. Proper QoS selection ensures appropriate delivery guarantees."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Services"}),": Synchronous request/response communication is suitable for immediate computations and one-time operations that require a response."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": Goal-based communication with feedback and cancellation capabilities is essential for long-running tasks that need progress tracking."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pattern Selection"}),": Choosing the appropriate communication pattern based on application requirements is crucial for system performance and reliability."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These communication patterns form the foundation for all complex robotic systems, enabling the coordination of multiple components in sophisticated applications like humanoid robots where precise timing, reliability, and feedback are critical."}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implementation"}),": Create a ROS 2 node that demonstrates all three communication patterns (topic, service, action) by implementing a simple robot arm controller that can receive position commands via topic, perform calibration via service, and execute complex trajectories via action."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Analysis"}),": Design a communication architecture for a multi-robot system performing coordinated mapping. Identify which communication patterns would be most appropriate for robot-to-robot communication, sensor data sharing, and task coordination."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Optimization"}),": Implement a message filtering node that receives high-frequency sensor data and applies various filtering techniques (averaging, thresholding, outlier detection) before publishing the processed data."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["ROS 2 Documentation: Actions - ",(0,t.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/Creating-an-Action.html",children:"https://docs.ros.org/en/humble/Tutorials/Intermediate/Creating-an-Action.html"})]}),"\n",(0,t.jsxs)(n.li,{children:["ROS 2 Design: Communication Patterns - ",(0,t.jsx)(n.a,{href:"https://design.ros2.org/articles/topic_versus_service.html",children:"https://design.ros2.org/articles/topic_versus_service.html"})]}),"\n",(0,t.jsxs)(n.li,{children:["Real-time ROS 2: Performance Considerations - ",(0,t.jsx)(n.a,{href:"https://ros-realtime.github.io/",children:"https://ros-realtime.github.io/"})]}),"\n"]})]})}function f(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var t=s(6540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);