---
title: Launch Files in ROS 2
---

# Launch Files in ROS 2

## Introduction to Launch Systems

Launch files in ROS 2 provide a powerful mechanism to start multiple nodes with specific configurations simultaneously. Unlike ROS 1, ROS 2 uses a more flexible and programmable launch system that supports both XML and Python formats, with Python being the recommended approach due to its flexibility and programmability.

### Launch File Fundamentals

Launch files allow you to define complex robotic systems with multiple nodes, parameters, and configurations in a single file. This is essential for:

- Starting multiple nodes with specific parameters
- Managing namespaces for multi-robot systems
- Setting up complex system configurations
- Managing dependencies between nodes
- Handling system startup and shutdown

## Python Launch Files

Python launch files offer maximum flexibility and are the recommended approach for complex systems:

```python
# launch/robot_system.launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, TimerAction
from launch.conditions import IfCondition
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node, ComposableNodeContainer
from launch_ros.descriptions import ComposableNode
from launch_ros.substitutions import FindPackageShare
import os

def generate_launch_description():
    # Declare launch arguments
    declare_use_sim_time = DeclareLaunchArgument(
        'use_sim_time',
        default_value='false',
        description='Use simulation (Gazebo) clock if true'
    )

    declare_robot_name = DeclareLaunchArgument(
        'robot_name',
        default_value='default_robot',
        description='Name of the robot'
    )

    declare_config_dir = DeclareLaunchArgument(
        'config_dir',
        default_value=PathJoinSubstitution([
            FindPackageShare('my_robot_package'),
            'config'
        ]),
        description='Path to config directory'
    )

    # Get launch configuration
    use_sim_time = LaunchConfiguration('use_sim_time')
    robot_name = LaunchConfiguration('robot_name')
    config_dir = LaunchConfiguration('config_dir')

    # Robot controller node
    robot_controller_node = Node(
        package='my_robot_package',
        executable='robot_controller',
        name='robot_controller',
        parameters=[
            PathJoinSubstitution([config_dir, 'robot_config.yaml']),
            {'robot_name': robot_name},
            {'use_sim_time': use_sim_time}
        ],
        output='screen',
        respawn=True,
        respawn_delay=2.0
    )

    # Sensor processor node
    sensor_processor_node = Node(
        package='my_robot_package',
        executable='sensor_processor',
        name='sensor_processor',
        parameters=[
            PathJoinSubstitution([config_dir, 'sensor_config.yaml']),
            {'use_sim_time': use_sim_time}
        ],
        output='screen',
        respawn=True
    )

    # Navigation node
    navigation_node = Node(
        package='my_robot_package',
        executable='navigation_node',
        name='navigation',
        parameters=[
            PathJoinSubstitution([config_dir, 'navigation_config.yaml']),
            {'use_sim_time': use_sim_time}
        ],
        output='screen',
        respawn=True
    )

    # RViz2 visualization
    rviz_node = Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        arguments=['-d', PathJoinSubstitution([
            FindPackageShare('my_robot_package'),
            'rviz',
            'robot_view.rviz'
        ])],
        condition=IfCondition(LaunchConfiguration('enable_rviz', default='true')),
        output='screen'
    )

    # Return the launch description
    return LaunchDescription([
        declare_use_sim_time,
        declare_robot_name,
        declare_config_dir,

        # Launch nodes
        robot_controller_node,
        sensor_processor_node,
        navigation_node,
        rviz_node,
    ])
```

## Advanced Launch File Patterns

### Multi-Robot Systems

For complex multi-robot scenarios, launch files can manage namespaces and coordination:

```python
# launch/multi_robot_system.launch.py
from launch import LaunchDescription
from launch.actions import (
    DeclareLaunchArgument, GroupAction, SetEnvironmentVariable
)
from launch.conditions import IfCondition
from launch.substitutions import LaunchConfiguration, TextSubstitution
from launch_ros.actions import Node, PushRosNamespace
from launch_ros.descriptions import ParameterFile
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    # Launch arguments for multi-robot system
    declare_robot1_namespace = DeclareLaunchArgument(
        'robot1_namespace',
        default_value='robot1',
        description='Namespace for robot 1'
    )

    declare_robot2_namespace = DeclareLaunchArgument(
        'robot2_namespace',
        default_value='robot2',
        description='Namespace for robot 2'
    )

    declare_use_composition = DeclareLaunchArgument(
        'use_composition',
        default_value='false',
        description='Use composed nodes'
    )

    declare_composable_nodes = DeclareLaunchArgument(
        'composable_nodes',
        default_value='false',
        description='Use composable nodes'
    )

    # Get launch configurations
    robot1_namespace = LaunchConfiguration('robot1_namespace')
    robot2_namespace = LaunchConfiguration('robot2_namespace')
    use_composition = LaunchConfiguration('use_composition')
    composable_nodes = LaunchConfiguration('composable_nodes')

    # Robot 1 group
    robot1_group = GroupAction(
        actions=[
            PushRosNamespace(robot1_namespace),
            Node(
                package='my_robot_package',
                executable='robot_controller',
                name='controller',
                parameters=[
                    {'robot_name': 'robot1'},
                    {'max_linear_velocity': 0.8}
                ],
                output='screen'
            ),
            Node(
                package='my_robot_package',
                executable='sensor_processor',
                name='sensor_processor',
                output='screen'
            )
        ]
    )

    # Robot 2 group
    robot2_group = GroupAction(
        actions=[
            PushRosNamespace(robot2_namespace),
            Node(
                package='my_robot_package',
                executable='robot_controller',
                name='controller',
                parameters=[
                    {'robot_name': 'robot2'},
                    {'max_linear_velocity': 1.0}
                ],
                output='screen'
            ),
            Node(
                package='my_robot_package',
                executable='sensor_processor',
                name='sensor_processor',
                output='screen'
            )
        ]
    )

    # Coordinator node for multi-robot coordination
    coordinator_node = Node(
        package='my_robot_package',
        executable='multi_robot_coordinator',
        name='multi_robot_coordinator',
        parameters=[
            {'robot_names': ['robot1', 'robot2']},
            {'coordination_strategy': 'distributed'}
        ],
        output='screen'
    )

    return LaunchDescription([
        declare_robot1_namespace,
        declare_robot2_namespace,
        declare_use_composition,
        declare_composable_nodes,

        robot1_group,
        robot2_group,
        coordinator_node,
    ])
```

### Composable Nodes Launch

For performance optimization, ROS 2 supports composable nodes that run in the same process:

```python
# launch/composable_system.launch.py
from launch import LaunchDescription
from launch_ros.actions import ComposableNodeContainer
from launch_ros.descriptions import ComposableNode

def generate_launch_description():
    # Create a container for composable nodes
    container = ComposableNodeContainer(
        name='robot_system_container',
        namespace='',
        package='rclcpp_components',
        executable='component_container',
        composable_node_descriptions=[
            ComposableNode(
                package='my_robot_package',
                plugin='my_robot_package::SensorProcessorComponent',
                name='sensor_processor',
                parameters=[
                    {'sensor_frequency': 50.0},
                    {'enable_filtering': True}
                ]
            ),
            ComposableNode(
                package='my_robot_package',
                plugin='my_robot_package::ControllerComponent',
                name='controller',
                parameters=[
                    {'control_frequency': 100.0},
                    {'max_velocity': 1.0}
                ]
            ),
            ComposableNode(
                package='my_robot_package',
                plugin='my_robot_package::NavigationComponent',
                name='navigator',
                parameters=[
                    {'planning_frequency': 10.0},
                    {'goal_tolerance': 0.1}
                ]
            )
        ],
        output='screen',
    )

    return LaunchDescription([container])
```

## XML Launch Files

While Python is preferred, XML launch files are still supported for simpler configurations:

```xml
<!-- launch/simple_robot.launch.xml -->
<launch>
  <arg name="use_sim_time" default="false"/>
  <arg name="robot_name" default="default_robot"/>

  <node pkg="my_robot_package" exec="robot_controller" name="robot_controller">
    <param name="robot_name" value="$(var robot_name)"/>
    <param name="use_sim_time" value="$(var use_sim_time)"/>
    <remap from="cmd_vel" to="robot_cmd_vel"/>
  </node>

  <node pkg="my_robot_package" exec="sensor_processor" name="sensor_processor">
    <param name="use_sim_time" value="$(var use_sim_time)"/>
  </node>

  <node pkg="rviz2" exec="rviz2" name="rviz2" required="false">
    <arg name="display-config" value="$(find-pkg-share my_robot_package)/rviz/default.rviz"/>
  </node>
</launch>
```

## Launch File Best Practices

### Parameter Management in Launch Files

Launch files can include parameter files for complex configurations:

```python
# launch/parameterized_system.launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, RegisterEventHandler
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
from launch.event_handlers import OnProcessStart
import os

def generate_launch_description():
    # Declare launch arguments
    declare_params_file = DeclareLaunchArgument(
        'params_file',
        default_value=PathJoinSubstitution([
            FindPackageShare('my_robot_package'),
            'config',
            'robot_params.yaml'
        ]),
        description='Full path to the ROS2 parameters file to use for robot controller nodes'
    )

    declare_robot_name = DeclareLaunchArgument(
        'robot_name',
        default_value='default_robot',
        description='Name of the robot'
    )

    # Get launch configurations
    params_file = LaunchConfiguration('params_file')
    robot_name = LaunchConfiguration('robot_name')

    # Robot controller with parameter file
    robot_controller = Node(
        package='my_robot_package',
        executable='robot_controller',
        name='robot_controller',
        parameters=[
            params_file,
            {'robot_name': robot_name}
        ],
        output='screen'
    )

    # Event handler for post-start actions
    event_handler = RegisterEventHandler(
        OnProcessStart(
            target_action=robot_controller,
            on_start=[
                # Additional actions after node starts
            ]
        )
    )

    return LaunchDescription([
        declare_params_file,
        declare_robot_name,
        robot_controller,
        event_handler
    ])
```

### Conditional Launch

Launch files can include conditional logic for flexible system configurations:

```python
# launch/conditional_system.launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.conditions import IfCondition, UnlessCondition
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    # Declare launch arguments
    declare_use_sim = DeclareLaunchArgument(
        'use_simulation',
        default_value='false',
        description='Whether to use simulation'
    )

    declare_enable_viz = DeclareLaunchArgument(
        'enable_visualization',
        default_value='true',
        description='Whether to enable visualization tools'
    )

    # Get launch configurations
    use_sim = LaunchConfiguration('use_simulation')
    enable_viz = LaunchConfiguration('enable_visualization')

    # Nodes that run in both simulation and real
    robot_controller = Node(
        package='my_robot_package',
        executable='robot_controller',
        name='robot_controller',
        condition=UnlessCondition(use_sim),
        output='screen'
    )

    # Simulation-specific nodes
    sim_nodes = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            PathJoinSubstitution([
                FindPackageShare('my_robot_gazebo'),
                'launch',
                'robot_gazebo.launch.py'
            ])
        ]),
        condition=IfCondition(use_sim)
    )

    # Visualization nodes (conditional)
    rviz_node = Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        condition=IfCondition(enable_viz),
        output='screen'
    )

    return LaunchDescription([
        declare_use_sim,
        declare_enable_viz,
        robot_controller,
        sim_nodes,
        rviz_node
    ])
```

## Launch File Testing and Validation

### Unit Testing Launch Files

Launch files can be tested to ensure they work correctly:

```python
# test/test_launch_files.py
import unittest
import launch
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node
import launch_testing
import launch_testing.actions
import pytest

@pytest.mark.launch_test
def generate_test_description():
    """Generate launch description with all nodes for testing."""
    robot_controller = Node(
        package='my_robot_package',
        executable='robot_controller',
        name='robot_controller_test',
        output='screen'
    )

    return LaunchDescription([
        robot_controller,
        launch_testing.actions.ReadyToTest()
    ])

def test_nodes_start_successfully():
    """Test that nodes start successfully."""
    # This would contain actual test logic
    assert True
```

Launch files are a critical component of ROS 2 systems, providing the orchestration layer that brings together multiple nodes and configurations into a cohesive robotic application. Proper use of launch files ensures that complex robotic systems can be started, configured, and managed effectively.
