---
title: Nodes and Topics in ROS 2
---

# Nodes and Topics in ROS 2

## Introduction

Nodes and topics form the fundamental communication infrastructure of ROS 2, enabling asynchronous, decoupled communication between different components of a robotic system. This publish/subscribe pattern allows for flexible, scalable architectures where components can be developed, tested, and deployed independently while maintaining seamless communication.

## Understanding Nodes

### What is a Node?

A node in ROS 2 is an executable process that performs computation. Nodes are the basic building blocks of a ROS 2 system, and they can:
- Publish messages to topics
- Subscribe to topics to receive messages
- Provide services
- Call services
- Execute actions
- Declare and use parameters

### Node Lifecycle

ROS 2 nodes follow a well-defined lifecycle that enables better system management:

#### Lifecycle States
- **Unconfigured**: Node created but not yet configured
- **Inactive**: Node configured but not active
- **Active**: Node running and performing its function
- **Finalized**: Node has been shut down

#### Lifecycle Transitions
```python
from rclpy.lifecycle import LifecycleNode
from rclpy.lifecycle import TransitionCallbackReturn

class LifecycleExampleNode(LifecycleNode):
    def on_configure(self, state):
        """Called when transitioning to INACTIVE state."""
        self.get_logger().info('Configuring node...')
        # Setup resources, initialize variables
        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state):
        """Called when transitioning to ACTIVE state."""
        self.get_logger().info('Activating node...')
        # Start timers, enable publishers/subscribers
        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, state):
        """Called when transitioning from ACTIVE state."""
        self.get_logger().info('Deactivating node...')
        # Stop timers, disable publishers/subscribers
        return TransitionCallbackReturn.SUCCESS

    def on_cleanup(self, state):
        """Called when transitioning from INACTIVE to UNCONFIGURED."""
        self.get_logger().info('Cleaning up node...')
        # Release resources
        return TransitionCallbackReturn.SUCCESS
```

### Node Implementation Patterns

#### Simple Node Pattern
```python
import rclpy
from rclpy.node import Node

class SimpleNode(Node):
    def __init__(self):
        super().__init__('simple_node')
        self.get_logger().info('Simple node initialized')

        # Create a timer for periodic execution
        self.timer = self.create_timer(1.0, self.timer_callback)
        self.counter = 0

    def timer_callback(self):
        self.get_logger().info(f'Counter: {self.counter}')
        self.counter += 1
```

#### Sensor Node Pattern
```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
import random

class SensorNode(Node):
    def __init__(self):
        super().__init__('sensor_node')

        # Create publisher for sensor data
        self.publisher = self.create_publisher(
            LaserScan,
            'laser_scan',
            10
        )

        # Simulate sensor readings
        self.timer = self.create_timer(0.1, self.publish_sensor_data)

    def publish_sensor_data(self):
        msg = LaserScan()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'laser_frame'

        # Simulate 360 degree scan with random values
        msg.ranges = [random.uniform(0.1, 10.0) for _ in range(360)]

        self.publisher.publish(msg)
```

### Node Best Practices

#### Proper Resource Management
- Initialize resources in constructor
- Clean up resources in destructor or lifecycle callbacks
- Use try/finally blocks for critical resource management
- Implement proper error handling

#### Error Handling and Recovery
```python
def robust_timer_callback(self):
    try:
        # Perform critical operation
        result = self.perform_operation()
        self.publish_result(result)
    except Exception as e:
        self.get_logger().error(f'Error in timer callback: {e}')
        # Implement recovery strategy
        self.handle_error(e)
```

## Understanding Topics

### Topic Communication Model

Topics implement the publish/subscribe communication pattern where:
- **Publishers** send messages to topics
- **Subscribers** receive messages from topics
- Communication is asynchronous and decoupled
- Multiple publishers and subscribers can exist for the same topic

### Topic Architecture

#### Publisher-Subscriber Relationship
```
[Publisher Node] ----> [Topic] <---- [Subscriber Node]
      |                     |
      |                     |
      V                     V
   Send Data            Receive Data
```

#### Message Flow
1. Publisher creates a message object
2. Publisher fills the message with data
3. Publisher calls publish() method
4. ROS 2 middleware handles message delivery
5. Subscribers receive the message through callbacks

### Topic Implementation

#### Publisher Implementation
```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String, Int32
from geometry_msgs.msg import Twist

class PublisherNode(Node):
    def __init__(self):
        super().__init__('publisher_node')

        # Create multiple publishers for different topics
        self.string_publisher = self.create_publisher(
            String,
            'chatter',
            10  # QoS history depth
        )

        self.cmd_vel_publisher = self.create_publisher(
            Twist,
            'cmd_vel',
            10
        )

        # Timer to periodically publish messages
        self.timer = self.create_timer(0.5, self.publish_messages)
        self.counter = 0

    def publish_messages(self):
        # Publish string message
        string_msg = String()
        string_msg.data = f'Hello World: {self.counter}'
        self.string_publisher.publish(string_msg)

        # Publish velocity command
        cmd_msg = Twist()
        cmd_msg.linear.x = 0.5  # Move forward at 0.5 m/s
        cmd_msg.angular.z = 0.2  # Rotate at 0.2 rad/s
        self.cmd_vel_publisher.publish(cmd_msg)

        self.counter += 1
```

#### Subscriber Implementation
```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from geometry_msgs.msg import Twist

class SubscriberNode(Node):
    def __init__(self):
        super().__init__('subscriber_node')

        # Create subscribers for different topics
        self.string_subscriber = self.create_subscription(
            String,
            'chatter',
            self.string_callback,
            10  # QoS history depth
        )

        self.cmd_vel_subscriber = self.create_subscription(
            Twist,
            'cmd_vel',
            self.cmd_vel_callback,
            10
        )

    def string_callback(self, msg):
        self.get_logger().info(f'Received string: {msg.data}')

    def cmd_vel_callback(self, msg):
        self.get_logger().info(
            f'Received velocity command: '
            f'linear.x={msg.linear.x}, angular.z={msg.angular.z}'
        )
```

## Quality of Service (QoS) in Topics

### QoS Policies for Topics

QoS policies determine how messages are handled by the DDS middleware:

#### Reliability Policy
```python
from rclpy.qos import QoSProfile, ReliabilityPolicy

# For critical data where delivery is essential
critical_qos = QoSProfile(
    reliability=ReliabilityPolicy.RELIABLE,
    history=QoSHistoryPolicy.KEEP_LAST,
    depth=10
)

# For high-frequency data where some loss is acceptable
high_freq_qos = QoSProfile(
    reliability=ReliabilityPolicy.BEST_EFFORT,
    history=QoSHistoryPolicy.KEEP_LAST,
    depth=1
)
```

#### Durability Policy
```python
from rclpy.qos import DurabilityPolicy

# For configuration data that should be available to late-joining subscribers
transient_qos = QoSProfile(
    durability=DurabilityPolicy.TRANSIENT_LOCAL,
    history=QoSHistoryPolicy.KEEP_ALL
)

# For regular data where only future messages matter
volatile_qos = QoSProfile(
    durability=DurabilityPolicy.VOLATILE,
    history=QoSHistoryPolicy.KEEP_LAST,
    depth=10
)
```

#### History Policy
```python
from rclpy.qos import HistoryPolicy

# Keep only the most recent messages
last_5_qos = QoSProfile(
    history=HistoryPolicy.KEEP_LAST,
    depth=5
)

# Keep all messages (be careful with memory usage)
all_qos = QoSProfile(
    history=HistoryPolicy.KEEP_ALL
)
```

### Practical QoS Examples

#### Sensor Data QoS
```python
# High-frequency sensor data (e.g., IMU, camera)
sensor_qos = QoSProfile(
    reliability=ReliabilityPolicy.BEST_EFFORT,
    durability=DurabilityPolicy.VOLATILE,
    history=QoSHistoryPolicy.KEEP_LAST,
    depth=1  # Only keep the most recent message
)

# Critical sensor data (e.g., emergency stop)
critical_sensor_qos = QoSProfile(
    reliability=ReliabilityPolicy.RELIABLE,
    durability=DurabilityPolicy.VOLATILE,
    history=QoSHistoryPolicy.KEEP_LAST,
    depth=10
)
```

#### Control Command QoS
```python
# Robot control commands (velocity, joint positions)
control_qos = QoSProfile(
    reliability=ReliabilityPolicy.RELIABLE,
    durability=DurabilityPolicy.VOLATILE,
    history=QoSHistoryPolicy.KEEP_LAST,
    depth=1  # Only use the most recent command
)
```

## Advanced Topic Patterns

### Multiple Publishers/Single Subscriber Pattern

This pattern is common in sensor fusion applications:

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan, Imu, Image
from std_msgs.msg import Header

class SensorFusionNode(Node):
    def __init__(self):
        super().__init__('sensor_fusion_node')

        # Subscribe to multiple sensor streams
        self.laser_sub = self.create_subscription(
            LaserScan, 'laser_scan', self.laser_callback, 10
        )
        self.imu_sub = self.create_subscription(
            Imu, 'imu_data', self.imu_callback, 10
        )
        self.camera_sub = self.create_subscription(
            Image, 'camera/image_raw', self.camera_callback, 10
        )

        # Publish fused data
        self.fused_publisher = self.create_publisher(
            String, 'fused_sensor_data', 10
        )

        # Store sensor data for fusion
        self.laser_data = None
        self.imu_data = None
        self.camera_data = None

    def laser_callback(self, msg):
        self.laser_data = msg
        self.fuse_if_complete()

    def imu_callback(self, msg):
        self.imu_data = msg
        self.fuse_if_complete()

    def camera_callback(self, msg):
        self.camera_data = msg
        self.fuse_if_complete()

    def fuse_if_complete(self):
        if self.laser_data and self.imu_data and self.camera_data:
            # Perform sensor fusion logic
            fused_msg = String()
            fused_msg.data = f"Fused data at {self.get_clock().now()}"
            self.fused_publisher.publish(fused_msg)

            # Reset for next fusion cycle
            self.laser_data = None
            self.imu_data = None
            self.camera_data = None
```

### Single Publisher/Multiple Subscribers Pattern

This pattern is common for sharing processed data:

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
import time

class DataSharingNode(Node):
    def __init__(self):
        super().__init__('data_sharing_node')

        # Single publisher for processed data
        self.pose_publisher = self.create_publisher(
            PoseStamped, 'robot_pose', 10
        )

        # Timer to periodically publish data
        self.timer = self.create_timer(0.1, self.publish_pose)

    def publish_pose(self):
        msg = PoseStamped()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'map'

        # Simulate robot pose (in real application, this would come from localization)
        msg.pose.position.x = 1.0
        msg.pose.position.y = 2.0
        msg.pose.position.z = 0.0

        self.pose_publisher.publish(msg)
```

## Topic Monitoring and Debugging

### Command Line Tools

#### Topic Inspection
```bash
# List all topics
ros2 topic list

# Get information about a specific topic
ros2 topic info /topic_name

# Echo topic messages
ros2 topic echo /topic_name MessageType

# Show message statistics
ros2 topic hz /topic_name

# Show message delay
ros2 topic delay /topic_name
```

#### Topic Manipulation
```bash
# Publish a single message
ros2 topic pub /topic_name MessageType "field: value"

# Publish messages at a rate
ros2 topic pub -r 1 /topic_name MessageType "field: value"
```

### Programmatic Monitoring

```python
from rclpy.qos import qos_profile_sensor_data
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class TopicMonitorNode(Node):
    def __init__(self):
        super().__init__('topic_monitor')

        # Subscribe with monitoring
        self.subscriber = self.create_subscription(
            String,
            'monitored_topic',
            self.monitored_callback,
            qos_profile=qos_profile_sensor_data
        )

        # Statistics
        self.message_count = 0
        self.start_time = self.get_clock().now()

    def monitored_callback(self, msg):
        self.message_count += 1
        current_time = self.get_clock().now()

        # Log statistics every 100 messages
        if self.message_count % 100 == 0:
            elapsed = (current_time - self.start_time).nanoseconds / 1e9
            rate = self.message_count / elapsed if elapsed > 0 else 0
            self.get_logger().info(
                f'Messages: {self.message_count}, Rate: {rate:.2f} Hz'
            )

        # Process the message
        self.process_message(msg)

    def process_message(self, msg):
        # Implement message processing logic
        pass
```

## Performance Considerations

### Message Optimization

#### Message Size
- Keep messages small to reduce bandwidth and latency
- Use efficient data types (float32 instead of float64 when precision allows)
- Consider compression for large data like images

#### Message Frequency
- Balance between responsiveness and system load
- Use appropriate QoS settings for different frequencies
- Consider message throttling for high-frequency data

### Memory Management

```python
# Reuse message objects to reduce allocation overhead
class OptimizedPublisherNode(Node):
    def __init__(self):
        super().__init__('optimized_publisher')
        self.publisher = self.create_publisher(String, 'optimized_topic', 10)

        # Pre-allocate message object
        self.msg = String()
        self.timer = self.create_timer(0.01, self.optimized_publish)

    def optimized_publish(self):
        # Reuse the same message object
        self.msg.data = f'Optimized message {self.get_clock().now().nanoseconds}'
        self.publisher.publish(self.msg)
```

### Network Considerations

#### Bandwidth Management
- Monitor network usage for multi-robot systems
- Use appropriate QoS for network-constrained environments
- Consider data filtering and preprocessing

#### Latency Optimization
- Use reliable QoS for critical control data
- Use best effort for non-critical high-frequency data
- Consider local processing to reduce network dependencies

## Integration with Physical AI Systems

### Sensor Integration Patterns

#### Multi-Sensor Data Flow
```python
class MultiSensorNode(Node):
    def __init__(self):
        super().__init__('multi_sensor_node')

        # High-frequency sensors (best effort)
        self.imu_sub = self.create_subscription(
            Imu, 'imu/data', self.imu_callback,
            qos_profile=qos_profile_sensor_data
        )

        # Critical sensors (reliable)
        self.emergency_sub = self.create_subscription(
            Bool, 'emergency_stop', self.emergency_callback,
            qos_profile=qos_profile_services_default
        )

        # Control commands (reliable, small history)
        self.cmd_pub = self.create_publisher(
            Twist, 'cmd_vel',
            qos_profile=qos_profile_services_default
        )

    def imu_callback(self, msg):
        # Process high-frequency IMU data
        self.process_imu_data(msg)

    def emergency_callback(self, msg):
        # Handle critical emergency signals
        if msg.data:
            self.emergency_stop()
```

### Real-time Considerations

#### Real-time Scheduling for Nodes
```python
import os
import mmap
from rclpy.qos import QoSProfile

class RealTimeNode(Node):
    def __init__(self):
        super().__init__('real_time_node')

        # Lock memory to prevent page faults
        self.lock_memory()

        # Set up real-time publisher
        self.rt_publisher = self.create_publisher(
            String, 'real_time_topic',
            QoSProfile(
                reliability=ReliabilityPolicy.RELIABLE,
                history=QoSHistoryPolicy.KEEP_LAST,
                depth=1
            )
        )

        # Use real-time timer
        self.rt_timer = self.create_timer(
            0.001,  # 1ms period
            self.real_time_callback,
            clock=Clock(clock_type=ClockType.STEADY_TIME)
        )

    def lock_memory(self):
        # Lock current process memory to prevent page faults
        try:
            mmap.mmap(-1, os.sysconf('SC_PAGE_SIZE'), flags=mmap.MAP_ANONYMOUS | mmap.MAP_LOCKED)
        except Exception as e:
            self.get_logger().warn(f'Could not lock memory: {e}')

    def real_time_callback(self):
        # Real-time critical operation
        msg = String()
        msg.data = f'Real-time: {self.get_clock().now()}'
        self.rt_publisher.publish(msg)
```

## Best Practices Summary

### Node Design
1. **Single Responsibility**: Each node should have one clear purpose
2. **Proper Lifecycle**: Implement lifecycle management for complex nodes
3. **Error Handling**: Include robust error handling and recovery
4. **Resource Management**: Properly initialize and clean up resources

### Topic Design
1. **Appropriate QoS**: Choose QoS policies based on data requirements
2. **Message Optimization**: Keep messages efficient and appropriately sized
3. **Naming Conventions**: Use clear, consistent topic naming
4. **Documentation**: Document topic purposes and message formats

### Performance
1. **Monitor Usage**: Track message rates and system load
2. **Optimize Frequency**: Balance between performance and system load
3. **Memory Management**: Reuse objects and manage memory efficiently
4. **Network Awareness**: Consider network constraints in multi-robot systems

## Chapter Summary

Nodes and topics form the backbone of ROS 2's communication architecture, providing the asynchronous, decoupled communication necessary for complex robotic systems. Understanding proper node implementation, topic usage, and Quality of Service policies is essential for building robust, efficient robotic applications.

The publish/subscribe pattern enables flexible system architectures where components can be developed independently while maintaining seamless communication. Proper QoS selection ensures that different types of data (critical vs. high-frequency) are handled appropriately.

These concepts are fundamental to coordinating the complex sensor and actuator systems required in Physical AI applications, particularly in humanoid robots where multiple subsystems must communicate effectively to achieve coordinated behavior.

## Exercises

1. **Implementation**: Create a ROS 2 node that publishes sensor data with appropriate QoS settings and another node that subscribes to this data and performs basic processing.

2. **Analysis**: Design a multi-sensor fusion system using nodes and topics. Identify which sensors would use reliable vs. best-effort QoS and justify your choices.

3. **Optimization**: Implement a message optimization strategy where message objects are reused to reduce allocation overhead. Measure the performance improvement.

## Further Reading

- ROS 2 Documentation: Quality of Service (QoS) - https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html
- ROS 2 Design: Nodes and Topics - https://design.ros2.org/articles/topic_and_service_names.html
- DDS Specification: Quality of Service - https://www.omg.org/spec/DDS/