---
title: Chapter 4 - Services and Actions in ROS 2
---

# Services and Actions in ROS 2

## Introduction

Services and actions represent two critical communication patterns in ROS 2 that complement topics. Services provide synchronous request/response communication for immediate computations, while actions handle goal-oriented, long-running tasks with feedback and cancellation capabilities.

## Service Implementation

### Basic Service Architecture

Services provide synchronous request/response communication for immediate computations and operations:

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from example_interfaces.srv import AddTwoInts, SetBool
from std_srvs.srv import Trigger, Empty
from sensor_msgs.srv import SetCameraInfo
import time
import threading
from rclpy.task import Future

class BasicServiceNode(Node):
    def __init__(self):
        super().__init__('basic_service_node')

        # Multiple service servers
        self.add_service = self.create_service(
            AddTwoInts, 'add_two_ints', self.add_callback
        )

        self.toggle_service = self.create_service(
            SetBool, 'toggle_device', self.toggle_callback
        )

        self.trigger_service = self.create_service(
            Trigger, 'trigger_operation', self.trigger_callback
        )

    def add_callback(self, request, response):
        """Basic addition service."""
        try:
            result = request.a + request.b
            response.sum = result
            response.success = True
            response.message = f'Successfully calculated {request.a} + {request.b} = {result}'
            self.get_logger().info(f'Add service: {request.a} + {request.b} = {result}')
        except Exception as e:
            self.get_logger().error(f'Add service error: {e}')
            response.success = False
            response.message = f'Calculation error: {str(e)}'

        return response

    def toggle_callback(self, request, response):
        """Basic toggle service."""
        try:
            device_state = request.data
            self.get_logger().info(f'Toggling device to state: {device_state}')

            # Simulate hardware operation time
            time.sleep(0.1)

            response.success = True
            response.message = f'Device toggled to {"ON" if device_state else "OFF"}'

        except Exception as e:
            self.get_logger().error(f'Toggle service error: {e}')
            response.success = False
            response.message = f'Toggle operation failed: {str(e)}'

        return response

    def trigger_callback(self, request, response):
        """Basic trigger service."""
        try:
            # Perform operation
            success = self.perform_operation()

            response.success = success
            response.message = 'Operation completed successfully' if success else 'Operation failed'

        except Exception as e:
            self.get_logger().error(f'Trigger service error: {e}')
            response.success = False
            response.message = f'Trigger operation failed: {str(e)}'

        return response

    def perform_operation(self):
        """Perform a simple operation."""
        # Simulate operation
        time.sleep(0.5)
        return True
```

### Robust Service Architecture

Advanced service implementations with comprehensive error handling and monitoring:

```python
class RobustServiceNode(Node):
    def __init__(self):
        super().__init__('robust_service_node')

        # Multiple service servers
        self.add_service = self.create_service(
            AddTwoInts, 'robust_add_two_ints', self.robust_add_callback
        )

        self.toggle_service = self.create_service(
            SetBool, 'toggle_device', self.toggle_callback
        )

        self.trigger_service = self.create_service(
            Trigger, 'trigger_operation', self.trigger_callback
        )

        # Service clients for internal coordination
        self.dependency_client = self.create_client(
            Trigger, 'dependency_service'
        )

        # Statistics for monitoring
        self.service_stats = {
            'add': {'requests': 0, 'errors': 0, 'avg_time': 0.0},
            'toggle': {'requests': 0, 'errors': 0, 'avg_time': 0.0},
            'trigger': {'requests': 0, 'errors': 0, 'avg_time': 0.0}
        }

        # Thread-safe statistics
        self.stats_lock = threading.Lock()

    def robust_add_callback(self, request, response):
        """Robust addition service with error handling."""
        start_time = time.time()
        self._update_stats('add', 'requests')

        try:
            # Validate inputs
            if not self._validate_numbers(request.a, request.b):
                self.get_logger().error('Invalid numbers provided to add service')
                response.success = False
                response.message = 'Invalid input numbers'
                self._update_stats('add', 'errors')
                return response

            # Perform calculation
            result = self._safe_add(request.a, request.b)
            response.sum = result
            response.success = True
            response.message = f'Successfully calculated {request.a} + {request.b} = {result}'

            # Log successful operation
            processing_time = time.time() - start_time
            self._update_avg_time('add', processing_time)
            self.get_logger().info(
                f'Add service: {request.a} + {request.b} = {result} '
                f'(time: {processing_time:.4f}s)'
            )

        except Exception as e:
            self.get_logger().error(f'Add service error: {e}')
            response.success = False
            response.message = f'Calculation error: {str(e)}'
            self._update_stats('add', 'errors')

        return response

    def toggle_callback(self, request, response):
        """Toggle service with state management."""
        start_time = time.time()
        self._update_stats('toggle', 'requests')

        try:
            # Simulate device toggle operation
            device_state = request.data
            self.get_logger().info(f'Toggling device to state: {device_state}')

            # Simulate hardware operation time
            time.sleep(0.1)

            response.success = True
            response.message = f'Device toggled to {"ON" if device_state else "OFF"}'

            processing_time = time.time() - start_time
            self._update_avg_time('toggle', processing_time)

        except Exception as e:
            self.get_logger().error(f'Toggle service error: {e}')
            response.success = False
            response.message = f'Toggle operation failed: {str(e)}'
            self._update_stats('toggle', 'errors')

        return response

    def trigger_callback(self, request, response):
        """Trigger service with complex operations."""
        start_time = time.time()
        self._update_stats('trigger', 'requests')

        try:
            # Check dependencies
            if not self._check_dependencies():
                response.success = False
                response.message = 'Required dependencies not available'
                self._update_stats('trigger', 'errors')
                return response

            # Perform complex operation
            success = self._perform_complex_operation()

            response.success = success
            response.message = 'Operation completed successfully' if success else 'Operation failed'

            processing_time = time.time() - start_time
            self._update_avg_time('trigger', processing_time)

        except Exception as e:
            self.get_logger().error(f'Trigger service error: {e}')
            response.success = False
            response.message = f'Trigger operation failed: {str(e)}'
            self._update_stats('trigger', 'errors')

        return response

    def _validate_numbers(self, a, b):
        """Validate number inputs."""
        if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
            return False
        if abs(a) > 1e10 or abs(b) > 1e10:
            self.get_logger().warn('Very large numbers detected')
        return True

    def _safe_add(self, a, b):
        """Perform safe addition with overflow protection."""
        try:
            result = a + b
            if not np.isfinite(result):
                raise ValueError('Result is not finite')
            return result
        except OverflowError:
            raise ValueError('Addition resulted in overflow')

    def _check_dependencies(self):
        """Check if required dependencies are available."""
        # Simulate dependency check
        return True

    def _perform_complex_operation(self):
        """Perform a complex operation."""
        # Simulate complex operation
        time.sleep(0.5)
        return True

    def _update_stats(self, service_name, stat_type):
        """Thread-safe statistics update."""
        with self.stats_lock:
            if stat_type == 'requests':
                self.service_stats[service_name]['requests'] += 1
            elif stat_type == 'errors':
                self.service_stats[service_name]['errors'] += 1

    def _update_avg_time(self, service_name, processing_time):
        """Update average processing time."""
        with self.stats_lock:
            stats = self.service_stats[service_name]
            current_avg = stats['avg_time']
            count = stats['requests']
            stats['avg_time'] = ((current_avg * (count - 1)) + processing_time) / count
```

### Service Chaining and Coordination

Complex robotic systems often require services that coordinate with other services:

```python
from rclpy.qos import qos_profile_services_default
from example_interfaces.srv import AddTwoInts, SetBool
from std_srvs.srv import Trigger
import asyncio

class ServiceCoordinatorNode(Node):
    def __init__(self):
        super().__init__('service_coordinator')

        # Main service that coordinates other services
        self.complex_calc_service = self.create_service(
            AddTwoInts, 'complex_calculation', self.complex_calc_callback
        )

        # Client for dependency services
        self.add_client = self.create_client(AddTwoInts, 'robust_add_two_ints')
        self.multiply_client = self.create_client(AddTwoInts, 'multiply_service')
        self.validation_client = self.create_client(SetBool, 'validate_inputs')

        # Wait for services to be available
        self.get_logger().info('Waiting for dependency services...')
        while not self.add_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Add service not available, waiting...')
        while not self.multiply_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Multiply service not available, waiting...')
        while not self.validation_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Validation service not available, waiting...')

    def complex_calc_callback(self, request, response):
        """Complex calculation that chains multiple services."""
        try:
            # First, validate inputs
            validation_request = SetBool.Request()
            validation_request.data = True  # Simplified validation
            validation_future = self.validation_client.call_async(validation_request)

            # Wait for validation result
            rclpy.spin_until_future_complete(self, validation_future)
            validation_result = validation_future.result()

            if not validation_result.success:
                response.success = False
                response.message = validation_result.message
                return response

            # Perform addition using dependency service
            add_request = AddTwoInts.Request()
            add_request.a = request.a
            add_request.b = request.b
            add_future = self.add_client.call_async(add_request)

            # Wait for addition result
            rclpy.spin_until_future_complete(self, add_future)
            add_result = add_future.result()

            if not add_result.sum:
                response.success = False
                response.message = 'Addition service failed'
                return response

            # Multiply result by a factor (simplified example)
            multiply_request = AddTwoInts.Request()
            multiply_request.a = add_result.sum
            multiply_request.b = 2  # Factor of 2
            multiply_future = self.multiply_client.call_async(multiply_request)

            # Wait for multiplication result
            rclpy.spin_until_future_complete(self, multiply_future)
            multiply_result = multiply_future.result()

            response.sum = multiply_result.sum
            response.success = True
            response.message = f'Complex calculation completed: ({request.a} + {request.b}) * 2 = {multiply_result.sum}'

        except Exception as e:
            self.get_logger().error(f'Complex calculation error: {e}')
            response.success = False
            response.message = f'Complex calculation failed: {str(e)}'

        return response

class ServiceLoadBalancerNode(Node):
    def __init__(self):
        super().__init__('service_load_balancer')

        # Main service interface
        self.load_balanced_service = self.create_service(
            AddTwoInts, 'load_balanced_calc', self.load_balanced_callback
        )

        # Multiple backend services
        self.backend_clients = [
            self.create_client(AddTwoInts, 'backend_calc_1'),
            self.create_client(AddTwoInts, 'backend_calc_2'),
            self.create_client(AddTwoInts, 'backend_calc_3')
        ]

        # Load balancing state
        self.current_backend = 0
        self.backend_stats = [0] * len(self.backend_clients)  # Request counts

        # Wait for all backends
        for i, client in enumerate(self.backend_clients):
            while not client.wait_for_service(timeout_sec=1.0):
                self.get_logger().info(f'Backend {i+1} not available, waiting...')

    def load_balanced_callback(self, request, response):
        """Distribute requests across multiple backend services."""
        # Select backend using round-robin
        selected_client = self.backend_clients[self.current_backend]
        self.backend_stats[self.current_backend] += 1

        # Update for next request
        self.current_backend = (self.current_backend + 1) % len(self.backend_clients)

        try:
            # Call backend service
            backend_request = AddTwoInts.Request()
            backend_request.a = request.a
            backend_request.b = request.b

            backend_future = selected_client.call_async(backend_request)
            rclpy.spin_until_future_complete(self, backend_future)
            backend_result = backend_future.result()

            response.sum = backend_result.sum
            response.success = backend_result.sum is not None
            response.message = f'Processed by backend {self.current_backend}'

        except Exception as e:
            self.get_logger().error(f'Load balancer error: {e}')
            response.success = False
            response.message = f'Load balancing failed: {str(e)}'

        return response
```

## Action Implementation

### Basic Action Server

Actions provide goal-oriented communication with feedback and cancellation for long-running tasks:

```python
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.callback_groups import ReentrantCallbackGroup
from example_interfaces.action import Fibonacci
from geometry_msgs.action import NavigateToPose
from control_msgs.action import FollowJointTrajectory
import threading
import time
import math
from collections import deque

class BasicActionServer(Node):
    def __init__(self):
        super().__init__('basic_action_server')

        # Use reentrant callback group for concurrent access
        callback_group = ReentrantCallbackGroup()

        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci_action',
            self.execute_callback,
            goal_callback=self.goal_callback,
            handle_accepted_callback=self.handle_accepted_callback,
            cancel_callback=self.cancel_callback,
            callback_group=callback_group
        )

        # State tracking
        self.active_goals = {}

    def goal_callback(self, goal_request):
        """Validate and accept/reject goals."""
        # Validate goal
        if goal_request.order < 0 or goal_request.order > 100:  # Reasonable limit
            self.get_logger().warn(f'Goal order out of range: {goal_request.order}')
            return GoalResponse.REJECT
        else:
            self.get_logger().info(f'Accepting goal with order: {goal_request.order}')
            return GoalResponse.ACCEPT

    def handle_accepted_callback(self, goal_handle):
        """Handle accepted goal by starting execution."""
        self.get_logger().info('Goal accepted, starting execution')

        # Store goal in active goals
        goal_id = goal_handle.goal_id.uuid
        self.active_goals[goal_id] = goal_handle

        # Start execution in separate thread
        thread = threading.Thread(target=self.execute_goal, args=(goal_handle,))
        thread.start()

    def cancel_callback(self, goal_handle):
        """Handle cancel request."""
        self.get_logger().info('Goal cancellation requested')
        return CancelResponse.ACCEPT

    def execute_goal(self, goal_handle):
        """Execute goal in separate thread."""
        self.get_logger().info('Starting goal execution...')

        # Create feedback and result messages
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        result_msg = Fibonacci.Result()

        try:
            # Generate Fibonacci sequence
            for i in range(1, goal_handle.request.order):
                # Check for cancellation
                if goal_handle.is_cancel_requested:
                    self.get_logger().info('Goal cancelled')
                    goal_handle.canceled()
                    result_msg.sequence = feedback_msg.sequence

                    # Remove from active goals
                    goal_id = goal_handle.goal_id.uuid
                    if goal_id in self.active_goals:
                        del self.active_goals[goal_id]
                    return

                # Simulate processing time
                time.sleep(0.1)

                # Calculate next Fibonacci number
                next_fib = feedback_msg.sequence[i] + feedback_msg.sequence[i-1]
                feedback_msg.sequence.append(next_fib)

                # Publish feedback
                goal_handle.publish_feedback(feedback_msg)

                self.get_logger().info(f'Published feedback: {feedback_msg.sequence}')

            # Complete the goal successfully
            goal_handle.succeed()
            result_msg.sequence = feedback_msg.sequence
            self.get_logger().info(f'Goal succeeded with result: {result_msg.sequence}')

        except Exception as e:
            self.get_logger().error(f'Error during goal execution: {e}')
            goal_handle.abort()
            result_msg.sequence = feedback_msg.sequence

        finally:
            # Remove from active goals
            goal_id = goal_handle.goal_id.uuid
            if goal_id in self.active_goals:
                del self.active_goals[goal_id]

            # Publish final result
            goal_handle.publish_result(result_msg)

    def execute_callback(self, goal_handle):
        """Execute callback (placeholder - actual execution in separate thread)."""
        # This method is required by the action server interface
        # Actual execution happens in execute_goal in separate thread
        pass
```

### Advanced Action Server with Complex State Management

```python
class AdvancedNavigationActionServer(Node):
    def __init__(self):
        super().__init__('advanced_navigation_action_server')

        # Use reentrant callback group for concurrent access
        callback_group = ReentrantCallbackGroup()

        self._action_server = ActionServer(
            self,
            NavigateToPose,
            'navigate_to_pose',
            self.execute_callback,
            goal_callback=self.goal_callback,
            handle_accepted_callback=self.handle_accepted_callback,
            cancel_callback=self.cancel_callback,
            callback_group=callback_group
        )

        # State tracking
        self.current_pose = {'x': 0.0, 'y': 0.0, 'theta': 0.0}
        self.active_goals = {}
        self.navigation_history = deque(maxlen=100)

        # Publishers for navigation state
        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)
        self.pose_pub = self.create_publisher(PoseStamped, 'current_pose', 10)

        # Timer for periodic state updates
        self.state_timer = self.create_timer(0.1, self.update_navigation_state)

    def goal_callback(self, goal_request):
        """Validate and accept/reject navigation goals."""
        target_pose = goal_request.pose.pose
        current_pose = self.current_pose

        # Calculate distance to goal
        distance = math.sqrt(
            (target_pose.position.x - current_pose['x'])**2 +
            (target_pose.position.y - current_pose['y'])**2
        )

        # Validate goal
        if distance > 100.0:  # Max navigation distance
            self.get_logger().warn(f'Navigation goal too far: {distance:.2f}m')
            return GoalResponse.REJECT
        elif distance < 0.1:  # Already at goal
            self.get_logger().info('Already at navigation goal')
            return GoalResponse.REJECT
        else:
            self.get_logger().info(f'Accepting navigation goal, distance: {distance:.2f}m')
            return GoalResponse.ACCEPT

    def handle_accepted_callback(self, goal_handle):
        """Handle accepted goal by starting execution."""
        self.get_logger().info('Navigation goal accepted, starting execution')

        # Store goal in active goals
        goal_id = goal_handle.goal_id.uuid
        self.active_goals[goal_id] = goal_handle

        # Start execution in separate thread
        thread = threading.Thread(target=self.execute_navigation, args=(goal_handle,))
        thread.start()

    def cancel_callback(self, goal_handle):
        """Handle cancel request."""
        self.get_logger().info('Navigation goal cancellation requested')
        return CancelResponse.ACCEPT

    def execute_navigation(self, goal_handle):
        """Execute navigation in separate thread."""
        self.get_logger().info('Starting navigation execution...')

        # Extract goal pose
        target_pose = goal_handle.request.pose.pose
        target_x = target_pose.position.x
        target_y = target_pose.position.y

        # Navigation parameters
        linear_speed = 0.5
        angular_speed = 0.5
        tolerance = 0.1  # Distance tolerance in meters

        # Navigation loop
        while rclpy.ok():
            # Check for cancellation
            if goal_handle.is_cancel_requested:
                self.get_logger().info('Navigation goal cancelled')
                goal_handle.canceled()

                # Stop robot
                stop_msg = Twist()
                self.cmd_vel_pub.publish(stop_msg)

                # Remove from active goals
                goal_id = goal_handle.goal_id.uuid
                if goal_id in self.active_goals:
                    del self.active_goals[goal_id]
                return

            # Calculate distance to goal
            distance = math.sqrt(
                (target_x - self.current_pose['x'])**2 +
                (target_y - self.current_pose['y'])**2
            )

            # Check if reached goal
            if distance <= tolerance:
                self.get_logger().info('Navigation goal reached')

                # Stop robot
                stop_msg = Twist()
                self.cmd_vel_pub.publish(stop_msg)

                # Create result
                result = NavigateToPose.Result()
                result.result_code = 1  # Success

                goal_handle.succeed()
                goal_handle.publish_result(result)

                # Add to history
                history_entry = {
                    'start': (self.current_pose['x'], self.current_pose['y']),
                    'goal': (target_x, target_y),
                    'distance': distance,
                    'time': time.time()
                }
                self.navigation_history.append(history_entry)

                # Remove from active goals
                goal_id = goal_handle.goal_id.uuid
                if goal_id in self.active_goals:
                    del self.active_goals[goal_id]
                return

            # Calculate control commands
            cmd_vel = self.calculate_navigation_command(target_x, target_y, linear_speed, angular_speed)

            # Publish command
            self.cmd_vel_pub.publish(cmd_vel)

            # Publish feedback
            feedback = NavigateToPose.Feedback()
            feedback.current_pose.pose.position.x = self.current_pose['x']
            feedback.current_pose.pose.position.y = self.current_pose['y']
            feedback.distance_remaining = distance
            goal_handle.publish_feedback(feedback)

            # Log progress
            self.get_logger().info(f'Navigating: {distance:.2f}m remaining')

            # Sleep to control loop rate
            time.sleep(0.1)

    def calculate_navigation_command(self, target_x, target_y, linear_speed, angular_speed):
        """Calculate navigation commands."""
        # Calculate desired angle
        desired_angle = math.atan2(
            target_y - self.current_pose['y'],
            target_x - self.current_pose['x']
        )

        # Calculate angle difference
        angle_diff = desired_angle - self.current_pose['theta']

        # Normalize angle
        while angle_diff > math.pi:
            angle_diff -= 2 * math.pi
        while angle_diff < -math.pi:
            angle_diff += 2 * math.pi

        # Create command message
        cmd_vel = Twist()
        cmd_vel.linear.x = min(linear_speed, linear_speed * (abs(angle_diff) < 0.1))
        cmd_vel.angular.z = angular_speed * angle_diff

        return cmd_vel

    def update_navigation_state(self):
        """Update navigation state periodically."""
        # Simulate state updates (in real system, this would come from localization)
        self.current_pose['x'] += 0.01  # Simulated movement
        self.current_pose['y'] += 0.005  # Simulated movement

        # Publish current pose
        pose_msg = PoseStamped()
        pose_msg.header.stamp = self.get_clock().now().to_msg()
        pose_msg.header.frame_id = 'map'
        pose_msg.pose.position.x = self.current_pose['x']
        pose_msg.pose.position.y = self.current_pose['y']
        pose_msg.pose.orientation.w = 1.0  # Simplified orientation

        self.pose_pub.publish(pose_msg)

    def execute_callback(self, goal_handle):
        """Execute callback (placeholder - actual execution in separate thread)."""
        # This method is required by the action server interface
        # Actual execution happens in execute_navigation in separate thread
        pass
```

### Advanced Action Client with Comprehensive Features

Action clients need to handle various scenarios including timeouts, feedback, and result processing:

```python
from rclpy.action import ActionClient
from geometry_msgs.action import NavigateToPose
from control_msgs.action import FollowJointTrajectory
import time

class AdvancedNavigationActionClient(Node):
    def __init__(self):
        super().__init__('advanced_navigation_action_client')

        # Create action client
        self._action_client = ActionClient(
            self, NavigateToPose, 'navigate_to_pose'
        )

        # Wait for action server
        self.get_logger().info('Waiting for navigation action server...')
        self._action_client.wait_for_server()
        self.get_logger().info('Navigation action server available')

        # Statistics tracking
        self.navigation_stats = {
            'completed': 0,
            'cancelled': 0,
            'failed': 0,
            'avg_duration': 0.0
        }

    def send_navigation_goal(self, x, y, theta=0.0, timeout_sec=60.0):
        """Send navigation goal with comprehensive handling."""
        # Create goal message
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.pose.position.x = x
        goal_msg.pose.pose.position.y = y
        goal_msg.pose.pose.orientation.z = math.sin(theta / 2.0)
        goal_msg.pose.pose.orientation.w = math.cos(theta / 2.0)

        self.get_logger().info(f'Sending navigation goal to ({x}, {y}, {theta})')

        # Send goal asynchronously
        goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )

        # Add goal response callback
        goal_future.add_done_callback(
            lambda future: self.goal_response_callback(future, timeout_sec)
        )

        return goal_future

    def goal_response_callback(self, future, timeout_sec):
        """Handle goal response."""
        goal_handle = future.result()

        if not goal_handle.accepted:
            self.get_logger().info('Navigation goal rejected by server')
            return

        self.get_logger().info('Navigation goal accepted by server')

        # Get result future
        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.result_callback)

        # Set up timeout monitoring
        start_time = time.time()
        self.monitor_navigation_timeout(goal_handle, start_time, timeout_sec)

    def feedback_callback(self, feedback_msg):
        """Handle navigation feedback."""
        current_pos = feedback_msg.current_pose.pose.position
        remaining = feedback_msg.distance_remaining

        self.get_logger().info(
            f'Navigation progress: position=({current_pos.x:.2f}, {current_pos.y:.2f}), '
            f'distance remaining={remaining:.2f}m'
        )

    def result_callback(self, result_future):
        """Handle navigation result."""
        result = result_future.result().result
        status = result_future.result().status

        if status == GoalStatus.STATUS_SUCCEEDED:
            self.get_logger().info('Navigation completed successfully')
            self.navigation_stats['completed'] += 1
        elif status == GoalStatus.STATUS_CANCELED:
            self.get_logger().info('Navigation was cancelled')
            self.navigation_stats['cancelled'] += 1
        elif status == GoalStatus.STATUS_ABORTED:
            self.get_logger().info('Navigation failed')
            self.navigation_stats['failed'] += 1

    def monitor_navigation_timeout(self, goal_handle, start_time, timeout_sec):
        """Monitor navigation for timeout."""
        if time.time() - start_time > timeout_sec:
            self.get_logger().warn('Navigation timeout, cancelling goal...')
            self.cancel_current_navigation(goal_handle)
        else:
            # Schedule next check
            timer = self.create_timer(
                1.0,
                lambda: self.monitor_navigation_timeout(goal_handle, start_time, timeout_sec)
            )

    def cancel_current_navigation(self, goal_handle):
        """Cancel current navigation goal."""
        cancel_future = goal_handle.cancel_goal_async()
        cancel_future.add_done_callback(self.cancel_response_callback)

    def cancel_response_callback(self, future):
        """Handle cancellation response."""
        cancel_response = future.result()
        if len(cancel_response.goals_canceling) > 0:
            self.get_logger().info('Navigation goal successfully cancelled')
        else:
            self.get_logger().info('Navigation goal could not be cancelled')

    def send_multiple_goals(self, waypoints):
        """Send multiple navigation goals in sequence."""
        for i, (x, y, theta) in enumerate(waypoints):
            self.get_logger().info(f'Sending waypoint {i+1}: ({x}, {y}, {theta})')
            self.send_navigation_goal(x, y, theta)

            # Wait between goals (in a real implementation, this would be more sophisticated)
            time.sleep(2)
```

## Communication Pattern Selection

### When to Use Each Pattern

Understanding when to use topics, services, or actions is crucial for proper ROS 2 design:

```python
"""
Communication Pattern Selection Guide:

TOPICS (Publish/Subscribe):
- Use for: Continuous data streams, sensor data, status updates
- Characteristics: Asynchronous, many-to-many, fire-and-forget
- Examples:
  - Sensor readings (camera, LIDAR, IMU)
  - Robot state (position, velocity, battery)
  - Status information (health, diagnostics)

SERVICES (Request/Response):
- Use for: One-time computations, immediate responses
- Characteristics: Synchronous, one-to-one, blocking
- Examples:
  - Transform lookup (tf2)
  - Map queries
  - Configuration changes
  - Simple calculations

ACTIONS (Goal-Based):
- Use for: Long-running tasks with feedback
- Characteristics: Asynchronous, with progress tracking and cancellation
- Examples:
  - Navigation to goal
  - Object manipulation
  - Data processing tasks
  - Calibration procedures
"""

class CommunicationPatternSelector:
    @staticmethod
    def select_pattern(data_type, duration, feedback_needed, criticality):
        """
        Select the appropriate communication pattern based on requirements.

        Args:
            data_type: Type of data (sensor, command, status, etc.)
            duration: Expected duration (instant, short, long)
            feedback_needed: Whether feedback is required (bool)
            criticality: How critical the communication is (low, medium, high)
        """
        if duration == 'continuous':
            return 'topic'
        elif duration == 'instant' and not feedback_needed:
            return 'service'
        elif duration == 'long' and feedback_needed:
            return 'action'
        elif duration == 'short' and not feedback_needed:
            return 'service'
        else:
            return 'topic'  # Default to topic for continuous monitoring

    @staticmethod
    def get_qos_recommendations(pattern, data_type, criticality):
        """Get recommended QoS settings for different patterns."""
        from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

        if pattern == 'topic':
            if data_type in ['critical_sensor', 'command', 'emergency']:
                return QoSProfile(
                    reliability=ReliabilityPolicy.RELIABLE,
                    history=HistoryPolicy.KEEP_LAST,
                    depth=10
                )
            elif data_type in ['high_frequency', 'diagnostic', 'status']:
                return QoSProfile(
                    reliability=ReliabilityPolicy.BEST_EFFORT,
                    history=HistoryPolicy.KEEP_LAST,
                    depth=1
                )
        elif pattern == 'service':
            return QoSProfile(
                reliability=ReliabilityPolicy.RELIABLE,
                history=HistoryPolicy.KEEP_LAST,
                depth=10
            )
        elif pattern == 'action':
            return QoSProfile(
                reliability=ReliabilityPolicy.RELIABLE,
                history=HistoryPolicy.KEEP_ALL,
                depth=1
            )
```

## Integration Examples

### Multi-Pattern Robot Controller

Here's a comprehensive example that demonstrates services and actions working together:

```python
from rclpy.qos import QoSProfile, qos_profile_sensor_data
from std_msgs.msg import String, Float64
from example_interfaces.srv import SetBool
from example_interfaces.action import Fibonacci
from rclpy.action import ActionClient
import threading

class IntegratedRobotController(Node):
    def __init__(self):
        super().__init__('integrated_robot_controller')

        # SERVICE: Servers for immediate commands
        self.emergency_service = self.create_service(
            SetBool, 'emergency_stop', self.emergency_stop_callback
        )

        # SERVICE: Clients for external services
        self.navigation_client = self.create_client(
            SetBool, 'navigation_service'
        )

        # ACTION: Action client for long-running tasks
        self.movement_action_client = ActionClient(
            self, Fibonacci, 'movement_sequence'
        )

        # Robot state
        self.current_position = 0.0
        self.is_emergency_stopped = False
        self.is_moving = False

    def emergency_stop_callback(self, request, response):
        """Handle emergency stop via service."""
        if request.data:
            self.emergency_stop()
            response.success = True
            response.message = 'Emergency stop activated'
        else:
            self.emergency_stop_release()
            response.success = True
            response.message = 'Emergency stop released'

        return response

    def emergency_stop(self):
        """Emergency stop the robot."""
        self.is_emergency_stopped = True
        self.is_moving = False
        self.get_logger().warn('EMERGENCY STOP ACTIVATED')

    def emergency_stop_release(self):
        """Release emergency stop."""
        self.is_emergency_stopped = False
        self.get_logger().info('Emergency stop released')
```

## Performance Optimization and Best Practices

### Service Optimization

```python
class OptimizedServiceNode(Node):
    def __init__(self):
        super().__init__('optimized_service')

        # Optimized service with thread pool
        self.optimized_service = self.create_service(
            AddTwoInts, 'optimized_calc', self.optimized_calc_callback
        )

        # Thread pool for handling requests
        self.thread_pool = ThreadPoolExecutor(max_workers=4)

    def optimized_calc_callback(self, request, response):
        """Handle service request with thread pool."""
        try:
            # Perform calculation using thread pool if needed
            result = self.perform_calculation(request.a, request.b)
            response.sum = result
            response.success = True
            response.message = f'Calculated: {result}'
        except Exception as e:
            response.success = False
            response.message = str(e)

        return response

    def perform_calculation(self, a, b):
        """Perform the actual calculation."""
        # Implement calculation logic
        return a + b
```

## Chapter Summary

This section covered the comprehensive implementation of services and actions in ROS 2:

1. **Services**: Synchronous request/response communication for immediate computations
2. **Actions**: Goal-oriented communication with feedback and cancellation for long-running tasks
3. **Pattern Selection**: When to use topics, services, or actions based on application requirements
4. **Advanced Features**: Service chaining, load balancing, and complex state management
5. **Integration**: How services and actions work together in comprehensive robotic systems

Services and actions complement topics by providing synchronous communication for immediate responses and goal-oriented communication for complex, long-running operations with feedback and cancellation capabilities.