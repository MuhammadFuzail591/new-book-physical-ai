---
title: Chapter 11 - Navigation Systems for Physical AI
---

# Navigation Systems in Physical AI

## Chapter Overview

Navigation is a fundamental capability for mobile robots operating in physical environments. This section explores the principles and implementation of navigation systems that enable robots to autonomously plan and execute paths from start to goal positions while avoiding obstacles and respecting environmental constraints. We'll cover both global path planning and local motion control, with emphasis on integration with ROS 2 navigation stack and real-time performance considerations.

## Learning Outcomes

By the end of this section, you will be able to:
1. Implement global path planning algorithms like A*, Dijkstra, and RRT
2. Design local motion control systems for obstacle avoidance
3. Integrate navigation with SLAM for simultaneous localization and mapping
4. Configure and tune ROS 2 Navigation 2 (Nav2) for different robot platforms
5. Evaluate navigation performance in various environmental conditions
6. Handle dynamic obstacles and replanning scenarios
7. Optimize navigation systems for computational efficiency and safety

## 1. Fundamentals of Robot Navigation

### 1.1 Navigation Architecture

Robot navigation typically follows a hierarchical architecture with three main components:

1. **Global Path Planning**: Computes an optimal path from start to goal based on a map
2. **Local Path Planning**: Generates short-term trajectories that avoid obstacles while following the global path
3. **Motion Control**: Translates planned trajectories into actual robot actuator commands

### 1.2 Coordinate Systems and Transformations

Navigation systems rely on proper coordinate frame management to transform between different reference frames:

```python
import numpy as np
from scipy.spatial.transform import Rotation as R

class CoordinateTransform:
    def __init__(self):
        self.transforms = {}  # Store transformation matrices between frames

    def add_transform(self, from_frame, to_frame, translation, rotation_quat):
        """
        Add a transformation between two coordinate frames
        """
        # Create transformation matrix
        R_mat = R.from_quat(rotation_quat).as_matrix()
        T = np.eye(4)
        T[:3, :3] = R_mat
        T[:3, 3] = translation

        self.transforms[(from_frame, to_frame)] = T
        # Also store inverse transform
        self.transforms[(to_frame, from_frame)] = np.linalg.inv(T)

    def transform_point(self, point, from_frame, to_frame):
        """
        Transform a point from one frame to another
        """
        if (from_frame, to_frame) in self.transforms:
            T = self.transforms[(from_frame, to_frame)]
            point_h = np.append(point, 1)  # Homogeneous coordinates
            transformed = T @ point_h
            return transformed[:3]  # Return 3D coordinates
        else:
            raise ValueError(f"No transform found from {from_frame} to {to_frame}")

# Example usage for robot navigation
nav_transform = CoordinateTransform()
# Add transform from robot base to map frame
nav_transform.add_transform("base_link", "map", [1.0, 2.0, 0.0], [0, 0, 0, 1])
```

## 2. Global Path Planning

### 2.1 Grid-Based Path Planning

Grid-based approaches discretize the environment into a 2D or 3D grid where each cell represents free space or obstacles.

#### A* Algorithm

A* is a popular pathfinding algorithm that uses a heuristic to guide search toward the goal efficiently:

```python
import heapq
import numpy as np
from typing import List, Tuple

class AStarPlanner:
    def __init__(self, grid_map: np.ndarray, resolution: float = 1.0):
        """
        Initialize A* planner with a grid map
        grid_map: 2D array where 0 = free space, 1 = obstacle
        resolution: Size of each grid cell in meters
        """
        self.grid = grid_map
        self.resolution = resolution
        self.height, self.width = grid_map.shape

    def heuristic(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:
        """
        Calculate heuristic distance between two positions (Manhattan distance)
        """
        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

    def get_neighbors(self, pos: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Get valid neighboring positions
        """
        neighbors = []
        for dx, dy in [(-1,0), (1,0), (0,-1), (0,1), (-1,-1), (-1,1), (1,-1), (1,1)]:
            new_x, new_y = pos[0] + dx, pos[1] + dy

            # Check bounds
            if 0 <= new_x < self.height and 0 <= new_y < self.width:
                # Check if cell is free
                if self.grid[new_x, new_y] == 0:
                    neighbors.append((new_x, new_y))

        return neighbors

    def plan(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Plan a path from start to goal using A* algorithm
        """
        # Priority queue: (f_score, g_score, position)
        open_set = [(0, 0, start)]
        heapq.heapify(open_set)

        # Track costs
        g_score = {start: 0}
        f_score = {start: self.heuristic(start, goal)}

        # Track path
        came_from = {}

        while open_set:
            current_f, current_g, current = heapq.heappop(open_set)

            # Check if we reached the goal
            if current == goal:
                # Reconstruct path
                path = [current]
                while current in came_from:
                    current = came_from[current]
                    path.append(current)
                path.reverse()
                return path

            # Explore neighbors
            for neighbor in self.get_neighbors(current):
                # Calculate tentative g_score
                tentative_g = g_score[current] + self.distance(current, neighbor)

                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    # This path to neighbor is better than any previous one
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + self.heuristic(neighbor, goal)

                    # Add to open set if not already there
                    heapq.heappush(open_set, (f_score[neighbor], g_score[neighbor], neighbor))

        # No path found
        return []

    def distance(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:
        """
        Calculate distance between two adjacent positions
        """
        if pos1[0] == pos2[0] or pos1[1] == pos2[1]:
            # Adjacent horizontally or vertically
            return 1.0
        else:
            # Diagonal movement
            return np.sqrt(2)

# Example usage
def create_simple_map():
    """
    Create a simple 10x10 map with some obstacles
    """
    grid = np.zeros((10, 10))
    # Add some obstacles
    grid[3, 3:7] = 1  # Horizontal wall
    grid[5:8, 5] = 1  # Vertical wall
    return grid

# Plan a path
grid_map = create_simple_map()
planner = AStarPlanner(grid_map)
path = planner.plan((1, 1), (8, 8))
print(f"Path found: {path}")
```

#### Dijkstra's Algorithm

Dijkstra's algorithm finds the shortest path without using a heuristic, making it optimal but potentially slower:

```python
import heapq
import numpy as np
from typing import List, Tuple

class DijkstraPlanner:
    def __init__(self, grid_map: np.ndarray, resolution: float = 1.0):
        """
        Initialize Dijkstra planner with a grid map
        """
        self.grid = grid_map
        self.resolution = resolution
        self.height, self.width = grid_map.shape

    def get_neighbors(self, pos: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Get valid neighboring positions
        """
        neighbors = []
        for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
            new_x, new_y = pos[0] + dx, pos[1] + dy

            # Check bounds
            if 0 <= new_x < self.height and 0 <= new_y < self.width:
                # Check if cell is free
                if self.grid[new_x, new_y] == 0:
                    neighbors.append((new_x, new_y))

        return neighbors

    def plan(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Plan a path from start to goal using Dijkstra's algorithm
        """
        # Priority queue: (distance, position)
        pq = [(0, start)]
        heapq.heapify(pq)

        # Track distances and visited nodes
        distances = {start: 0}
        visited = set()
        came_from = {}

        while pq:
            current_dist, current = heapq.heappop(pq)

            if current in visited:
                continue

            visited.add(current)

            # Check if we reached the goal
            if current == goal:
                # Reconstruct path
                path = [current]
                while current in came_from:
                    current = came_from[current]
                    path.append(current)
                path.reverse()
                return path

            # Explore neighbors
            for neighbor in self.get_neighbors(current):
                if neighbor in visited:
                    continue

                # Calculate tentative distance
                tentative_dist = current_dist + 1  # Assuming unit cost for adjacent cells

                if neighbor not in distances or tentative_dist < distances[neighbor]:
                    distances[neighbor] = tentative_dist
                    came_from[neighbor] = current
                    heapq.heappush(pq, (tentative_dist, neighbor))

        # No path found
        return []
```

### 2.2 Sampling-Based Path Planning

Sampling-based methods like RRT (Rapidly-exploring Random Trees) are effective for high-dimensional spaces:

```python
import numpy as np
from typing import Tuple, List
import random

class RRTPlanner:
    def __init__(self, bounds: Tuple[float, float, float, float],
                 obstacles: List[Tuple[float, float, float]],
                 step_size: float = 0.5):
        """
        Initialize RRT planner
        bounds: (x_min, x_max, y_min, y_max)
        obstacles: List of (x, y, radius) tuples representing circular obstacles
        step_size: Maximum distance to extend tree at each step
        """
        self.bounds = bounds
        self.obstacles = obstacles
        self.step_size = step_size

        # Tree structure: {node: parent}
        self.tree = {}
        self.nodes = []  # List of (x, y) coordinates

    def is_collision_free(self, point: Tuple[float, float]) -> bool:
        """
        Check if a point is collision-free
        """
        x, y = point

        # Check bounds
        if not (self.bounds[0] <= x <= self.bounds[1] and
                self.bounds[2] <= y <= self.bounds[3]):
            return False

        # Check obstacles
        for obs_x, obs_y, radius in self.obstacles:
            distance = np.sqrt((x - obs_x)**2 + (y - obs_y)**2)
            if distance <= radius:
                return False

        return True

    def nearest_node(self, point: Tuple[float, float]) -> Tuple[float, float]:
        """
        Find the nearest node in the tree to the given point
        """
        if not self.nodes:
            return None

        min_dist = float('inf')
        nearest = None

        for node in self.nodes:
            dist = np.sqrt((point[0] - node[0])**2 + (point[1] - node[1])**2)
            if dist < min_dist:
                min_dist = dist
                nearest = node

        return nearest

    def extend_toward(self, from_node: Tuple[float, float],
                     to_point: Tuple[float, float]) -> Tuple[float, float]:
        """
        Extend the tree from from_node toward to_point
        """
        dx = to_point[0] - from_node[0]
        dy = to_point[1] - from_node[1]
        distance = np.sqrt(dx**2 + dy**2)

        if distance <= self.step_size:
            return to_point
        else:
            # Move step_size distance toward the target
            scale = self.step_size / distance
            new_x = from_node[0] + dx * scale
            new_y = from_node[1] + dy * scale
            return (new_x, new_y)

    def plan(self, start: Tuple[float, float], goal: Tuple[float, float],
             max_iterations: int = 1000) -> List[Tuple[float, float]]:
        """
        Plan a path from start to goal using RRT
        """
        # Initialize tree with start node
        self.tree[start] = None
        self.nodes = [start]

        for _ in range(max_iterations):
            # Sample random point (bias toward goal)
            if random.random() < 0.1:  # 10% chance to sample goal
                rand_point = goal
            else:
                rand_point = (
                    random.uniform(self.bounds[0], self.bounds[1]),
                    random.uniform(self.bounds[2], self.bounds[3])
                )

            # Find nearest node in tree
            nearest = self.nearest_node(rand_point)
            if nearest is None:
                continue

            # Extend toward random point
            new_point = self.extend_toward(nearest, rand_point)

            # Check if path is collision-free
            if self.is_collision_free(new_point):
                # Add to tree
                self.tree[new_point] = nearest
                self.nodes.append(new_point)

                # Check if we're close to goal
                dist_to_goal = np.sqrt((new_point[0] - goal[0])**2 +
                                      (new_point[1] - goal[1])**2)
                if dist_to_goal < self.step_size:
                    # Reconstruct path to goal
                    path = [goal]
                    current = new_point
                    while current is not None:
                        path.append(current)
                        current = self.tree[current]
                    path.reverse()
                    return path

        # No path found
        return []
```

## 3. Local Path Planning and Obstacle Avoidance

### 3.1 Dynamic Window Approach (DWA)

The Dynamic Window Approach is a local planning method that considers robot dynamics and constraints:

```python
import numpy as np
from typing import Tuple, List

class DynamicWindowApproach:
    def __init__(self, robot_params: dict):
        """
        Initialize DWA with robot parameters
        robot_params: {
            'max_vel_x': maximum linear velocity,
            'min_vel_x': minimum linear velocity,
            'max_vel_theta': maximum angular velocity,
            'min_vel_theta': minimum angular velocity,
            'max_accel_x': maximum linear acceleration,
            'max_accel_theta': maximum angular acceleration,
            'dt': time step,
            'predict_time': prediction horizon,
            'to_goal_cost_gain': weight for goal cost,
            'speed_cost_gain': weight for speed cost,
            'obstacle_cost_gain': weight for obstacle cost
        }
        """
        self.params = robot_params

    def motion(self, x: np.ndarray, u: np.ndarray, dt: float) -> np.ndarray:
        """
        Motion model: update robot state based on control input
        x = [x, y, theta, vel_x, vel_theta]
        u = [vel_x, vel_theta]
        """
        x[0] += u[0] * np.cos(x[2]) * dt
        x[1] += u[0] * np.sin(x[2]) * dt
        x[2] += u[1] * dt
        x[3] = u[0]
        x[4] = u[1]
        return x

    def calc_dynamic_window(self, state: np.ndarray) -> np.ndarray:
        """
        Calculate dynamic window based on current state and constraints
        """
        # Dynamic window = [min_vel_x, max_vel_x, min_vel_theta, max_vel_theta]
        vs = np.array([
            self.params['min_vel_x'],
            self.params['max_vel_x'],
            -self.params['max_vel_theta'],
            self.params['max_vel_theta']
        ])

        # Velocity window based on acceleration limits
        vd = np.array([
            state[3] - self.params['max_accel_x'] * self.params['dt'],
            state[3] + self.params['max_accel_x'] * self.params['dt'],
            state[4] - self.params['max_accel_theta'] * self.params['dt'],
            state[4] + self.params['max_accel_theta'] * self.params['dt']
        ])

        # Take intersection of both windows
        dw = np.array([
            max(vs[0], vd[0]),
            min(vs[1], vd[1]),
            max(vs[2], vd[2]),
            min(vs[3], vd[3])
        ])

        return dw

    def calc_trajectory(self, state: np.ndarray, vel_x: float, vel_theta: float) -> np.ndarray:
        """
        Calculate trajectory for given velocities
        """
        x = state.copy()
        trajectory = np.array([x])

        time = 0
        while time <= self.params['predict_time']:
            x = self.motion(x, [vel_x, vel_theta], self.params['dt'])
            trajectory = np.vstack((trajectory, x))
            time += self.params['dt']

        return trajectory

    def calc_obstacle_cost(self, trajectory: np.ndarray, obstacles: np.ndarray) -> float:
        """
        Calculate cost due to obstacles
        """
        min_dist = float('inf')

        for i in range(len(trajectory)):
            for obs in obstacles:
                dist = np.sqrt((trajectory[i, 0] - obs[0])**2 +
                              (trajectory[i, 1] - obs[1])**2)
                if dist <= min_dist:
                    min_dist = dist

        # Cost is inverse of minimum distance (higher cost for closer obstacles)
        if min_dist == 0:
            return float('inf')
        return 1.0 / min_dist

    def calc_to_goal_cost(self, trajectory: np.ndarray, goal: np.ndarray) -> float:
        """
        Calculate cost to goal based on final position
        """
        dx = goal[0] - trajectory[-1, 0]
        dy = goal[1] - trajectory[-1, 1]
        error_angle = np.arctan2(dy, dx)
        cost_angle = error_angle - trajectory[-1, 2]
        cost = abs(np.arctan2(np.sin(cost_angle), np.cos(cost_angle)))
        return cost

    def dwa_control(self, state: np.ndarray, goal: np.ndarray,
                   obstacles: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        Dynamic Window Approach control
        """
        dw = self.calc_dynamic_window(state)

        min_cost = float('inf')
        best_u = np.array([0.0, 0.0])
        best_trajectory = np.array([state])

        # Evaluate all possible velocities in dynamic window
        v_vel_x = np.arange(dw[0], dw[1], 0.1)
        v_vel_theta = np.arange(dw[2], dw[3], 0.1)

        for vel_x in v_vel_x:
            for vel_theta in v_vel_theta:
                # Generate trajectory for this velocity
                trajectory = self.calc_trajectory(state, vel_x, vel_theta)

                # Calculate costs
                to_goal_cost = self.calc_to_goal_cost(trajectory, goal) * self.params['to_goal_cost_gain']
                speed_cost = (self.params['max_vel_x'] - trajectory[-1, 3]) * self.params['speed_cost_gain']
                ob_cost = self.calc_obstacle_cost(trajectory, obstacles) * self.params['obstacle_cost_gain']

                final_cost = to_goal_cost + speed_cost + ob_cost

                if min_cost >= final_cost:
                    min_cost = final_cost
                    best_u = [vel_x, vel_theta]
                    best_trajectory = trajectory

        return best_u, best_trajectory
```

### 3.2 Trajectory Rollout

Trajectory rollout evaluates multiple possible paths and selects the best one:

```python
import numpy as np
from typing import List, Tuple

class TrajectoryRollout:
    def __init__(self, robot_config: dict):
        self.config = robot_config
        self.dt = robot_config.get('dt', 0.1)
        self.horizon = robot_config.get('horizon', 2.0)
        self.steps = int(self.horizon / self.dt)

    def predict_motion(self, state: np.ndarray, cmd_vel: np.ndarray) -> np.ndarray:
        """
        Predict robot motion for a given command velocity
        state = [x, y, theta, vel_x, vel_y, vel_theta]
        cmd_vel = [vel_x, vel_theta]
        """
        next_state = state.copy()
        dt = self.dt

        # Update position based on current velocity
        next_state[0] += cmd_vel[0] * np.cos(state[2]) * dt
        next_state[1] += cmd_vel[0] * np.sin(state[2]) * dt
        next_state[2] += cmd_vel[1] * dt

        # Update velocities
        next_state[3] = cmd_vel[0]  # Linear x velocity
        next_state[5] = cmd_vel[1]  # Angular velocity

        return next_state

    def evaluate_trajectory(self, trajectory: List[np.ndarray],
                           goal: np.ndarray, obstacles: List[np.ndarray]) -> float:
        """
        Evaluate a trajectory based on multiple criteria
        """
        # Calculate trajectory length penalty
        length_penalty = 0
        for i in range(1, len(trajectory)):
            dx = trajectory[i][0] - trajectory[i-1][0]
            dy = trajectory[i][1] - trajectory[i-1][1]
            length_penalty += np.sqrt(dx**2 + dy**2)

        # Calculate distance to goal
        final_pos = trajectory[-1][:2]
        goal_dist = np.sqrt((final_pos[0] - goal[0])**2 + (final_pos[1] - goal[1])**2)

        # Calculate obstacle proximity cost
        obstacle_cost = 0
        for state in trajectory:
            for obs in obstacles:
                dist = np.sqrt((state[0] - obs[0])**2 + (state[1] - obs[1])**2)
                if dist < 1.0:  # Within 1m of obstacle
                    obstacle_cost += 1.0 / (dist + 0.01)  # Higher cost for closer obstacles

        # Calculate smoothness penalty
        smoothness_penalty = 0
        if len(trajectory) > 2:
            for i in range(1, len(trajectory) - 1):
                p1 = trajectory[i-1][:2]
                p2 = trajectory[i][:2]
                p3 = trajectory[i+1][:2]

                # Calculate curvature (simplified)
                v1 = p2 - p1
                v2 = p3 - p2
                dot_product = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2) + 1e-6)
                curvature = 1 - abs(dot_product)  # Higher for sharp turns
                smoothness_penalty += curvature

        # Weighted combination of costs
        total_cost = (1.0 * goal_dist +
                     0.1 * length_penalty +
                     5.0 * obstacle_cost +
                     0.5 * smoothness_penalty)

        return total_cost

    def generate_trajectories(self, state: np.ndarray) -> List[Tuple[List[np.ndarray], float]]:
        """
        Generate multiple possible trajectories
        """
        trajectories = []

        # Define possible velocity commands
        vel_x_options = np.linspace(0.0, self.config['max_vel_x'], 5)
        vel_theta_options = np.linspace(-self.config['max_vel_theta'],
                                       self.config['max_vel_theta'], 7)

        for vel_x in vel_x_options:
            for vel_theta in vel_theta_options:
                cmd_vel = np.array([vel_x, vel_theta])

                # Generate trajectory for this command
                trajectory = [state.copy()]
                current_state = state.copy()

                for _ in range(self.steps):
                    current_state = self.predict_motion(current_state, cmd_vel)
                    trajectory.append(current_state.copy())

                trajectories.append((trajectory, cmd_vel))

        return trajectories

    def select_best_trajectory(self, state: np.ndarray, goal: np.ndarray,
                              obstacles: List[np.ndarray]) -> np.ndarray:
        """
        Select the best trajectory based on evaluation
        """
        trajectories = self.generate_trajectories(state)

        best_cost = float('inf')
        best_cmd_vel = np.array([0.0, 0.0])

        for trajectory, cmd_vel in trajectories:
            cost = self.evaluate_trajectory(trajectory, goal, obstacles)

            if cost < best_cost:
                best_cost = cost
                best_cmd_vel = cmd_vel

        return best_cmd_vel
```

## 4. Integration with ROS 2 Navigation Stack

### 4.1 ROS 2 Navigation 2 (Nav2) Components

The ROS 2 Navigation 2 stack provides a complete navigation framework with plugins for different components:

```python
# Example ROS 2 Navigation node
import rclpy
from rclpy.node import Node
from nav2_msgs.action import NavigateToPose
from geometry_msgs.msg import PoseStamped
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import OccupancyGrid
import tf2_ros
from rclpy.action import ActionClient

class NavigationNode(Node):
    def __init__(self):
        super().__init__('navigation_node')

        # Action client for navigation
        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')

        # Subscribers
        self.scan_sub = self.create_subscription(
            LaserScan,
            '/scan',
            self.scan_callback,
            10
        )

        self.map_sub = self.create_subscription(
            OccupancyGrid,
            '/map',
            self.map_callback,
            10
        )

        # TF buffer for coordinate transforms
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)

        # Navigation parameters
        self.global_frame = 'map'
        self.robot_frame = 'base_link'

        # Wait for navigation server
        self.nav_client.wait_for_server()

    def navigate_to_pose(self, x: float, y: float, theta: float) -> None:
        """
        Navigate to a specific pose
        """
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = self.global_frame
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()

        goal_msg.pose.pose.position.x = x
        goal_msg.pose.pose.position.y = y
        goal_msg.pose.pose.position.z = 0.0

        # Convert theta to quaternion
        from math import sin, cos
        s = sin(theta / 2.0)
        c = cos(theta / 2.0)
        goal_msg.pose.pose.orientation.x = 0.0
        goal_msg.pose.pose.orientation.y = 0.0
        goal_msg.pose.pose.orientation.z = s
        goal_msg.pose.pose.orientation.w = c

        # Send navigation goal
        self.nav_client.send_goal_async(goal_msg)

    def scan_callback(self, msg: LaserScan) -> None:
        """
        Process laser scan data for obstacle detection
        """
        # Process scan data for local obstacle avoidance
        # This would typically be handled by the Nav2 local planner
        pass

    def map_callback(self, msg: OccupancyGrid) -> None:
        """
        Process map data for global planning
        """
        # Store map for global path planning
        # This would typically be handled by the Nav2 global planner
        pass

def main(args=None):
    rclpy.init(args=args)
    nav_node = NavigationNode()

    # Example: Navigate to position (5.0, 5.0) with orientation 0
    nav_node.navigate_to_pose(5.0, 5.0, 0.0)

    try:
        rclpy.spin(nav_node)
    except KeyboardInterrupt:
        pass
    finally:
        nav_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### 4.2 Custom Navigation Plugin

Creating a custom navigation plugin for specific requirements:

```python
# Custom local planner plugin
import numpy as np
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
from tf2_ros import TransformException
import tf2_geometry_msgs
import tf2_ros

class CustomLocalPlanner:
    def __init__(self):
        self.max_vel_x = 0.5  # m/s
        self.max_vel_theta = 1.0  # rad/s
        self.min_vel_x = 0.1
        self.safe_distance = 0.5  # meters
        self.obstacle_threshold = 0.3  # meters

        # Goal following parameters
        self.kp_linear = 1.0
        self.kp_angular = 2.0

        # Current state
        self.current_pose = None
        self.current_twist = None
        self.laser_data = None
        self.goal_pose = None

    def set_goal(self, goal_pose):
        """
        Set the navigation goal
        """
        self.goal_pose = goal_pose

    def update_laser_data(self, laser_msg):
        """
        Update laser scan data
        """
        self.laser_data = laser_msg

    def update_odometry(self, odom_msg):
        """
        Update robot odometry
        """
        self.current_pose = odom_msg.pose.pose
        self.current_twist = odom_msg.twist.twist

    def obstacle_in_direction(self, angle, laser_data):
        """
        Check for obstacles in a specific direction
        """
        if laser_data is None:
            return False

        # Calculate the index for the given angle
        angle_min = laser_data.angle_min
        angle_increment = laser_data.angle_increment
        index = int((angle - angle_min) / angle_increment)

        if 0 <= index < len(laser_data.ranges):
            range_val = laser_data.ranges[index]
            return range_val < self.obstacle_threshold

        return False

    def compute_velocity_commands(self):
        """
        Compute velocity commands based on current state and goal
        """
        if self.goal_pose is None or self.current_pose is None:
            return Twist()

        # Calculate error to goal
        dx = self.goal_pose.position.x - self.current_pose.position.x
        dy = self.goal_pose.position.y - self.current_pose.position.y
        distance_to_goal = np.sqrt(dx**2 + dy**2)

        # Calculate goal angle
        goal_angle = np.arctan2(dy, dx)

        # Get current robot angle from quaternion
        q = self.current_pose.orientation
        current_angle = np.arctan2(
            2.0 * (q.w * q.z + q.x * q.y),
            1.0 - 2.0 * (q.y * q.y + q.z * q.z)
        )

        # Calculate angle error
        angle_error = goal_angle - current_angle
        angle_error = np.arctan2(np.sin(angle_error), np.cos(angle_error))  # Normalize to [-pi, pi]

        cmd_vel = Twist()

        # Check for obstacles
        if self.laser_data is not None:
            # Check forward direction
            if self.obstacle_in_direction(0.0, self.laser_data):
                # Stop or slow down if obstacle ahead
                cmd_vel.linear.x = 0.0
                cmd_vel.angular.z = self.kp_angular * angle_error
                return cmd_vel

            # Check left and right for obstacles
            left_clear = not self.obstacle_in_direction(0.5, self.laser_data)
            right_clear = not self.obstacle_in_direction(-0.5, self.laser_data)

            # If path is blocked but not directly ahead, try to turn
            if not left_clear and not right_clear:
                cmd_vel.angular.z = self.kp_angular * 0.5  # Turn right
                return cmd_vel

        # Normal navigation behavior
        if distance_to_goal > 0.1:  # If not close to goal
            # Proportional control for linear velocity
            cmd_vel.linear.x = min(self.kp_linear * distance_to_goal, self.max_vel_x)

            # Proportional control for angular velocity
            cmd_vel.angular.z = self.kp_angular * angle_error
        else:
            # Close to goal, slow down
            cmd_vel.linear.x = 0.0
            cmd_vel.angular.z = 0.0

        # Apply velocity limits
        cmd_vel.linear.x = max(min(cmd_vel.linear.x, self.max_vel_x), 0.0)
        cmd_vel.angular.z = max(min(cmd_vel.angular.z, self.max_vel_theta), -self.max_vel_theta)

        return cmd_vel
```

## 5. Navigation Performance Evaluation

### 5.1 Metrics and Evaluation

Evaluating navigation performance requires several key metrics:

```python
import numpy as np
from typing import List, Tuple
import matplotlib.pyplot as plt

class NavigationEvaluator:
    def __init__(self):
        self.trajectory_history = []
        self.execution_times = []
        self.success_count = 0
        self.total_attempts = 0

    def add_trajectory(self, trajectory: List[Tuple[float, float]],
                      execution_time: float, success: bool):
        """
        Add a completed navigation trajectory for evaluation
        """
        self.trajectory_history.append(trajectory)
        self.execution_times.append(execution_time)
        self.total_attempts += 1
        if success:
            self.success_count += 1

    def calculate_path_efficiency(self, planned_path: List[Tuple[float, float]],
                                 executed_path: List[Tuple[float, float]]) -> float:
        """
        Calculate path efficiency as ratio of optimal path length to actual path length
        """
        if len(planned_path) < 2 or len(executed_path) < 2:
            return 0.0

        # Calculate planned path length
        planned_length = 0
        for i in range(1, len(planned_path)):
            dx = planned_path[i][0] - planned_path[i-1][0]
            dy = planned_path[i][1] - planned_path[i-1][1]
            planned_length += np.sqrt(dx**2 + dy**2)

        # Calculate executed path length
        executed_length = 0
        for i in range(1, len(executed_path)):
            dx = executed_path[i][0] - executed_path[i-1][0]
            dy = executed_path[i][1] - executed_path[i-1][1]
            executed_length += np.sqrt(dx**2 + dy**2)

        if planned_length == 0:
            return 0.0

        return planned_length / executed_length if executed_length > 0 else 0.0

    def calculate_smoothness(self, path: List[Tuple[float, float]]) -> float:
        """
        Calculate path smoothness based on curvature
        """
        if len(path) < 3:
            return 1.0  # Perfectly smooth for short paths

        total_curvature = 0.0
        segments = 0

        for i in range(1, len(path) - 1):
            p1 = np.array(path[i-1])
            p2 = np.array(path[i])
            p3 = np.array(path[i+1])

            # Calculate vectors
            v1 = p2 - p1
            v2 = p3 - p2

            # Calculate angle between segments
            cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2) + 1e-6)
            angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))

            # Curvature is proportional to change in direction
            total_curvature += abs(np.pi - angle)
            segments += 1

        if segments == 0:
            return 1.0

        # Convert to smoothness (inverse of curvature)
        avg_curvature = total_curvature / segments
        smoothness = 1.0 / (1.0 + avg_curvature)  # Higher is better

        return smoothness

    def evaluate_navigation_performance(self) -> dict:
        """
        Evaluate overall navigation performance
        """
        if self.total_attempts == 0:
            return {}

        results = {}

        # Success rate
        results['success_rate'] = self.success_count / self.total_attempts

        # Average execution time
        if self.execution_times:
            results['avg_execution_time'] = np.mean(self.execution_times)
            results['std_execution_time'] = np.std(self.execution_times)

        # Path efficiency (if we have trajectory data)
        if self.trajectory_history:
            efficiencies = []
            smoothnesses = []

            for traj in self.trajectory_history:
                if len(traj) > 1:
                    # For evaluation, we'd need both planned and executed paths
                    # Here we'll just evaluate the smoothness of the executed path
                    smoothness = self.calculate_smoothness(traj)
                    smoothnesses.append(smoothness)

            if smoothnesses:
                results['avg_smoothness'] = np.mean(smoothnesses)
                results['std_smoothness'] = np.std(smoothnesses)

        return results

    def plot_performance(self):
        """
        Plot navigation performance metrics
        """
        if not self.execution_times:
            print("No execution time data to plot")
            return

        fig, axes = plt.subplots(2, 2, figsize=(12, 10))

        # Execution time histogram
        axes[0, 0].hist(self.execution_times, bins=20)
        axes[0, 0].set_title('Execution Time Distribution')
        axes[0, 0].set_xlabel('Time (s)')
        axes[0, 0].set_ylabel('Frequency')

        # Success rate
        axes[0, 1].bar(['Success', 'Failure'],
                      [self.success_count, self.total_attempts - self.success_count])
        axes[0, 1].set_title(f'Success Rate: {self.success_count/self.total_attempts:.2%}')
        axes[0, 1].set_ylabel('Count')

        # Trajectory examples (if available)
        if self.trajectory_history and len(self.trajectory_history) > 0:
            for i, traj in enumerate(self.trajectory_history[:3]):  # Show first 3 trajectories
                if len(traj) > 1:
                    x_coords = [point[0] for point in traj]
                    y_coords = [point[1] for point in traj]
                    axes[1, 0].plot(x_coords, y_coords, label=f'Trajectory {i+1}', alpha=0.7)

            axes[1, 0].set_title('Navigation Trajectories')
            axes[1, 0].set_xlabel('X (m)')
            axes[1, 0].set_ylabel('Y (m)')
            axes[1, 0].legend()
            axes[1, 0].grid(True)

        # Success rate over time (if we had time-ordered data)
        cumulative_success = []
        for i in range(1, len(self.execution_times) + 1):
            subset_success = sum(1 for j in range(i)
                               if j < self.success_count) / i if i <= self.success_count else self.success_count / i
            cumulative_success.append(subset_success)

        if cumulative_success:
            axes[1, 1].plot(range(1, len(cumulative_success) + 1), cumulative_success)
            axes[1, 1].set_title('Cumulative Success Rate')
            axes[1, 1].set_xlabel('Attempt Number')
            axes[1, 1].set_ylabel('Success Rate')
            axes[1, 1].grid(True)

        plt.tight_layout()
        plt.show()
```

## 6. Advanced Navigation Topics

### 6.1 Multi-Robot Navigation

Coordinating navigation for multiple robots requires additional considerations for collision avoidance:

```python
import numpy as np
from typing import Dict, List, Tuple
from dataclasses import dataclass

@dataclass
class RobotState:
    position: Tuple[float, float]
    velocity: Tuple[float, float]
    radius: float
    id: int

class MultiRobotNavigator:
    def __init__(self, safety_margin: float = 0.5):
        self.safety_margin = safety_margin
        self.robots: Dict[int, RobotState] = {}
        self.prediction_horizon = 2.0  # seconds
        self.time_step = 0.1  # seconds

    def add_robot(self, robot_id: int, position: Tuple[float, float],
                  velocity: Tuple[float, float], radius: float = 0.3):
        """
        Add a robot to the navigation system
        """
        self.robots[robot_id] = RobotState(position, velocity, radius, robot_id)

    def update_robot_state(self, robot_id: int, position: Tuple[float, float],
                          velocity: Tuple[float, float]):
        """
        Update a robot's state
        """
        if robot_id in self.robots:
            self.robots[robot_id].position = position
            self.robots[robot_id].velocity = velocity

    def predict_collision(self, robot1: RobotState, robot2: RobotState) -> bool:
        """
        Predict if two robots will collide based on their current velocities
        """
        # Simple collision prediction using constant velocity model
        pos1 = np.array(robot1.position)
        vel1 = np.array(robot1.velocity)
        pos2 = np.array(robot2.position)
        vel2 = np.array(robot2.velocity)

        # Relative position and velocity
        rel_pos = pos2 - pos1
        rel_vel = vel2 - vel1

        # Minimum distance between trajectories
        # This is a simplified approach - full implementation would be more complex
        min_distance = np.linalg.norm(rel_pos)

        # If robots are already too close, consider it a collision risk
        combined_radius = robot1.radius + robot2.radius + self.safety_margin
        return min_distance < combined_radius

    def compute_velocity_obstacles(self, robot_id: int, other_robot_id: int) -> List[Tuple[float, float]]:
        """
        Compute velocity obstacles for collision avoidance
        """
        robot = self.robots[robot_id]
        other = self.robots[other_robot_id]

        # Vector from other robot to this robot
        rel_pos = np.array(robot.position) - np.array(other.position)
        distance = np.linalg.norm(rel_pos)

        if distance == 0:
            return []  # Same position, avoid all velocities

        # Unit vector pointing from other to this
        rel_dir = rel_pos / distance

        # Combined radius with safety margin
        combined_radius = robot.radius + other.radius + self.safety_margin

        # Velocity obstacle is a cone around the "collision velocity"
        collision_velocity = np.array(other.velocity) + rel_dir * (combined_radius / self.prediction_horizon)

        # Return a simple velocity obstacle region
        obstacle_cone = []
        for angle_offset in np.linspace(-0.5, 0.5, 5):
            rotated_dir = np.array([
                rel_dir[0] * np.cos(angle_offset) - rel_dir[1] * np.sin(angle_offset),
                rel_dir[0] * np.sin(angle_offset) + rel_dir[1] * np.cos(angle_offset)
            ])
            obstacle_cone.append(tuple(collision_velocity + rotated_dir * 0.2))

        return obstacle_cone

    def avoid_collisions(self, robot_id: int, desired_velocity: Tuple[float, float]) -> Tuple[float, float]:
        """
        Adjust desired velocity to avoid collisions with other robots
        """
        if robot_id not in self.robots:
            return desired_velocity

        robot = self.robots[robot_id]

        # Check against all other robots
        for other_id, other_robot in self.robots.items():
            if other_id == robot_id:
                continue

            # Compute velocity obstacles
            vo = self.compute_velocity_obstacles(robot_id, other_id)

            # If desired velocity is in velocity obstacle, adjust it
            desired_vec = np.array(desired_velocity)
            for vo_point in vo:
                vo_vec = np.array(vo_point)
                # Simple adjustment: move away from the velocity obstacle
                if np.linalg.norm(desired_vec - vo_vec) < 0.2:  # If too close to obstacle
                    avoidance_vec = desired_vec - vo_vec
                    avoidance_vec = avoidance_vec / (np.linalg.norm(avoidance_vec) + 1e-6)
                    desired_velocity = tuple(desired_vec + avoidance_vec * 0.1)
                    desired_velocity = (np.clip(desired_velocity[0], -1.0, 1.0),
                                      np.clip(desired_velocity[1], -1.0, 1.0))

        return desired_velocity
```

### 6.2 Navigation in Dynamic Environments

Handling moving obstacles and changing environments:

```python
import numpy as np
from typing import List, Tuple
from dataclasses import dataclass
import time

@dataclass
class DynamicObstacle:
    id: int
    position: Tuple[float, float]
    velocity: Tuple[float, float]
    radius: float
    last_seen: float

class DynamicEnvironmentNavigator:
    def __init__(self):
        self.dynamic_obstacles: Dict[int, DynamicObstacle] = {}
        self.obstacle_timeout = 2.0  # seconds before removing unseen obstacles
        self.prediction_horizon = 1.0  # seconds to predict obstacle positions

    def update_dynamic_obstacle(self, obs_id: int, position: Tuple[float, float],
                               velocity: Tuple[float, float], radius: float = 0.5):
        """
        Update or add a dynamic obstacle
        """
        current_time = time.time()
        self.dynamic_obstacles[obs_id] = DynamicObstacle(
            obs_id, position, velocity, radius, current_time
        )

    def remove_expired_obstacles(self):
        """
        Remove obstacles that haven't been seen recently
        """
        current_time = time.time()
        expired_ids = []

        for obs_id, obstacle in self.dynamic_obstacles.items():
            if current_time - obstacle.last_seen > self.obstacle_timeout:
                expired_ids.append(obs_id)

        for obs_id in expired_ids:
            del self.dynamic_obstacles[obs_id]

    def predict_obstacle_positions(self, time_ahead: float) -> List[Tuple[float, float, float]]:
        """
        Predict positions of all dynamic obstacles at a future time
        Returns list of (x, y, radius) tuples
        """
        predicted_positions = []
        current_time = time.time()

        for obstacle in self.dynamic_obstacles.values():
            # Predict position based on current velocity
            dt = time_ahead
            pred_x = obstacle.position[0] + obstacle.velocity[0] * dt
            pred_y = obstacle.position[1] + obstacle.velocity[1] * dt
            predicted_positions.append((pred_x, pred_y, obstacle.radius))

        return predicted_positions

    def check_dynamic_collision(self, path: List[Tuple[float, float]],
                               time_steps: List[float]) -> Tuple[bool, float]:
        """
        Check if a path collides with any predicted dynamic obstacles
        Returns (collision_detected, time_of_collision)
        """
        for i, (path_point, t) in enumerate(zip(path, time_steps)):
            predicted_obstacles = self.predict_obstacle_positions(t)

            for obs_x, obs_y, obs_radius in predicted_obstacles:
                distance = np.sqrt((path_point[0] - obs_x)**2 + (path_point[1] - obs_y)**2)
                if distance <= obs_radius:
                    return True, t

        return False, 0.0

    def replan_if_needed(self, current_position: Tuple[float, float],
                        goal: Tuple[float, float], robot_radius: float = 0.3) -> bool:
        """
        Determine if replanning is needed due to dynamic obstacles
        """
        # Predict obstacle positions in the near future
        near_future_obstacles = self.predict_obstacle_positions(0.5)  # 0.5 seconds ahead

        # Check if any obstacles are on our path or getting close
        for obs_x, obs_y, obs_radius in near_future_obstacles:
            distance = np.sqrt((current_position[0] - obs_x)**2 +
                              (current_position[1] - obs_y)**2)
            combined_radius = robot_radius + obs_radius + 0.5  # Safety margin

            if distance < combined_radius:
                return True  # Replan needed

        return False
```

## 7. Implementation Best Practices

### 7.1 Safety Considerations

Navigation systems must prioritize safety above all other considerations:

- Always maintain safety margins around obstacles
- Implement emergency stop mechanisms
- Use conservative velocity profiles near obstacles
- Validate all paths before execution

### 7.2 Performance Optimization

- Use appropriate data structures for fast nearest neighbor searches
- Implement efficient collision detection algorithms
- Use hierarchical planning to reduce computational load
- Cache frequently computed values

### 7.3 Robustness

- Handle sensor failures gracefully
- Implement fallback behaviors
- Monitor system health continuously
- Validate all inputs and outputs

## 8. Chapter Summary

This section has covered the fundamental concepts and implementation techniques for navigation systems in Physical AI applications. We've explored global path planning algorithms like A* and RRT, local path planning methods like DWA, and integration with ROS 2 Navigation 2 stack. We've also discussed performance evaluation, multi-robot navigation, and dynamic environment handling.

The next section will explore sim-to-real transfer techniques that enable navigation systems developed in simulation to work effectively in real-world environments.

## Exercises

1. **Implementation Exercise**: Implement a complete navigation system that combines A* global planning with DWA local planning. Test it on a simulated environment with various obstacle configurations.

2. **Analysis Exercise**: Compare the performance of different path planning algorithms (A*, Dijkstra, RRT) in terms of computation time, path optimality, and success rate in different environments.

3. **Integration Exercise**: Create a ROS 2 package that integrates your custom local planner with the Navigation 2 stack.

4. **Optimization Exercise**: Implement a dynamic window approach planner with obstacle prediction for moving obstacles.
