---
title: SDF for Simulation - Advanced Physics and Sensor Modeling
---

# SDF for Simulation: Advanced Physics and Sensor Modeling

## Introduction to Simulation Description Format (SDF)

The Simulation Description Format (SDF) is the native format used by Gazebo for describing robots, sensors, and environments in simulation. While URDF is primarily used for ROS applications and kinematic descriptions, SDF is specifically designed for physics simulation with detailed properties for realistic physics, sensors, and environments. Understanding SDF is crucial for creating accurate and realistic simulation environments for Physical AI applications.

### SDF vs URDF: When to Use Each

While URDF and SDF serve similar purposes, they have different strengths and use cases:

- **URDF**: Best for robot model description in ROS applications, kinematic chain definition, and TF tree generation
- **SDF**: Best for detailed physics simulation, sensor simulation with realistic noise models, and environment description

For humanoid robotics simulation, you'll often convert URDF models to SDF for use in Gazebo, or create SDF models directly for simulation-specific scenarios.

## SDF File Structure

An SDF file is an XML document that typically follows this structure:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <model name="humanoid_robot">
    <!-- Links -->
    <link name="base_link">
      <!-- Inertial properties -->
      <inertial>
        <mass>10.0</mass>
        <inertia>
          <ixx>1.0</ixx>
          <ixy>0.0</ixy>
          <ixz>0.0</ixz>
          <iyy>1.0</iyy>
          <iyz>0.0</iyz>
          <izz>1.0</izz>
        </inertia>
      </inertial>

      <!-- Visual properties -->
      <visual name="visual">
        <geometry>
          <box>
            <size>0.5 0.5 1.0</size>
          </box>
        </geometry>
        <material>
          <ambient>0 0 1 1</ambient>
          <diffuse>0 0 1 1</diffuse>
          <specular>0 0 1 1</specular>
        </material>
      </visual>

      <!-- Collision properties -->
      <collision name="collision">
        <geometry>
          <box>
            <size>0.5 0.5 1.0</size>
          </box>
        </geometry>
      </collision>

      <!-- Physics properties -->
      <physics>
        <ode>
          <mu>1.0</mu>
          <mu2>1.0</mu2>
          <fdir1>0 0 1</fdir1>
          <slip1>0.0</slip1>
          <slip2>0.0</slip2>
          <kp>100000000.0</kp>
          <kd>1.0</kd>
        </ode>
      </physics>
    </link>

    <!-- Joints -->
    <joint name="base_to_torso" type="fixed">
      <parent>base_link</parent>
      <child>torso</child>
      <pose>0 0 1.0 0 0 0</pose>
    </joint>

    <!-- Sensors -->
    <link name="sensor_link">
      <sensor name="imu_sensor" type="imu">
        <always_on>1</always_on>
        <update_rate>100</update_rate>
        <pose>0 0 0 0 0 0</pose>
        <imu>
          <angular_velocity>
            <x>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>2e-4</stddev>
              </noise>
            </x>
            <y>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>2e-4</stddev>
              </noise>
            </y>
            <z>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>2e-4</stddev>
              </noise>
            </z>
          </angular_velocity>
          <linear_acceleration>
            <x>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>1.7e-2</stddev>
              </noise>
            </x>
            <y>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>1.7e-2</stddev>
              </noise>
            </y>
            <z>
              <noise type="gaussian">
                <mean>0.0</mean>
                <stddev>1.7e-2</stddev>
              </noise>
            </z>
          </linear_acceleration>
        </imu>
      </sensor>
    </link>

    <!-- Plugins -->
    <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
      <robotNamespace>/humanoid_robot</robotNamespace>
    </plugin>
  </model>
</sdf>
```

## Advanced Physics Properties in SDF

SDF allows for detailed physics configuration that is essential for realistic humanoid robot simulation. These properties control how objects interact with the physics engine.

### Surface Properties

Surface properties define how objects interact when they come into contact:

```xml
<collision name="collision">
  <geometry>
    <box>
      <size>0.5 0.5 1.0</size>
    </box>
  </geometry>
  <surface>
    <friction>
      <ode>
        <mu>1.0</mu>
        <mu2>1.0</mu2>
        <fdir1>0 0 1</fdir1>
        <slip1>0.0</slip1>
        <slip2>0.0</slip2>
      </ode>
      <torsional>
        <coefficient>1.0</coefficient>
        <use_patch_radius>1</use_patch_radius>
        <surface_radius>0.01</surface_radius>
      </torsional>
    </friction>
    <bounce>
      <restitution_coefficient>0.01</restitution_coefficient>
      <threshold>100000</threshold>
    </bounce>
    <contact>
      <ode>
        <soft_cfm>0</soft_cfm>
        <soft_erp>0.2</soft_erp>
        <kp>1e+13</kp>
        <kd>1</kd>
        <max_vel>100.0</max_vel>
        <min_depth>0.001</min_depth>
      </ode>
    </contact>
  </surface>
</collision>
```

- **friction**: Defines how objects resist sliding against each other
- **bounce**: Controls how bouncy the surface is
- **contact**: Defines how contact forces are computed

### Joint Physics

Joints in SDF can have detailed physics properties that affect how they behave in simulation:

```xml
<joint name="knee_joint" type="revolute">
  <parent>thigh</parent>
  <child>shin</child>
  <pose>0 0 -0.4 0 0 0</pose>
  <axis>
    <xyz>0 1 0</xyz>
    <limit>
      <lower>-0.5</lower>
      <upper>2.0</upper>
      <effort>200</effort>
      <velocity>1.0</velocity>
    </limit>
    <dynamics>
      <damping>1.0</damping>
      <friction>0.5</friction>
      <spring_reference>0</spring_reference>
      <spring_stiffness>0</spring_stiffness>
    </dynamics>
  </axis>
  <physics>
    <ode>
      <limit>
        <cfm>0.0</cfm>
        <erp>0.2</erp>
      </limit>
      <suspension>
        <cfm>0.0</cfm>
        <erp>0.2</erp>
      </suspension>
    </ode>
  </physics>
</joint>
```

## Sensor Integration in SDF

SDF provides comprehensive support for various sensor types with realistic noise models and properties, which is essential for Physical AI applications where sensor data quality affects intelligence.

### IMU Sensors

IMU sensors are crucial for humanoid robot balance and orientation:

```xml
<sensor name="imu_sensor" type="imu">
  <always_on>1</always_on>
  <update_rate>100</update_rate>
  <pose>0 0 0 0 0 0</pose>
  <topic>imu/data</topic>
  <imu>
    <angular_velocity>
      <x>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>2e-4</stddev>
          <bias_mean>0.0000075</bias_mean>
          <bias_stddev>0.0000008</bias_stddev>
        </noise>
      </x>
      <y>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>2e-4</stddev>
          <bias_mean>0.0000075</bias_mean>
          <bias_stddev>0.0000008</bias_stddev>
        </noise>
      </y>
      <z>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>2e-4</stddev>
          <bias_mean>0.0000075</bias_mean>
          <bias_stddev>0.0000008</bias_stddev>
        </noise>
      </z>
    </angular_velocity>
    <linear_acceleration>
      <x>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>1.7e-2</stddev>
          <bias_mean>0.017</bias_mean>
          <bias_stddev>0.0017</bias_stddev>
        </noise>
      </x>
      <y>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>1.7e-2</stddev>
          <bias_mean>0.017</bias_mean>
          <bias_stddev>0.0017</bias_stddev>
        </noise>
      </y>
      <z>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>1.7e-2</stddev>
          <bias_mean>0.017</bias_mean>
          <bias_stddev>0.0017</bias_stddev>
        </noise>
      </z>
    </linear_acceleration>
  </imu>
</sensor>
```

### Camera Sensors

Camera sensors are essential for vision-based Physical AI:

```xml
<sensor name="camera" type="camera">
  <always_on>1</always_on>
  <update_rate>30</update_rate>
  <pose>0.1 0 0.1 0 0 0</pose>
  <camera>
    <horizontal_fov>1.047</horizontal_fov>
    <image>
      <width>640</width>
      <height>480</height>
      <format>R8G8B8</format>
    </image>
    <clip>
      <near>0.1</near>
      <far>100</far>
    </clip>
    <noise>
      <type>gaussian</type>
      <mean>0.0</mean>
      <stddev>0.007</stddev>
    </noise>
  </camera>
  <plugin name="camera_controller" filename="libgazebo_ros_camera.so">
    <frame_name>camera_link</frame_name>
    <topic_name>camera/image_raw</topic_name>
  </plugin>
</sensor>
```

### LIDAR Sensors

LIDAR sensors are important for navigation and environment perception:

```xml
<sensor name="laser" type="ray">
  <always_on>1</always_on>
  <update_rate>40</update_rate>
  <pose>0.1 0 0.1 0 0 0</pose>
  <ray>
    <scan>
      <horizontal>
        <samples>720</samples>
        <resolution>1</resolution>
        <min_angle>-1.570796</min_angle>
        <max_angle>1.570796</max_angle>
      </horizontal>
    </scan>
    <range>
      <min>0.1</min>
      <max>30.0</max>
      <resolution>0.01</resolution>
    </range>
    <noise>
      <type>gaussian</type>
      <mean>0.0</mean>
      <stddev>0.01</stddev>
    </noise>
  </ray>
  <plugin name="laser_controller" filename="libgazebo_ros_laser.so">
    <topicName>scan</topicName>
    <frameName>laser_link</frameName>
  </plugin>
</sensor>
```

## World Description with SDF

SDF is also used to describe entire simulation environments:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="humanoid_world">
    <!-- Physics engine configuration -->
    <physics name="default_physics" type="ode">
      <gravity>0 0 -9.8</gravity>
      <ode>
        <solver>
          <type>quick</type>
          <iters>10</iters>
          <sor>1.0</sor>
        </solver>
        <constraints>
          <cfm>0.000001</cfm>
          <erp>0.2</erp>
          <contact_max_correcting_vel>100</contact_max_correcting_vel>
          <contact_surface_layer>0.001</contact_surface_layer>
        </constraints>
      </ode>
    </physics>

    <!-- Environment lighting -->
    <light name="sun" type="directional">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.3 0.3 -1</direction>
    </light>

    <!-- Ground plane -->
    <model name="ground_plane" static="true">
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>1.0</mu>
                <mu2>1.0</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.7 0.7 0.7 1</ambient>
            <diffuse>0.7 0.7 0.7 1</diffuse>
            <specular>0.7 0.7 0.7 1</specular>
          </material>
        </visual>
      </link>
    </model>

    <!-- Include robot model -->
    <include>
      <uri>model://humanoid_robot</uri>
      <pose>0 0 1.0 0 0 0</pose>
    </include>

    <!-- Additional objects in the environment -->
    <model name="table">
      <static>true</static>
      <link name="table_link">
        <collision name="collision">
          <geometry>
            <box>
              <size>1.0 0.8 0.8</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>1.0 0.8 0.8</size>
            </box>
          </geometry>
          <material>
            <ambient>0.8 0.6 0.4 1</ambient>
            <diffuse>0.8 0.6 0.4 1</diffuse>
          </material>
        </visual>
      </link>
    </model>
  </world>
</sdf>
```

## Converting URDF to SDF

For simulation, you often need to convert URDF models to SDF. This can be done using Gazebo's built-in tools:

```bash
# Convert URDF to SDF
gz sdf -p robot.urdf > robot.sdf

# Or using the legacy tool
gzsdf -p robot.urdf > robot.sdf
```

However, for more complex humanoid robots, you may want to add simulation-specific properties directly to the SDF file:

```xml
<!-- Add Gazebo-specific plugins and properties -->
<gazebo reference="base_link">
  <material>Gazebo/Blue</material>
  <mu1>0.2</mu1>
  <mu2>0.2</mu2>
  <kp>1000000.0</kp>
  <kd>1000000.0</kd>
</gazebo>

<!-- Add controller plugins -->
<gazebo>
  <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
    <robotNamespace>/humanoid_robot</robotNamespace>
    <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>
  </plugin>
</gazebo>
```

## SDF Best Practices for Humanoid Robotics

### 1. Realistic Physics Parameters
- Use appropriate friction coefficients for different materials
- Set realistic damping and spring constants for joints
- Configure contact properties to match real-world behavior

### 2. Accurate Sensor Models
- Include realistic noise models that match actual sensor specifications
- Set appropriate update rates for each sensor type
- Configure proper field-of-view and range parameters

### 3. Performance Optimization
- Use simplified collision geometry where possible
- Set appropriate update rates to balance accuracy and performance
- Use static models for environment objects that don't move

### 4. Modular Design
- Break complex humanoid robots into logical sub-models
- Use SDF includes to reuse common components
- Organize models in a hierarchical structure

### 5. Validation and Testing
- Test models in simulation before real-world deployment
- Verify that physical properties match real hardware
- Validate sensor outputs for realistic behavior

SDF provides the detailed physics and sensor modeling capabilities necessary for realistic humanoid robot simulation. By properly configuring SDF files, you can create simulation environments that closely match real-world conditions, enabling effective development and testing of Physical AI systems.
