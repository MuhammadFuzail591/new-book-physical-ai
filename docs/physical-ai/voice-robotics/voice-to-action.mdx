---
title: Voice-to-Action Command Processing in Robotics
---

# Voice-to-Action Command Processing in Robotics

## Introduction to Voice Command Processing

Voice-to-action processing in robotics involves converting spoken natural language commands into executable robot actions. This process requires multiple sophisticated components working in harmony: speech recognition, natural language understanding, command mapping, and action execution. The goal is to create an intuitive interface that allows humans to communicate with robots using natural language, similar to how we communicate with other humans.

The voice-to-action pipeline can be broken down into several stages:
1. **Speech Recognition**: Converting audio to text
2. **Natural Language Understanding**: Interpreting the meaning of commands
3. **Command Mapping**: Translating understood commands to robot actions
4. **Action Execution**: Executing mapped actions on the robot
5. **Feedback Generation**: Providing confirmation or error feedback

## Command Structure and Classification

### Command Categories

Robotic voice commands can typically be categorized into several types:

1. **Navigation Commands**: Directing the robot to move to specific locations
   - "Go to the kitchen"
   - "Come here"
   - "Move forward 2 meters"
   - "Turn left"

2. **Manipulation Commands**: Instructing the robot to interact with objects
   - "Pick up the red cup"
   - "Place the book on the table"
   - "Open the door"
   - "Grab the pen"

3. **Information Commands**: Requesting information from the robot
   - "What time is it?"
   - "Tell me about yourself"
   - "What can you do?"
   - "Where are you?"

4. **Interaction Commands**: Initiating social interactions
   - "Say hello to John"
   - "Introduce yourself"
   - "Follow me"
   - "Wait here"

### Command Parsing Architecture

```python
import re
import spacy
from typing import Dict, List, Tuple, Optional

class VoiceCommandParser:
    def __init__(self):
        # Load spaCy model for linguistic analysis
        try:
            self.nlp = spacy.load("en_core_web_sm")
        except OSError:
            print("spaCy English model not found. Install with: python -m spacy download en_core_web_sm")
            self.nlp = None

        # Define command patterns and templates
        self.command_patterns = {
            'navigation': [
                r'go to (?:the )?(?P<location>\w+(?: \w+)*)',
                r'move to (?:the )?(?P<location>\w+(?: \w+)*)',
                r'navigate to (?:the )?(?P<location>\w+(?: \w+)*)',
                r'come (?:here|to me)',
                r'move (?:forward|backward|left|right)',
                r'go (?:forward|backward|left|right)'
            ],
            'manipulation': [
                r'(?:pick up|grab|take) (?:the )?(?P<object>\w+(?: \w+)*)',
                r'place (?:the )?(?P<object>\w+(?: \w+)*) (?:on|at) (?:the )?(?P<destination>\w+(?: \w+)*)',
                r'put (?:the )?(?P<object>\w+(?: \w+)*) (?:on|at) (?:the )?(?P<destination>\w+(?: \w+)*)',
                r'open (?:the )?(?P<object>\w+(?: \w+)*)',
                r'close (?:the )?(?P<object>\w+(?: \w+)*)'
            ],
            'information': [
                r'what time is it',
                r'tell me about yourself',
                r'introduce yourself',
                r'what can you do',
                r'where are you'
            ],
            'interaction': [
                r'say hello to (?P<name>\w+)',
                r'introduce yourself(?: to (?P<name>\w+))?',
                r'follow me',
                r'wait here',
                r'stop'
            ]
        }

        # Define entity extraction patterns
        self.entity_patterns = {
            'location': [r'kitchen', r'bedroom', r'living room', r'bathroom', r'office', r'dining room'],
            'object': [r'cup', r'book', r'pen', r'ball', r'box', r'table', r'chair', r'door'],
            'action': [r'pick', r'place', r'grab', r'open', r'close', r'move', r'go'],
            'direction': [r'forward', r'backward', r'left', r'right', r'up', r'down']
        }

    def parse_command(self, text: str) -> Dict:
        """
        Parse a voice command and extract its components
        """
        text_lower = text.lower().strip()

        # Use regex patterns to identify command type
        command_type = self.identify_command_type(text_lower)

        # Extract entities using NLP if available
        entities = self.extract_entities(text_lower)

        # Perform syntactic analysis
        syntax_analysis = self.analyze_syntax(text_lower)

        # Generate action plan
        action_plan = self.generate_action_plan(command_type, entities)

        return {
            'raw_text': text,
            'command_type': command_type,
            'entities': entities,
            'syntax_analysis': syntax_analysis,
            'action_plan': action_plan,
            'confidence': self.calculate_confidence(text_lower, command_type, entities)
        }

    def identify_command_type(self, text: str) -> str:
        """
        Identify the type of command using regex patterns
        """
        for cmd_type, patterns in self.command_patterns.items():
            for pattern in patterns:
                match = re.search(pattern, text)
                if match:
                    return cmd_type

        # If no pattern matches, return 'unknown'
        return 'unknown'

    def extract_entities(self, text: str) -> Dict[str, List[str]]:
        """
        Extract named entities from the command text
        """
        entities = {
            'location': [],
            'object': [],
            'person': [],
            'action': [],
            'direction': [],
            'other': []
        }

        # If spaCy is available, use it for entity extraction
        if self.nlp:
            doc = self.nlp(text)

            # Extract named entities
            for ent in doc.ents:
                if ent.label_ in ['GPE', 'LOC', 'FAC']:  # Geopolitical, location, facility
                    entities['location'].append(ent.text)
                elif ent.label_ == 'PERSON':
                    entities['person'].append(ent.text)
                elif ent.label_ in ['OBJECT', 'PRODUCT']:  # These might not be standard labels
                    entities['object'].append(ent.text)

            # Extract noun chunks as potential objects
            for chunk in doc.noun_chunks:
                if chunk.text != chunk.root.text:  # Skip single-word chunks for now
                    entities['object'].append(chunk.text)

        # Use pattern-based extraction as fallback
        for entity_type, patterns in self.entity_patterns.items():
            for pattern in patterns:
                matches = re.findall(pattern, text, re.IGNORECASE)
                entities[entity_type].extend(matches)

        # Remove duplicates while preserving order
        for key in entities:
            entities[key] = list(dict.fromkeys(entities[key]))

        return entities

    def analyze_syntax(self, text: str) -> Dict:
        """
        Perform basic syntactic analysis
        """
        if not self.nlp:
            # Simple fallback without NLP
            words = text.split()
            return {
                'verb': words[0] if words else None,  # Very basic assumption
                'noun_phrase': ' '.join(words[1:]) if len(words) > 1 else None,
                'pos_tags': [(word, 'UNKNOWN') for word in words]
            }

        doc = self.nlp(text)

        # Extract verbs (actions)
        verbs = [token.lemma_ for token in doc if token.pos_ == 'VERB']

        # Extract subjects and objects
        subjects = [chunk.text for chunk in doc.noun_chunks if any(token.dep_ == 'nsubj' for token in chunk)]
        objects = [chunk.text for chunk in doc.noun_chunks if any(token.dep_ == 'dobj' for token in chunk)]

        # Extract dependencies
        dependencies = [(token.text, token.dep_, token.head.text) for token in doc]

        return {
            'verbs': verbs,
            'subjects': subjects,
            'objects': objects,
            'dependencies': dependencies,
            'pos_tags': [(token.text, token.pos_) for token in doc]
        }

    def generate_action_plan(self, command_type: str, entities: Dict) -> List[Dict]:
        """
        Generate an action plan based on command type and entities
        """
        action_plan = []

        if command_type == 'navigation':
            if entities['location']:
                for location in entities['location']:
                    action_plan.append({
                        'action_type': 'navigation',
                        'target': location,
                        'parameters': {}
                    })
            elif 'here' in entities.get('direction', []) or 'me' in str(entities):
                action_plan.append({
                    'action_type': 'navigation',
                    'target': 'user_location',
                    'parameters': {}
                })
            elif entities['direction']:
                for direction in entities['direction']:
                    action_plan.append({
                        'action_type': 'move',
                        'direction': direction,
                        'distance': 1.0,  # Default distance
                        'parameters': {}
                    })

        elif command_type == 'manipulation':
            if entities['object']:
                for obj in entities['object']:
                    action = 'pick'  # Default action
                    if any(word in ['place', 'put', 'on', 'at'] for word in entities.get('other', [])):
                        action = 'place'
                    elif any(word in ['open', 'close'] for word in entities.get('action', [])):
                        action = entities['action'][0] if entities['action'] else 'manipulate'

                    action_plan.append({
                        'action_type': 'manipulation',
                        'object': obj,
                        'action': action,
                        'destination': entities['location'][0] if entities['location'] else None,
                        'parameters': {}
                    })

        elif command_type == 'information':
            for entity in entities.get('other', []):
                if 'time' in entity:
                    action_plan.append({
                        'action_type': 'information',
                        'request': 'time',
                        'parameters': {}
                    })
                elif 'yourself' in entity or 'introduce' in entity:
                    action_plan.append({
                        'action_type': 'information',
                        'request': 'self_introduction',
                        'parameters': {}
                    })

        elif command_type == 'interaction':
            if 'follow' in str(entities) or 'me' in str(entities):
                action_plan.append({
                    'action_type': 'interaction',
                    'interaction_type': 'follow',
                    'target': 'user',
                    'parameters': {}
                })
            elif 'hello' in str(entities) or 'hi' in str(entities):
                action_plan.append({
                    'action_type': 'interaction',
                    'interaction_type': 'greet',
                    'target': entities['person'][0] if entities['person'] else 'user',
                    'parameters': {}
                })

        return action_plan

    def calculate_confidence(self, text: str, command_type: str, entities: Dict) -> float:
        """
        Calculate confidence score for the parsed command
        """
        confidence = 0.0

        # Base confidence on command type identification
        if command_type != 'unknown':
            confidence += 0.5
        else:
            return 0.0  # If unknown, confidence is 0

        # Boost confidence if entities are found
        entity_count = sum(len(v) for v in entities.values())
        if entity_count > 0:
            confidence += 0.3 * min(entity_count / 5.0, 1.0)  # Up to 0.3 bonus

        # Additional confidence boost based on text length and structure
        if len(text.split()) >= 3:  # Reasonable command length
            confidence += 0.2

        return min(confidence, 1.0)  # Cap at 1.0
```

## Context-Aware Command Processing

### Maintaining Conversation Context

For more sophisticated voice-to-action systems, maintaining context is crucial for understanding ambiguous commands:

```python
from datetime import datetime, timedelta
from typing import Any, Dict, List

class ContextAwareCommandProcessor:
    def __init__(self, context_window_minutes=5):
        self.context_window = timedelta(minutes=context_window_minutes)
        self.conversation_history = []
        self.current_context = {}
        self.last_command_time = None

    def process_command_with_context(self, command_text: str, user_id: str = "default_user") -> Dict:
        """
        Process a command while considering the conversation context
        """
        current_time = datetime.now()

        # Update context based on time elapsed
        self.update_context_for_time(current_time)

        # Add current command to history
        command_entry = {
            'text': command_text,
            'user_id': user_id,
            'timestamp': current_time,
            'processed': False
        }
        self.conversation_history.append(command_entry)

        # Parse the command
        parsed_command = self.parse_command(command_text)

        # Apply context-aware disambiguation
        disambiguated_command = self.apply_context_disambiguation(parsed_command)

        # Update internal context
        self.update_internal_context(disambiguated_command, current_time)

        # Generate response
        response = {
            'original_command': command_text,
            'parsed_command': disambiguated_command,
            'context_used': self.current_context.copy(),
            'timestamp': current_time
        }

        # Mark command as processed
        command_entry['processed'] = True
        command_entry['result'] = response

        return response

    def update_context_for_time(self, current_time: datetime):
        """
        Clean up old context entries based on time window
        """
        cutoff_time = current_time - self.context_window

        # Remove old entries from history
        self.conversation_history = [
            entry for entry in self.conversation_history
            if entry['timestamp'] > cutoff_time
        ]

        # Update last command time
        if self.conversation_history:
            self.last_command_time = self.conversation_history[-1]['timestamp']
        else:
            self.last_command_time = None

    def apply_context_disambiguation(self, parsed_command: Dict) -> Dict:
        """
        Apply context to disambiguate the parsed command
        """
        command_type = parsed_command['command_type']
        entities = parsed_command['entities']

        # If command is navigation-related and no specific location is mentioned
        if command_type == 'navigation' and not entities['location']:
            # Check if user previously mentioned a location
            recent_locations = self.get_recent_entities('location', minutes=10)
            if recent_locations:
                # Use the most recent location
                entities['location'] = [recent_locations[-1]]
                parsed_command['entities'] = entities
                parsed_command['disambiguated'] = True
                parsed_command['reason'] = f"Using context: location '{recent_locations[-1]}' from previous command"

        # If command is manipulation-related and no specific object is mentioned
        elif command_type == 'manipulation' and not entities['object']:
            # Check if user previously mentioned an object
            recent_objects = self.get_recent_entities('object', minutes=5)
            if recent_objects:
                # Use the most recent object
                entities['object'] = [recent_objects[-1]]
                parsed_command['entities'] = entities
                parsed_command['disambiguated'] = True
                parsed_command['reason'] = f"Using context: object '{recent_objects[-1]}' from previous command"

        # If command refers to "it" or "that"
        elif any(pronoun in parsed_command['raw_text'].lower() for pronoun in ['it', 'that', 'there']):
            # Look for recently mentioned objects or locations
            recent_objects = self.get_recent_entities('object', minutes=5)
            recent_locations = self.get_recent_entities('location', minutes=5)

            # Prioritize objects over locations for "it" and "that"
            if recent_objects:
                entities['object'] = [recent_objects[-1]]
                parsed_command['entities'] = entities
                parsed_command['disambiguated'] = True
                parsed_command['reason'] = f"Using context: '{recent_objects[-1]}' referred to as 'it/that'"
            elif recent_locations:
                entities['location'] = [recent_locations[-1]]
                parsed_command['entities'] = entities
                parsed_command['disambiguated'] = True
                parsed_command['reason'] = f"Using context: '{recent_locations[-1]}' referred to as 'it/there'"

        return parsed_command

    def get_recent_entities(self, entity_type: str, minutes: int = 5) -> List[str]:
        """
        Get entities of a specific type from recent commands
        """
        cutoff_time = datetime.now() - timedelta(minutes=minutes)
        recent_entities = []

        for entry in reversed(self.conversation_history):
            if entry['timestamp'] > cutoff_time and 'result' in entry:
                entities = entry['result']['parsed_command']['entities']
                if entity_type in entities:
                    recent_entities.extend(entities[entity_type])

        # Remove duplicates while preserving order
        return list(dict.fromkeys(recent_entities))

    def update_internal_context(self, parsed_command: Dict, timestamp: datetime):
        """
        Update internal context based on the processed command
        """
        # Update current location if navigation command was successful
        if parsed_command['command_type'] == 'navigation' and parsed_command['entities']['location']:
            self.current_context['current_location'] = parsed_command['entities']['location'][0]
            self.current_context['last_navigation_time'] = timestamp

        # Update held object if manipulation command was successful
        if parsed_command['command_type'] == 'manipulation':
            action = parsed_command.get('action_plan', [{}])[0].get('action', '') if parsed_command.get('action_plan') else ''
            if action == 'pick' and parsed_command['entities']['object']:
                self.current_context['held_object'] = parsed_command['entities']['object'][0]
            elif action == 'place':
                self.current_context.pop('held_object', None)  # Remove held object when placed

    def get_conversation_summary(self) -> Dict:
        """
        Get a summary of the current conversation state
        """
        return {
            'total_commands': len(self.conversation_history),
            'active_context': self.current_context,
            'recent_commands': [
                {
                    'text': entry['text'],
                    'timestamp': entry['timestamp'].isoformat(),
                    'processed': entry.get('processed', False)
                }
                for entry in self.conversation_history[-5:]  # Last 5 commands
            ]
        }
```

## Command Validation and Safety Checking

### Safety Validation Pipeline

Before executing voice commands, it's crucial to validate them for safety and feasibility:

```python
import rospy
from geometry_msgs.msg import Point
from sensor_msgs.msg import LaserScan
from typing import Dict, List, Tuple

class CommandSafetyValidator:
    def __init__(self):
        # Subscribe to relevant sensor topics
        self.laser_sub = rospy.Subscriber('/scan', LaserScan, self.laser_callback)
        self.odom_sub = rospy.Subscriber('/odom', Odometry, self.odom_callback)

        # Store current sensor data
        self.current_scan = None
        self.current_odom = None
        self.robot_radius = 0.3  # Robot radius in meters

        # Define safety zones and constraints
        self.safety_zones = {
            'forbidden_areas': [],  # List of Polygon points
            'restricted_heights': (0.1, 1.5),  # (min, max) in meters
            'speed_limits': {'navigation': 0.5, 'manipulation': 0.1}
        }

    def laser_callback(self, scan_msg):
        """Update current laser scan data"""
        self.current_scan = scan_msg

    def odom_callback(self, odom_msg):
        """Update current odometry data"""
        self.current_odom = odom_msg

    def validate_navigation_command(self, destination: Point) -> Dict:
        """
        Validate a navigation command for safety
        """
        if not self.current_odom:
            return {
                'valid': False,
                'reason': 'No odometry data available',
                'risk_factors': ['position_unknown']
            }

        # Check if destination is in forbidden area
        if self.is_in_forbidden_area(destination):
            return {
                'valid': False,
                'reason': 'Destination is in a forbidden area',
                'risk_factors': ['forbidden_zone']
            }

        # Check path for obstacles
        path_clear, obstacles = self.check_path_for_obstacles(
            self.current_odom.pose.pose.position,
            destination
        )

        if not path_clear:
            return {
                'valid': False,
                'reason': f'Path to destination blocked by obstacles: {obstacles}',
                'risk_factors': ['obstacle_in_path'],
                'obstacles': obstacles
            }

        # Check if destination is too close to walls or obstacles
        clearance_ok = self.check_destination_clearance(destination)
        if not clearance_ok:
            return {
                'valid': False,
                'reason': 'Insufficient clearance at destination',
                'risk_factors': ['insufficient_clearance']
            }

        # If all checks pass
        return {
            'valid': True,
            'reason': 'Navigation command is safe to execute',
            'risk_factors': [],
            'estimated_travel_time': self.estimate_travel_time(destination)
        }

    def validate_manipulation_command(self, object_position: Point, action: str) -> Dict:
        """
        Validate a manipulation command for safety
        """
        if not self.current_odom:
            return {
                'valid': False,
                'reason': 'No position data available',
                'risk_factors': ['position_unknown']
            }

        # Check if object is reachable
        robot_pos = self.current_odom.pose.pose.position
        distance = self.calculate_distance(robot_pos, object_position)

        max_reach = 1.0  # Maximum reach in meters
        if distance > max_reach:
            return {
                'valid': False,
                'reason': f'Object is too far away (distance: {distance:.2f}m, max: {max_reach}m)',
                'risk_factors': ['out_of_reach']
            }

        # Check if object is at safe height
        min_height, max_height = self.safety_zones['restricted_heights']
        if not (min_height <= object_position.z <= max_height):
            return {
                'valid': False,
                'reason': f'Object is at unsafe height (z: {object_position.z:.2f}m, safe range: {min_height}-{max_height}m)',
                'risk_factors': ['unsafe_height']
            }

        # Check for obstacles between robot and object
        path_clear, obstacles = self.check_path_for_obstacles(robot_pos, object_position)
        if not path_clear:
            return {
                'valid': False,
                'reason': f'Trajectory to object blocked by obstacles: {obstacles}',
                'risk_factors': ['obstacle_in_trajectory'],
                'obstacles': obstacles
            }

        # Validate specific action safety
        action_valid, action_reason = self.validate_action_specific_safety(action, object_position)
        if not action_valid:
            return {
                'valid': False,
                'reason': action_reason,
                'risk_factors': ['action_unsafe']
            }

        return {
            'valid': True,
            'reason': 'Manipulation command is safe to execute',
            'risk_factors': [],
            'estimated_execution_time': self.estimate_manipulation_time(action)
        }

    def is_in_forbidden_area(self, point: Point) -> bool:
        """
        Check if a point is in a forbidden area
        """
        # For now, implement a simple circular forbidden zone
        # In practice, this would check against polygonal regions
        forbidden_centers = [
            Point(x=0.0, y=0.0, z=0.0),  # Example: center of room
            Point(x=5.0, y=5.0, z=0.0)   # Example: specific location
        ]
        forbidden_radius = 0.5

        for center in forbidden_centers:
            distance = self.calculate_distance(point, center)
            if distance < forbidden_radius:
                return True

        return False

    def check_path_for_obstacles(self, start: Point, end: Point) -> Tuple[bool, List[Point]]:
        """
        Check if the path between two points is clear of obstacles
        """
        if not self.current_scan:
            return False, []

        # Calculate path points
        path_points = self.discretize_path(start, end, resolution=0.1)
        obstacles = []

        for point in path_points:
            # Check if this point is near an obstacle
            if self.is_point_near_obstacle(point):
                obstacles.append(point)

        return len(obstacles) == 0, obstacles

    def discretize_path(self, start: Point, end: Point, resolution: float = 0.1) -> List[Point]:
        """
        Discretize a path from start to end into points
        """
        path_points = []
        distance = self.calculate_distance(start, end)
        num_points = int(distance / resolution) + 1

        for i in range(num_points + 1):
            t = i / num_points if num_points > 0 else 0
            point = Point()
            point.x = start.x + t * (end.x - start.x)
            point.y = start.y + t * (end.y - start.y)
            point.z = start.z + t * (end.z - start.z)
            path_points.append(point)

        return path_points

    def is_point_near_obstacle(self, point: Point) -> bool:
        """
        Check if a point is near an obstacle based on laser scan data
        """
        if not self.current_scan:
            return True  # Assume obstacle if no data

        # Convert point to robot frame and check against scan
        # This is a simplified version - in practice, you'd transform coordinates
        # and check against actual scan beams
        min_distance = min(self.current_scan.ranges) if self.current_scan.ranges else float('inf')
        return min_distance < self.robot_radius

    def check_destination_clearance(self, destination: Point) -> bool:
        """
        Check if there's sufficient clearance at the destination
        """
        # Check if the destination area is free of obstacles
        # This would involve checking a small area around the destination
        # For now, we'll use a simplified check
        return True

    def validate_action_specific_safety(self, action: str, object_position: Point) -> Tuple[bool, str]:
        """
        Validate safety for specific manipulation actions
        """
        if action == 'pick':
            # Check if object is too heavy or dangerous to pick
            # This would require object recognition and weight estimation
            return True, "Action is safe"

        elif action == 'place':
            # Check if placement location is safe
            return True, "Action is safe"

        elif action == 'open':
            # Check if opening action is safe for this object type
            return True, "Action is safe"

        else:
            return True, "Action is safe"  # Default assumption

    def calculate_distance(self, p1: Point, p2: Point) -> float:
        """
        Calculate Euclidean distance between two points
        """
        dx = p2.x - p1.x
        dy = p2.y - p1.y
        dz = p2.z - p1.z
        return (dx*dx + dy*dy + dz*dz)**0.5

    def estimate_travel_time(self, destination: Point) -> float:
        """
        Estimate travel time to destination
        """
        if not self.current_odom:
            return float('inf')

        distance = self.calculate_distance(
            self.current_odom.pose.pose.position,
            destination
        )
        max_speed = self.safety_zones['speed_limits']['navigation']
        return distance / max_speed if max_speed > 0 else float('inf')

    def estimate_manipulation_time(self, action: str) -> float:
        """
        Estimate time for manipulation action
        """
        # Time estimates for different actions
        time_estimates = {
            'pick': 5.0,      # seconds
            'place': 4.0,     # seconds
            'open': 6.0,      # seconds
            'close': 5.0,     # seconds
            'move': 3.0       # seconds
        }
        return time_estimates.get(action, 5.0)
```

## Error Recovery and Fallback Mechanisms

### Command Recovery Strategies

Even with robust validation, voice commands may fail during execution. Effective recovery mechanisms are essential:

```python
import time
from enum import Enum

class RecoveryStrategy(Enum):
    RETRY = "retry"
    SIMPLIFY = "simplify"
    ALTERNATIVE = "alternative"
    HUMAN_ASSISTANCE = "human_assistance"
    ABORT = "abort"

class VoiceCommandRecovery:
    def __init__(self, max_retries=3):
        self.max_retries = max_retries
        self.failure_history = {}
        self.known_alternatives = {
            'kitchen': ['kitchen', 'kit', 'ken', 'chicken'],
            'bedroom': ['bedroom', 'bed', 'red room'],
            'living room': ['living room', 'living', 'lounge', 'sitting room'],
            'bathroom': ['bathroom', 'bath', 'restroom', 'toilet'],
            'office': ['office', 'study', 'work room']
        }

    def execute_with_recovery(self, command_parser, command_executor, command_text):
        """
        Execute a command with built-in recovery mechanisms
        """
        original_command = command_text
        retry_count = 0
        last_error = None

        while retry_count < self.max_retries:
            try:
                # Parse the command
                parsed_command = command_parser.parse_command(command_text)

                # Validate the command
                if parsed_command['confidence'] < 0.3:
                    raise ValueError(f"Command confidence too low: {parsed_command['confidence']}")

                # Execute the command
                result = command_executor.execute_command(parsed_command)

                if result['success']:
                    # Log successful execution
                    self.log_execution(original_command, command_text, 'SUCCESS', retry_count)
                    return result

                # If execution failed, determine next action
                error_msg = result.get('error', 'Unknown execution error')
                recovery_strategy = self.select_recovery_strategy(error_msg, command_text)

                if recovery_strategy == RecoveryStrategy.RETRY:
                    retry_count += 1
                    time.sleep(1)  # Brief pause before retry
                    continue
                elif recovery_strategy == RecoveryStrategy.SIMPLIFY:
                    command_text = self.simplify_command(command_text)
                    retry_count += 1
                    continue
                elif recovery_strategy == RecoveryStrategy.ALTERNATIVE:
                    alternative_command = self.get_alternative_command(command_text)
                    if alternative_command and alternative_command != command_text:
                        command_text = alternative_command
                        retry_count += 1
                        continue
                    else:
                        break  # No alternative available
                elif recovery_strategy == RecoveryStrategy.HUMAN_ASSISTANCE:
                    return self.request_human_assistance(original_command, error_msg)
                else:  # ABORT
                    break

            except Exception as e:
                last_error = str(e)
                recovery_strategy = self.select_recovery_strategy(str(e), command_text)

                if recovery_strategy == RecoveryStrategy.RETRY:
                    retry_count += 1
                    time.sleep(1)
                    continue
                elif recovery_strategy == RecoveryStrategy.SIMPLIFY:
                    command_text = self.simplify_command(command_text)
                    retry_count += 1
                    continue
                elif recovery_strategy == RecoveryStrategy.ALTERNATIVE:
                    alternative_command = self.get_alternative_command(command_text)
                    if alternative_command and alternative_command != command_text:
                        command_text = alternative_command
                        retry_count += 1
                        continue
                    else:
                        break
                elif recovery_strategy == RecoveryStrategy.HUMAN_ASSISTANCE:
                    return self.request_human_assistance(original_command, str(e))
                else:  # ABORT
                    break

        # If we've exhausted retries
        final_result = {
            'success': False,
            'original_command': original_command,
            'attempted_command': command_text,
            'error': last_error or f"Command failed after {self.max_retries} attempts",
            'attempts_made': retry_count,
            'recovery_attempts': []
        }

        self.log_execution(original_command, command_text, 'FAILED', retry_count, last_error)
        return final_result

    def select_recovery_strategy(self, error_message: str, command_text: str) -> RecoveryStrategy:
        """
        Select the most appropriate recovery strategy based on error
        """
        error_lower = error_message.lower()

        # If error suggests misunderstanding of command
        if any(keyword in error_lower for keyword in ['unknown', 'unrecognized', 'not found', 'invalid']):
            # Check if it's a location/command that might have alternatives
            for location, alternatives in self.known_alternatives.items():
                if any(alt.lower() in command_text.lower() for alt in alternatives):
                    return RecoveryStrategy.ALTERNATIVE

            # If it's a complex command, try simplifying
            if len(command_text.split()) > 4:
                return RecoveryStrategy.SIMPLIFY

            return RecoveryStrategy.RETRY

        # If error suggests physical limitation
        elif any(keyword in error_lower for keyword in ['obstacle', 'blocked', 'collision', 'reachable']):
            return RecoveryStrategy.HUMAN_ASSISTANCE

        # If error suggests temporary condition
        elif any(keyword in error_lower for keyword in ['busy', 'timeout', 'connection', 'offline']):
            return RecoveryStrategy.RETRY

        # Default to abort for other errors
        return RecoveryStrategy.ABORT

    def simplify_command(self, command_text: str) -> str:
        """
        Simplify a complex command to a more basic form
        """
        original = command_text.lower()

        # Remove qualifiers and modifiers
        simplified = original.replace('please', '').replace('could you', '').replace('would you', '')
        simplified = simplified.replace('kindly', '').replace('if you would', '').replace('go ahead and', '')

        # Remove specific descriptors that might be causing issues
        import re
        # Remove color descriptors
        simplified = re.sub(r'\b(red|blue|green|yellow|black|white|large|small|big|little)\b\s*', '', simplified)

        # Remove directional descriptors that might be ambiguous
        simplified = re.sub(r'\b(left|right|front|back|near|far|closest|furthest)\b\s*', '', simplified)

        # Try to extract the core action
        if 'go to' in simplified:
            simplified = 'go to ' + simplified.split('go to', 1)[1].strip()
        elif 'move to' in simplified:
            simplified = 'move to ' + simplified.split('move to', 1)[1].strip()
        elif 'pick up' in simplified:
            simplified = 'pick ' + simplified.split('pick up', 1)[1].strip()
        elif 'grab the' in simplified:
            simplified = 'grab ' + simplified.split('grab the', 1)[1].strip()

        return simplified.strip()

    def get_alternative_command(self, command_text: str) -> str:
        """
        Get an alternative command that might be clearer
        """
        # Check against known alternatives
        for location, alternatives in self.known_alternatives.items():
            for alt in alternatives:
                if alt.lower() in command_text.lower():
                    # Replace with the canonical form
                    return command_text.lower().replace(alt.lower(), location)

        # If no known alternative, return None
        return None

    def request_human_assistance(self, original_command: str, error: str) -> Dict:
        """
        Return a result indicating human assistance is needed
        """
        return {
            'success': False,
            'needs_human_assistance': True,
            'original_command': original_command,
            'error': error,
            'assistance_requested': True,
            'suggested_actions': [
                "Please repeat the command more clearly",
                "Use simpler language",
                "Specify the exact location or object",
                "Check if the robot's path is clear"
            ]
        }

    def log_execution(self, original_command: str, attempted_command: str, status: str,
                     attempts: int, error: str = None):
        """
        Log command execution for analysis and improvement
        """
        log_entry = {
            'timestamp': time.time(),
            'original_command': original_command,
            'attempted_command': attempted_command,
            'status': status,
            'attempts': attempts,
            'error': error,
            'success': status == 'SUCCESS'
        }

        # In a real system, you might save this to a database
        print(f"Command execution log: {log_entry}")
```

## Performance Optimization

### Optimizing Voice Command Processing

For real-time robotics applications, optimizing the voice-to-action pipeline is crucial:

```python
import asyncio
import concurrent.futures
from functools import lru_cache
import threading
import time

class OptimizedVoiceCommandProcessor:
    def __init__(self):
        # Use thread pool for CPU-intensive tasks
        self.thread_pool = concurrent.futures.ThreadPoolExecutor(max_workers=4)

        # Cache for frequently used computations
        self.command_cache = {}
        self.max_cache_size = 100

        # Timing statistics
        self.timing_stats = {
            'parse_time': [],
            'validation_time': [],
            'execution_time': []
        }

        # Async event loop for non-blocking operations
        self.loop = asyncio.new_event_loop()
        threading.Thread(target=self._run_event_loop, args=(self.loop,), daemon=True).start()

    def _run_event_loop(self, loop):
        """Run the asyncio event loop in a separate thread"""
        asyncio.set_event_loop(loop)
        loop.run_forever()

    def process_command_async(self, command_text: str) -> asyncio.Future:
        """
        Process a command asynchronously
        """
        future = asyncio.run_coroutine_threadsafe(
            self._process_command_coroutine(command_text),
            self.loop
        )
        return future

    async def _process_command_coroutine(self, command_text: str) -> Dict:
        """
        Coroutine for processing commands asynchronously
        """
        start_time = time.time()

        # Check cache first
        cached_result = self._check_cache(command_text)
        if cached_result:
            return cached_result

        # Parse command
        parse_start = time.time()
        parser = VoiceCommandParser()
        parsed_command = parser.parse_command(command_text)
        parse_time = time.time() - parse_start

        # Validate command
        validation_start = time.time()
        validator = CommandSafetyValidator()
        validation_result = await self._validate_command_async(validator, parsed_command)
        validation_time = time.time() - validation_start

        # Store timing
        self.timing_stats['parse_time'].append(parse_time)
        self.timing_stats['validation_time'].append(validation_time)

        # Prepare result
        result = {
            'command': command_text,
            'parsed': parsed_command,
            'validation': validation_result,
            'processing_time': time.time() - start_time,
            'cached': False
        }

        # Add to cache
        self._add_to_cache(command_text, result)

        return result

    async def _validate_command_async(self, validator, parsed_command: Dict) -> Dict:
        """
        Validate command using thread pool for CPU-intensive validation
        """
        def run_validation():
            command_type = parsed_command['command_type']
            entities = parsed_command['entities']

            if command_type == 'navigation' and entities.get('location'):
                # For simplicity, just return a basic validation
                return {'valid': True, 'reason': 'Validation passed'}
            elif command_type == 'manipulation' and entities.get('object'):
                return {'valid': True, 'reason': 'Validation passed'}
            else:
                return {'valid': False, 'reason': 'No specific validation rule for command type'}

        # Run validation in thread pool
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(self.thread_pool, run_validation)

    def _check_cache(self, command_text: str) -> Dict:
        """
        Check if command result is in cache
        """
        if command_text in self.command_cache:
            result = self.command_cache[command_text]
            result['cached'] = True
            return result
        return None

    def _add_to_cache(self, command_text: str, result: Dict):
        """
        Add result to cache with size management
        """
        if len(self.command_cache) >= self.max_cache_size:
            # Remove oldest entry (this is a simple FIFO approach)
            oldest_key = next(iter(self.command_cache))
            del self.command_cache[oldest_key]

        self.command_cache[command_text] = result

    def get_performance_metrics(self) -> Dict:
        """
        Get performance metrics for the command processor
        """
        def safe_average(lst):
            return sum(lst) / len(lst) if lst else 0

        def safe_max(lst):
            return max(lst) if lst else 0

        def safe_min(lst):
            return min(lst) if lst else 0

        return {
            'parse_time_avg': safe_average(self.timing_stats['parse_time']),
            'parse_time_min': safe_min(self.timing_stats['parse_time']),
            'parse_time_max': safe_max(self.timing_stats['parse_time']),
            'validation_time_avg': safe_average(self.timing_stats['validation_time']),
            'validation_time_min': safe_min(self.timing_stats['validation_time']),
            'validation_time_max': safe_max(self.timing_stats['validation_time']),
            'cache_hit_rate': len([r for r in self.command_cache.values() if r.get('cached')]) / len(self.command_cache) if self.command_cache else 0,
            'total_processed': len(self.timing_stats['parse_time'])
        }

    def cleanup(self):
        """
        Cleanup resources
        """
        self.thread_pool.shutdown(wait=True)
        self.loop.call_soon_threadsafe(self.loop.stop)
```

Voice-to-action command processing represents a critical component of modern robotic systems, enabling intuitive and natural human-robot interaction. By implementing robust parsing, context awareness, safety validation, and recovery mechanisms, we can create voice interfaces that are both powerful and reliable for real-world robotic applications.
