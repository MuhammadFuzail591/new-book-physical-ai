---
title: "Physics Engines in Gazebo - ODE, Bullet, and Simbody"
---

# Physics Engines in Gazebo: ODE, Bullet, and Simbody

## Introduction to Physics Simulation

Physics simulation is the cornerstone of realistic robot simulation in Gazebo. The physics engine is responsible for computing the interactions between objects, including collisions, contact forces, friction, and other physical phenomena. For humanoid robotics applications, selecting and configuring the appropriate physics engine is crucial for achieving stable and realistic simulation results.

## Overview of Available Physics Engines

Gazebo provides three main physics engines, each with distinct characteristics and use cases:

### 1. Open Dynamics Engine (ODE)

ODE is the default physics engine in Gazebo and is widely used in robotics research. It excels at handling contact simulation and is particularly well-suited for humanoid robots due to its stable contact handling capabilities.

**Key Features:**
- Stable contact simulation with good handling of friction
- Efficient collision detection for complex models
- Well-tested and mature codebase
- Good performance for humanoid robot applications

**Configuration Example:**
```xml
<physics name="ode_physics" type="ode">
  <gravity>0 0 -9.8</gravity>
  <ode>
    <solver>
      <type>quick</type>
      <iters>1000</iters>
      <sor>1.3</sor>
    </solver>
    <constraints>
      <cfm>0.000001</cfm>
      <erp>0.2</erp>
      <contact_max_correcting_vel>100</contact_max_correcting_vel>
      <contact_surface_layer>0.001</contact_surface_layer>
    </constraints>
  </ode>
  <max_step_size>0.001</max_step_size>
  <real_time_factor>1.0</real_time_factor>
  <real_time_update_rate>1000</real_time_update_rate>
</physics>
```

### 2. Bullet Physics

Bullet Physics is known for its superior performance in complex collision detection scenarios. It's particularly effective when simulating environments with many objects or complex geometries.

**Key Features:**
- Fast collision detection algorithms
- Better performance with large numbers of objects
- Good support for complex geometries
- Suitable for dynamic environments

**Configuration Example:**
```xml
<physics name="bullet_physics" type="bullet">
  <gravity>0 0 -9.8</gravity>
  <bullet>
    <solver>
      <type>sequential_impulse</type>
      <iter>50</iter>
      <sor>1.3</sor>
    </solver>
    <constraints>
      <cfm>0.000001</cfm>
      <erp>0.2</erp>
    </constraints>
  </bullet>
  <max_step_size>0.001</max_step_size>
  <real_time_factor>1.0</real_time_factor>
  <real_time_update_rate>1000</real_time_update_rate>
</physics>
```

### 3. Simbody

Simbody is designed for high-accuracy multibody dynamics and is excellent for complex kinematic chains. It's particularly suitable for precise humanoid motion simulation where accuracy is more important than raw performance.

**Key Features:**
- High-accuracy multibody dynamics
- Excellent for complex kinematic chains
- Suitable for precise motion simulation
- Advanced constraint handling

**Configuration Example:**
```xml
<physics name="simbody_physics" type="simbody">
  <gravity>0 0 -9.8</gravity>
  <simbody>
    <min_step_size>0.0001</min_step_size>
    <accuracy>0.001</accuracy>
    <max_contacts>20</max_contacts>
  </simbody>
  <max_step_size>0.001</max_step_size>
  <real_time_factor>1.0</real_time_factor>
  <real_time_update_rate>1000</real_time_update_rate>
</physics>
```

## Physics Engine Selection for Humanoid Robots

### ODE for Humanoid Applications

ODE is typically the best choice for humanoid robot simulation due to its stable contact handling. For humanoid robots that need to walk, balance, or interact with objects, ODE provides the most reliable contact simulation.

**Optimal ODE Settings for Humanoid Robots:**
```xml
<physics name="humanoid_ode" type="ode">
  <ode>
    <solver>
      <type>quick</type>
      <!-- Higher iterations for more stable contacts -->
      <iters>2000</iters>
      <sor>1.2</sor>
    </solver>
    <constraints>
      <!-- Low CFM for stiff constraints -->
      <cfm>1e-5</cfm>
      <!-- Higher ERP for faster error correction -->
      <erp>0.2</erp>
      <!-- Higher max correcting velocity for stable contacts -->
      <contact_max_correcting_vel>100</contact_max_correcting_vel>
      <!-- Small surface layer for accurate contacts -->
      <contact_surface_layer>0.001</contact_surface_layer>
    </constraints>
  </ode>
  <!-- Smaller time step for more accurate simulation -->
  <max_step_size>0.0005</max_step_size>
  <real_time_factor>0.5</real_time_factor>
  <real_time_update_rate>2000</real_time_update_rate>
</physics>
```

### Bullet for Complex Environments

Use Bullet when simulating humanoid robots in complex environments with many objects, or when performance is critical.

**Optimal Bullet Settings for Complex Environments:**
```xml
<physics name="bullet_complex_env" type="bullet">
  <bullet>
    <solver>
      <type>sequential_impulse</type>
      <iter>100</iter>
      <sor>1.3</sor>
    </solver>
    <constraints>
      <cfm>1e-6</cfm>
      <erp>0.1</erp>
    </constraints>
    <!-- Use continuous collision detection for fast-moving objects -->
    <use_ccd>true</use_ccd>
  </bullet>
  <max_step_size>0.001</max_step_size>
  <real_time_factor>1.0</real_time_factor>
</physics>
```

### Simbody for Precise Motion

Simbody is ideal when you need high accuracy in complex kinematic chains, such as for detailed analysis of humanoid joint movements.

**Optimal Simbody Settings for Precise Motion:**
```xml
<physics name="simbody_precise" type="simbody">
  <simbody>
    <min_step_size>1e-5</min_step_size>
    <accuracy>1e-4</accuracy>
    <max_contacts>50</max_contacts>
  </simbody>
  <max_step_size>0.0001</max_step_size>
  <real_time_factor>0.1</real_time_factor>
</physics>
```

## Advanced Physics Configuration

### Contact Properties

For humanoid robots, contact properties are crucial for stable walking and interaction:

```xml
<collision name="foot_collision">
  <surface>
    <friction>
      <ode>
        <!-- High friction for stable walking -->
        <mu>1.0</mu>
        <mu2>1.0</mu2>
        <!-- Direction of friction -->
        <fdir1>0 0 1</fdir1>
      </ode>
      <torsional>
        <!-- Torsional friction for preventing spinning -->
        <coefficient>1.0</coefficient>
        <use_patch_radius>1</use_patch_radius>
        <surface_radius>0.01</surface_radius>
      </torsional>
    </friction>
    <!-- Bounce properties -->
    <bounce>
      <restitution_coefficient>0.01</restitution_coefficient>
      <threshold>100000</threshold>
    </bounce>
    <!-- Contact dynamics -->
    <contact>
      <ode>
        <!-- Soft constraint force mixing -->
        <soft_cfm>0.0001</soft_cfm>
        <!-- Error reduction parameter -->
        <soft_erp>0.2</soft_erp>
        <!-- Spring stiffness -->
        <kp>1e+13</kp>
        <!-- Damping -->
        <kd>1</kd>
        <!-- Maximum velocity -->
        <max_vel>100.0</max_vel>
        <!-- Minimum depth -->
        <min_depth>0.001</min_depth>
      </ode>
    </contact>
  </surface>
</collision>
```

### Joint Physics Configuration

Proper joint physics configuration is essential for realistic humanoid movement:

```xml
<joint name="knee_joint" type="revolute">
  <parent>thigh</parent>
  <child>shin</child>
  <axis>
    <xyz>0 1 0</xyz>
    <limit>
      <lower>-0.1</lower>
      <upper>2.3</upper>
      <effort>300</effort>
      <velocity>5.0</velocity>
    </limit>
    <dynamics>
      <!-- Damping to simulate joint friction -->
      <damping>10.0</damping>
      <!-- Friction for realistic joint behavior -->
      <friction>5.0</friction>
      <!-- Spring properties -->
      <spring_reference>0.0</spring_reference>
      <spring_stiffness>0.0</spring_stiffness>
    </dynamics>
  </axis>
  <!-- Joint physics for more advanced properties -->
  <physics>
    <ode>
      <limit>
        <cfm>0.0</cfm>
        <erp>0.2</erp>
      </limit>
      <suspension>
        <cfm>0.0</cfm>
        <erp>0.2</erp>
      </suspension>
    </ode>
  </physics>
</joint>
```

## Performance Optimization Strategies

### Time Step Optimization

The time step significantly affects both accuracy and performance:

```xml
<!-- For real-time simulation -->
<max_step_size>0.001</max_step_size>
<real_time_update_rate>1000</real_time_update_rate>

<!-- For more accurate simulation -->
<max_step_size>0.0001</max_step_size>
<real_time_update_rate>10000</real_time_update_rate>

<!-- Balance between accuracy and performance -->
<max_step_size>0.0005</max_step_size>
<real_time_update_rate>2000</real_time_update_rate>
```

### Solver Parameter Tuning

Adjust solver parameters based on your simulation requirements:

```xml
<ode>
  <solver>
    <!-- More iterations = more stable but slower -->
    <iters>1000</iters>
    <!-- SOR over-relaxation parameter -->
    <sor>1.3</sor>
  </solver>
</ode>
```

## Physics Engine Benchmarking

To determine the best physics engine for your specific humanoid robot application, consider these benchmarking criteria:

1. **Stability**: How well does the robot maintain balance?
2. **Accuracy**: How closely does the simulation match expected physical behavior?
3. **Performance**: What is the real-time factor achieved?
4. **Contact Quality**: How realistic are the contact interactions?

### Simple Benchmark Test

Create a simple test to compare physics engines:

```python
#!/usr/bin/env python3
"""
Simple physics engine benchmark for humanoid robots
"""
import time
import subprocess
import argparse

def benchmark_physics_engine(engine_type, world_file, duration=10):
    """Benchmark a specific physics engine"""
    start_time = time.time()

    # Launch Gazebo with specific physics engine
    cmd = [
        'gz', 'sim',
        '-r',  # Run in headless mode
        f'--physics-engine={engine_type}',
        world_file
    ]

    print(f"Benchmarking {engine_type} for {duration} seconds...")

    # In a real implementation, you would run the simulation
    # and measure real-time factor and stability metrics
    time.sleep(duration)  # Simulate running the simulation

    end_time = time.time()
    actual_duration = end_time - start_time

    # Calculate real-time factor
    real_time_factor = duration / actual_duration

    print(f"Physics Engine: {engine_type}")
    print(f"Requested Duration: {duration}s")
    print(f"Actual Duration: {actual_duration:.2f}s")
    print(f"Real-time Factor: {real_time_factor:.2f}")

    return real_time_factor

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Physics Engine Benchmark')
    parser.add_argument('--engine', type=str, required=True,
                       choices=['ode', 'bullet', 'simbody'],
                       help='Physics engine to benchmark')
    parser.add_argument('--world', type=str, required=True,
                       help='World file to use for benchmarking')
    parser.add_argument('--duration', type=int, default=10,
                       help='Duration of benchmark in seconds')

    args = parser.parse_args()

    benchmark_physics_engine(args.engine, args.world, args.duration)
```

## Troubleshooting Common Physics Issues

### 1. Unstable Contact Simulation

**Symptoms**: Robot jitters, falls through surfaces, or exhibits unrealistic bouncing.

**Solutions**:
- Increase solver iterations
- Decrease time step
- Adjust ERP and CFM values
- Check collision geometry for proper overlap

### 2. Slow Performance

**Symptoms**: Low real-time factor, simulation lag.

**Solutions**:
- Increase time step (trade accuracy for speed)
- Reduce solver iterations
- Simplify collision geometry
- Use static models where possible

### 3. Penetration Issues

**Symptoms**: Objects pass through each other.

**Solutions**:
- Decrease time step
- Increase ERP
- Improve collision geometry
- Use continuous collision detection (for Bullet)

## Best Practices for Physics Configuration

### 1. Start Conservative
Begin with conservative settings and gradually optimize for performance while maintaining stability.

### 2. Match Real-World Properties
Use physical properties that match your real robot as closely as possible.

### 3. Validate with Simple Tests
Test physics configurations with simple scenarios before complex humanoid behaviors.

### 4. Document Configuration Changes
Keep track of physics parameters that work well for your specific robot design.

The choice of physics engine and its configuration significantly impacts the quality and realism of humanoid robot simulations. By understanding the strengths and characteristics of each engine, you can optimize your simulation for the specific requirements of your Physical AI applications.
